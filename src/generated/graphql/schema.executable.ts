// @ts-nocheck
/* eslint-disable graphile-export/export-instances, graphile-export/export-methods, graphile-export/export-plans, graphile-export/exhaustive-deps */
import { PgCondition, PgDeleteSingleStep, PgExecutor, TYPES, assertPgClassSingleStep, enumCodec, listOfCodec, makeRegistry, pgDeleteSingle, pgInsertSingle, pgSelectFromRecord, pgUpdateSingle, recordCodec, sqlValueWithCodec } from "@dataplan/pg";
import { ConnectionStep, EdgeStep, ObjectStep, __ValueStep, access, assertExecutableStep, bakedInputRuntime, connection, constant, context, createObjectAndApplyChildren, first, get as get2, inhibitOnNull, inspect, lambda, list, makeDecodeNodeId, makeGrafastSchema, object, rootValue, specFromNodeId } from "grafast";
import { GraphQLError, Kind } from "graphql";
import { sql } from "pg-sql2";
const nodeIdHandler_Query = {
  typeName: "Query",
  codec: {
    name: "raw",
    encode: Object.assign(function rawEncode(value) {
      return typeof value === "string" ? value : null;
    }, {
      isSyncAndSafe: true
    }),
    decode: Object.assign(function rawDecode(value) {
      return typeof value === "string" ? value : null;
    }, {
      isSyncAndSafe: true
    })
  },
  match(specifier) {
    return specifier === "query";
  },
  getIdentifiers(_value) {
    return [];
  },
  getSpec() {
    return "irrelevant";
  },
  get() {
    return rootValue();
  },
  plan() {
    return constant`query`;
  }
};
const nodeIdCodecs_base64JSON_base64JSON = {
  name: "base64JSON",
  encode: (() => {
    function base64JSONEncode(value) {
      return Buffer.from(JSON.stringify(value), "utf8").toString("base64");
    }
    base64JSONEncode.isSyncAndSafe = !0;
    return base64JSONEncode;
  })(),
  decode: (() => {
    function base64JSONDecode(value) {
      return JSON.parse(Buffer.from(value, "base64").toString("utf8"));
    }
    base64JSONDecode.isSyncAndSafe = !0;
    return base64JSONDecode;
  })()
};
const nodeIdCodecs = {
  __proto__: null,
  raw: nodeIdHandler_Query.codec,
  base64JSON: nodeIdCodecs_base64JSON_base64JSON,
  pipeString: {
    name: "pipeString",
    encode: Object.assign(function pipeStringEncode(value) {
      return Array.isArray(value) ? value.join("|") : null;
    }, {
      isSyncAndSafe: true
    }),
    decode: Object.assign(function pipeStringDecode(value) {
      return typeof value === "string" ? value.split("|") : null;
    }, {
      isSyncAndSafe: true
    })
  }
};
const executor = new PgExecutor({
  name: "main",
  context() {
    const ctx = context();
    return object({
      pgSettings: "pgSettings" != null ? ctx.get("pgSettings") : constant(null),
      withPgClient: ctx.get("withPgClient")
    });
  }
});
const userOrganizationIdentifier = sql.identifier("public", "user_organization");
const organizationRoleCodec = enumCodec({
  name: "organizationRole",
  identifier: sql.identifier("public", "organization_role"),
  values: ["owner", "admin", "member"],
  description: undefined,
  extensions: {
    oid: "204974",
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "organization_role"
    },
    tags: {
      __proto__: null
    }
  }
});
const spec_userOrganization = {
  name: "userOrganization",
  identifier: userOrganizationIdentifier,
  attributes: {
    __proto__: null,
    id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    user_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    organization_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    role: {
      description: undefined,
      codec: organizationRoleCodec,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    created_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    updated_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    }
  },
  description: undefined,
  extensions: {
    oid: "205228",
    isTableLike: true,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "user_organization"
    },
    tags: {
      __proto__: null
    }
  },
  executor: executor
};
const userOrganizationCodec = recordCodec(spec_userOrganization);
const bountyFundingIdentifier = sql.identifier("public", "bounty_funding");
const spec_bountyFunding = {
  name: "bountyFunding",
  identifier: bountyFundingIdentifier,
  attributes: {
    __proto__: null,
    id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    bounty_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    funder_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    amount: {
      description: undefined,
      codec: TYPES.numeric,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    currency: {
      description: undefined,
      codec: TYPES.text,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    message: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    transaction_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    created_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    updated_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    }
  },
  description: undefined,
  extensions: {
    oid: "205090",
    isTableLike: true,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "bounty_funding"
    },
    tags: {
      __proto__: null
    }
  },
  executor: executor
};
const bountyFundingCodec = recordCodec(spec_bountyFunding);
const userIdentifier = sql.identifier("public", "user");
const spec_user = {
  name: "user",
  identifier: userIdentifier,
  attributes: {
    __proto__: null,
    id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    created_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    updated_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    display_name: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    username: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    avatar_url: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    bio: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    website_url: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    deleted_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    }
  },
  description: undefined,
  extensions: {
    oid: "16411",
    isTableLike: true,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "user"
    },
    tags: {
      __proto__: null
    }
  },
  executor: executor
};
const userCodec = recordCodec(spec_user);
const webhookEndpointIdentifier = sql.identifier("public", "webhook_endpoint");
const spec_webhookEndpoint = {
  name: "webhookEndpoint",
  identifier: webhookEndpointIdentifier,
  attributes: {
    __proto__: null,
    id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    organization_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    url: {
      description: undefined,
      codec: TYPES.text,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    secret: {
      description: undefined,
      codec: TYPES.text,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    description: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    events: {
      description: undefined,
      codec: TYPES.text,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    is_active: {
      description: undefined,
      codec: TYPES.boolean,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    created_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    updated_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    deleted_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    }
  },
  description: undefined,
  extensions: {
    oid: "205359",
    isTableLike: true,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "webhook_endpoint"
    },
    tags: {
      __proto__: null
    }
  },
  executor: executor
};
const webhookEndpointCodec = recordCodec(spec_webhookEndpoint);
const workspaceIdentifier = sql.identifier("public", "workspace");
const spec_workspace = {
  name: "workspace",
  identifier: workspaceIdentifier,
  attributes: {
    __proto__: null,
    id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    organization_id: {
      description: undefined,
      codec: TYPES.text,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    name: {
      description: undefined,
      codec: TYPES.text,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    slug: {
      description: undefined,
      codec: TYPES.text,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    created_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    updated_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    deleted_at: {
      description: undefined,
      codec: TYPES.timestamp,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    deletion_reason: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    }
  },
  description: undefined,
  extensions: {
    oid: "335037",
    isTableLike: true,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "workspace"
    },
    tags: {
      __proto__: null
    }
  },
  executor: executor
};
const workspaceCodec = recordCodec(spec_workspace);
const donationIdentifier = sql.identifier("public", "donation");
const spec_donation = {
  name: "donation",
  identifier: donationIdentifier,
  attributes: {
    __proto__: null,
    id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    donor_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    organization_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    amount: {
      description: undefined,
      codec: TYPES.numeric,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    currency: {
      description: undefined,
      codec: TYPES.text,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    is_public: {
      description: undefined,
      codec: TYPES.boolean,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    is_anonymous: {
      description: undefined,
      codec: TYPES.boolean,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    public_message: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    transaction_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    created_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    }
  },
  description: undefined,
  extensions: {
    oid: "205106",
    isTableLike: true,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "donation"
    },
    tags: {
      __proto__: null
    }
  },
  executor: executor
};
const donationCodec = recordCodec(spec_donation);
const goalIdentifier = sql.identifier("public", "goal");
const spec_goal = {
  name: "goal",
  identifier: goalIdentifier,
  attributes: {
    __proto__: null,
    id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    organization_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    title: {
      description: undefined,
      codec: TYPES.text,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    description: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    target_amount: {
      description: undefined,
      codec: TYPES.numeric,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    currency: {
      description: undefined,
      codec: TYPES.text,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    current_amount: {
      description: undefined,
      codec: TYPES.numeric,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    display_order: {
      description: undefined,
      codec: TYPES.int,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    is_active: {
      description: undefined,
      codec: TYPES.boolean,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    is_completed: {
      description: undefined,
      codec: TYPES.boolean,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    completed_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    created_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    updated_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    }
  },
  description: undefined,
  extensions: {
    oid: "326533",
    isTableLike: true,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "goal"
    },
    tags: {
      __proto__: null
    }
  },
  executor: executor
};
const goalCodec = recordCodec(spec_goal);
const userIdentityIdentifier = sql.identifier("public", "user_identity");
const identityProviderCodec = enumCodec({
  name: "identityProvider",
  identifier: sql.identifier("public", "identity_provider"),
  values: ["github", "gitlab", "hidra"],
  description: undefined,
  extensions: {
    oid: "204966",
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "identity_provider"
    },
    tags: {
      __proto__: null
    }
  }
});
const spec_userIdentity = {
  name: "userIdentity",
  identifier: userIdentityIdentifier,
  attributes: {
    __proto__: null,
    id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    user_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    provider: {
      description: undefined,
      codec: identityProviderCodec,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    provider_user_id: {
      description: undefined,
      codec: TYPES.text,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    provider_username: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    provider_email: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    access_token: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    refresh_token: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    token_expires_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    created_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    updated_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    }
  },
  description: undefined,
  extensions: {
    oid: "205190",
    isTableLike: true,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "user_identity"
    },
    tags: {
      __proto__: null
    }
  },
  executor: executor
};
const userIdentityCodec = recordCodec(spec_userIdentity);
const webhookDeliveryIdentifier = sql.identifier("public", "webhook_delivery");
const spec_webhookDelivery = {
  name: "webhookDelivery",
  identifier: webhookDeliveryIdentifier,
  attributes: {
    __proto__: null,
    id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    webhook_endpoint_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    event_type: {
      description: undefined,
      codec: TYPES.text,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    payload: {
      description: undefined,
      codec: TYPES.text,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    is_successful: {
      description: undefined,
      codec: TYPES.boolean,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    http_status_code: {
      description: undefined,
      codec: TYPES.int,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    response_body: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    error_message: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    attempt_count: {
      description: undefined,
      codec: TYPES.int,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    next_retry_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    delivered_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    created_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    }
  },
  description: undefined,
  extensions: {
    oid: "205377",
    isTableLike: true,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "webhook_delivery"
    },
    tags: {
      __proto__: null
    }
  },
  executor: executor
};
const webhookDeliveryCodec = recordCodec(spec_webhookDelivery);
const sponsorshipTierIdentifier = sql.identifier("public", "sponsorship_tier");
const spec_sponsorshipTier = {
  name: "sponsorshipTier",
  identifier: sponsorshipTierIdentifier,
  attributes: {
    __proto__: null,
    id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    organization_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    name: {
      description: undefined,
      codec: TYPES.text,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    description: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    benefits: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    monthly_amount: {
      description: undefined,
      codec: TYPES.numeric,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    yearly_amount: {
      description: undefined,
      codec: TYPES.numeric,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    currency: {
      description: undefined,
      codec: TYPES.text,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    display_order: {
      description: undefined,
      codec: TYPES.int,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    is_active: {
      description: undefined,
      codec: TYPES.boolean,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    is_highlighted: {
      description: undefined,
      codec: TYPES.boolean,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    max_sponsors: {
      description: undefined,
      codec: TYPES.int,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    created_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    updated_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    deleted_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    }
  },
  description: undefined,
  extensions: {
    oid: "205241",
    isTableLike: true,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "sponsorship_tier"
    },
    tags: {
      __proto__: null
    }
  },
  executor: executor
};
const sponsorshipTierCodec = recordCodec(spec_sponsorshipTier);
const paymentProcessorConnectionIdentifier = sql.identifier("public", "payment_processor_connection");
const paymentProcessorCodec = enumCodec({
  name: "paymentProcessor",
  identifier: sql.identifier("public", "payment_processor"),
  values: ["stripe_connect", "paypal", "venmo", "crypto_btc", "crypto_eth", "crypto_usdc"],
  description: undefined,
  extensions: {
    oid: "204990",
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "payment_processor"
    },
    tags: {
      __proto__: null
    }
  }
});
const spec_paymentProcessorConnection = {
  name: "paymentProcessorConnection",
  identifier: paymentProcessorConnectionIdentifier,
  attributes: {
    __proto__: null,
    id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    organization_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    processor: {
      description: undefined,
      codec: paymentProcessorCodec,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    external_account_id: {
      description: undefined,
      codec: TYPES.text,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    display_name: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    is_active: {
      description: undefined,
      codec: TYPES.boolean,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    is_primary: {
      description: undefined,
      codec: TYPES.boolean,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    is_verified: {
      description: undefined,
      codec: TYPES.boolean,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    verified_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    metadata: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    created_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    updated_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    deleted_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    }
  },
  description: undefined,
  extensions: {
    oid: "205291",
    isTableLike: true,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "payment_processor_connection"
    },
    tags: {
      __proto__: null
    }
  },
  executor: executor
};
const paymentProcessorConnectionCodec = recordCodec(spec_paymentProcessorConnection);
const auditLogIdentifier = sql.identifier("public", "audit_log");
const auditActionCodec = enumCodec({
  name: "auditAction",
  identifier: sql.identifier("public", "audit_action"),
  values: ["create", "update", "delete", "status_change", "payment_initiated", "payment_completed", "payment_failed", "refund_initiated", "refund_completed"],
  description: undefined,
  extensions: {
    oid: "204898",
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "audit_action"
    },
    tags: {
      __proto__: null
    }
  }
});
const spec_auditLog = {
  name: "auditLog",
  identifier: auditLogIdentifier,
  attributes: {
    __proto__: null,
    id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    actor_user_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    actor_ip_address: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    actor_user_agent: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    organization_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    target_entity_type: {
      description: undefined,
      codec: TYPES.text,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    target_entity_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    action: {
      description: undefined,
      codec: auditActionCodec,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    previous_state: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    new_state: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    metadata: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    created_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    }
  },
  description: undefined,
  extensions: {
    oid: "205055",
    isTableLike: true,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "audit_log"
    },
    tags: {
      __proto__: null
    }
  },
  executor: executor
};
const auditLogCodec = recordCodec(spec_auditLog);
const postIdentifier = sql.identifier("public", "post");
const postVisibilityCodec = enumCodec({
  name: "postVisibility",
  identifier: sql.identifier("public", "post_visibility"),
  values: ["public", "supporters_only", "tier_gated"],
  description: undefined,
  extensions: {
    oid: "326511",
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "post_visibility"
    },
    tags: {
      __proto__: null
    }
  }
});
const spec_post = {
  name: "post",
  identifier: postIdentifier,
  attributes: {
    __proto__: null,
    id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    organization_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    author_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    title: {
      description: undefined,
      codec: TYPES.text,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    content: {
      description: undefined,
      codec: TYPES.text,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    excerpt: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    visibility: {
      description: undefined,
      codec: postVisibilityCodec,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    minimum_tier_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    is_published: {
      description: undefined,
      codec: TYPES.boolean,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    published_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    created_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    updated_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    deleted_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    }
  },
  description: undefined,
  extensions: {
    oid: "326558",
    isTableLike: true,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "post"
    },
    tags: {
      __proto__: null
    }
  },
  executor: executor
};
const postCodec = recordCodec(spec_post);
const grantProgramIdentifier = sql.identifier("public", "grant_program");
const spec_grantProgram = {
  name: "grantProgram",
  identifier: grantProgramIdentifier,
  attributes: {
    __proto__: null,
    id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    organization_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    name: {
      description: undefined,
      codec: TYPES.text,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    slug: {
      description: undefined,
      codec: TYPES.text,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    description: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    guidelines: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    total_budget: {
      description: undefined,
      codec: TYPES.numeric,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    remaining_budget: {
      description: undefined,
      codec: TYPES.numeric,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    currency: {
      description: undefined,
      codec: TYPES.text,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    min_grant_amount: {
      description: undefined,
      codec: TYPES.numeric,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    max_grant_amount: {
      description: undefined,
      codec: TYPES.numeric,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    is_active: {
      description: undefined,
      codec: TYPES.boolean,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    applications_open_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    applications_close_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    created_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    updated_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    deleted_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    }
  },
  description: undefined,
  extensions: {
    oid: "205169",
    isTableLike: true,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "grant_program"
    },
    tags: {
      __proto__: null
    }
  },
  executor: executor
};
const grantProgramCodec = recordCodec(spec_grantProgram);
const organizationIdentifier = sql.identifier("public", "organization");
const organizationTypeCodec = enumCodec({
  name: "organizationType",
  identifier: sql.identifier("public", "organization_type"),
  values: ["foss_project", "nonprofit", "commercial"],
  description: undefined,
  extensions: {
    oid: "204982",
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "organization_type"
    },
    tags: {
      __proto__: null
    }
  }
});
const spec_organization = {
  name: "organization",
  identifier: organizationIdentifier,
  attributes: {
    __proto__: null,
    id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    name: {
      description: undefined,
      codec: TYPES.text,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    slug: {
      description: undefined,
      codec: TYPES.text,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    description: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    avatar_url: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    website_url: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    organization_type: {
      description: undefined,
      codec: organizationTypeCodec,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    platform_fee_percent: {
      description: undefined,
      codec: TYPES.numeric,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    is_verified: {
      description: undefined,
      codec: TYPES.boolean,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    verified_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    created_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    updated_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    deleted_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    }
  },
  description: undefined,
  extensions: {
    oid: "205205",
    isTableLike: true,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "organization"
    },
    tags: {
      __proto__: null
    }
  },
  executor: executor
};
const organizationCodec = recordCodec(spec_organization);
const grantApplicationIdentifier = sql.identifier("public", "grant_application");
const grantApplicationStatusCodec = enumCodec({
  name: "grantApplicationStatus",
  identifier: sql.identifier("public", "grant_application_status"),
  values: ["draft", "submitted", "under_review", "approved", "rejected", "funded", "completed", "cancelled"],
  description: undefined,
  extensions: {
    oid: "204934",
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "grant_application_status"
    },
    tags: {
      __proto__: null
    }
  }
});
const spec_grantApplication = {
  name: "grantApplication",
  identifier: grantApplicationIdentifier,
  attributes: {
    __proto__: null,
    id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    grant_program_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    applicant_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    title: {
      description: undefined,
      codec: TYPES.text,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    description: {
      description: undefined,
      codec: TYPES.text,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    proposed_amount: {
      description: undefined,
      codec: TYPES.numeric,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    currency: {
      description: undefined,
      codec: TYPES.text,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    approved_amount: {
      description: undefined,
      codec: TYPES.numeric,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    status: {
      description: undefined,
      codec: grantApplicationStatusCodec,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    submitted_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    reviewed_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    reviewed_by_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    review_notes: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    created_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    updated_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    }
  },
  description: undefined,
  extensions: {
    oid: "205124",
    isTableLike: true,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "grant_application"
    },
    tags: {
      __proto__: null
    }
  },
  executor: executor
};
const grantApplicationCodec = recordCodec(spec_grantApplication);
const payoutIdentifier = sql.identifier("public", "payout");
const transactionStatusCodec = enumCodec({
  name: "transactionStatus",
  identifier: sql.identifier("public", "transaction_status"),
  values: ["pending", "processing", "completed", "failed", "refunded", "partially_refunded"],
  description: undefined,
  extensions: {
    oid: "205022",
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "transaction_status"
    },
    tags: {
      __proto__: null
    }
  }
});
const spec_payout = {
  name: "payout",
  identifier: payoutIdentifier,
  attributes: {
    __proto__: null,
    id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    recipient_user_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    from_organization_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    processor_connection_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    processor: {
      description: undefined,
      codec: paymentProcessorCodec,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    external_payout_id: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    amount: {
      description: undefined,
      codec: TYPES.numeric,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    fee_amount: {
      description: undefined,
      codec: TYPES.numeric,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    currency: {
      description: undefined,
      codec: TYPES.text,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    status: {
      description: undefined,
      codec: transactionStatusCodec,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    description: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    failure_reason: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    initiated_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    completed_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    created_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    updated_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    }
  },
  description: undefined,
  extensions: {
    oid: "205337",
    isTableLike: true,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "payout"
    },
    tags: {
      __proto__: null
    }
  },
  executor: executor
};
const payoutCodec = recordCodec(spec_payout);
const grantMilestoneIdentifier = sql.identifier("public", "grant_milestone");
const grantMilestoneStatusCodec = enumCodec({
  name: "grantMilestoneStatus",
  identifier: sql.identifier("public", "grant_milestone_status"),
  values: ["pending", "in_progress", "submitted", "approved", "rejected", "paid"],
  description: undefined,
  extensions: {
    oid: "204952",
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "grant_milestone_status"
    },
    tags: {
      __proto__: null
    }
  }
});
const spec_grantMilestone = {
  name: "grantMilestone",
  identifier: grantMilestoneIdentifier,
  attributes: {
    __proto__: null,
    id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    grant_application_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    title: {
      description: undefined,
      codec: TYPES.text,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    description: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    sequence_order: {
      description: undefined,
      codec: TYPES.int,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    amount: {
      description: undefined,
      codec: TYPES.numeric,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    currency: {
      description: undefined,
      codec: TYPES.text,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    status: {
      description: undefined,
      codec: grantMilestoneStatusCodec,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    due_date: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    submitted_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    approved_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    paid_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    transaction_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    created_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    updated_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    }
  },
  description: undefined,
  extensions: {
    oid: "205146",
    isTableLike: true,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "grant_milestone"
    },
    tags: {
      __proto__: null
    }
  },
  executor: executor
};
const grantMilestoneCodec = recordCodec(spec_grantMilestone);
const bountyIdentifier = sql.identifier("public", "bounty");
const bountySourceTypeCodec = enumCodec({
  name: "bountySourceType",
  identifier: sql.identifier("public", "bounty_source_type"),
  values: ["external_url", "arbor"],
  description: undefined,
  extensions: {
    oid: "204918",
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "bounty_source_type"
    },
    tags: {
      __proto__: null
    }
  }
});
const bountyStatusCodec = enumCodec({
  name: "bountyStatus",
  identifier: sql.identifier("public", "bounty_status"),
  values: ["open", "in_progress", "completed", "cancelled"],
  description: undefined,
  extensions: {
    oid: "204924",
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "bounty_status"
    },
    tags: {
      __proto__: null
    }
  }
});
const spec_bounty = {
  name: "bounty",
  identifier: bountyIdentifier,
  attributes: {
    __proto__: null,
    id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    organization_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    source_type: {
      description: undefined,
      codec: bountySourceTypeCodec,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    external_url: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    arbor_issue_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    title: {
      description: undefined,
      codec: TYPES.text,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    description: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    target_amount: {
      description: undefined,
      codec: TYPES.numeric,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    currency: {
      description: undefined,
      codec: TYPES.text,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    status: {
      description: undefined,
      codec: bountyStatusCodec,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    claimant_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    claimed_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    completed_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    expires_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    created_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    updated_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    deleted_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    }
  },
  description: undefined,
  extensions: {
    oid: "205068",
    isTableLike: true,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "bounty"
    },
    tags: {
      __proto__: null
    }
  },
  executor: executor
};
const bountyCodec = recordCodec(spec_bounty);
const sponsorshipFrequencyCodec = enumCodec({
  name: "sponsorshipFrequency",
  identifier: sql.identifier("public", "sponsorship_frequency"),
  values: ["one_time", "monthly", "yearly"],
  description: undefined,
  extensions: {
    oid: "205004",
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "sponsorship_frequency"
    },
    tags: {
      __proto__: null
    }
  }
});
const sponsorshipStatusCodec = enumCodec({
  name: "sponsorshipStatus",
  identifier: sql.identifier("public", "sponsorship_status"),
  values: ["active", "paused", "cancelled", "expired"],
  description: undefined,
  extensions: {
    oid: "205012",
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "sponsorship_status"
    },
    tags: {
      __proto__: null
    }
  }
});
const transactionTypeCodec = enumCodec({
  name: "transactionType",
  identifier: sql.identifier("public", "transaction_type"),
  values: ["bounty_funding", "bounty_payout", "grant_funding", "grant_milestone_payout", "sponsorship", "donation", "refund", "fee"],
  description: undefined,
  extensions: {
    oid: "205036",
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "transaction_type"
    },
    tags: {
      __proto__: null
    }
  }
});
const sponsorshipIdentifier = sql.identifier("public", "sponsorship");
const spec_sponsorship = {
  name: "sponsorship",
  identifier: sponsorshipIdentifier,
  attributes: {
    __proto__: null,
    id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    sponsor_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    organization_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    tier_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    amount: {
      description: undefined,
      codec: TYPES.numeric,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    currency: {
      description: undefined,
      codec: TYPES.text,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    frequency: {
      description: undefined,
      codec: sponsorshipFrequencyCodec,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    status: {
      description: undefined,
      codec: sponsorshipStatusCodec,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    current_period_start: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    current_period_end: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    next_billing_date: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    is_public: {
      description: undefined,
      codec: TYPES.boolean,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    public_message: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    external_subscription_id: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    started_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    cancelled_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    created_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    updated_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    }
  },
  description: undefined,
  extensions: {
    oid: "205264",
    isTableLike: true,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "sponsorship"
    },
    tags: {
      __proto__: null
    }
  },
  executor: executor
};
const sponsorshipCodec = recordCodec(spec_sponsorship);
const transactionIdentifier = sql.identifier("public", "transaction");
const spec_transaction = {
  name: "transaction",
  identifier: transactionIdentifier,
  attributes: {
    __proto__: null,
    id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    from_user_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    to_organization_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    to_user_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    processor_connection_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    processor: {
      description: undefined,
      codec: paymentProcessorCodec,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    external_transaction_id: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    gross_amount: {
      description: undefined,
      codec: TYPES.numeric,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    platform_fee_amount: {
      description: undefined,
      codec: TYPES.numeric,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    processor_fee_amount: {
      description: undefined,
      codec: TYPES.numeric,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    net_amount: {
      description: undefined,
      codec: TYPES.numeric,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    currency: {
      description: undefined,
      codec: TYPES.text,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    transaction_type: {
      description: undefined,
      codec: transactionTypeCodec,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    status: {
      description: undefined,
      codec: transactionStatusCodec,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    description: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    metadata: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    failure_reason: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    refunded_amount: {
      description: undefined,
      codec: TYPES.numeric,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    original_transaction_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    processed_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    },
    created_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    updated_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        isIndexed: false
      }
    }
  },
  description: undefined,
  extensions: {
    oid: "205313",
    isTableLike: true,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "transaction"
    },
    tags: {
      __proto__: null
    }
  },
  executor: executor
};
const transactionCodec = recordCodec(spec_transaction);
const user_organizationUniques = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: {
      __proto__: null
    }
  }
}];
const registryConfig_pgResources_user_organization_user_organization = {
  executor: executor,
  name: "user_organization",
  identifier: "main.public.user_organization",
  from: userOrganizationIdentifier,
  codec: userOrganizationCodec,
  uniques: user_organizationUniques,
  isVirtual: false,
  description: undefined,
  extensions: {
    description: undefined,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "user_organization"
    },
    isInsertable: true,
    isUpdatable: true,
    isDeletable: true,
    tags: {},
    canSelect: true,
    canInsert: true,
    canUpdate: true,
    canDelete: true
  }
};
const bounty_fundingUniques = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: {
      __proto__: null
    }
  }
}];
const registryConfig_pgResources_bounty_funding_bounty_funding = {
  executor: executor,
  name: "bounty_funding",
  identifier: "main.public.bounty_funding",
  from: bountyFundingIdentifier,
  codec: bountyFundingCodec,
  uniques: bounty_fundingUniques,
  isVirtual: false,
  description: undefined,
  extensions: {
    description: undefined,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "bounty_funding"
    },
    isInsertable: true,
    isUpdatable: true,
    isDeletable: true,
    tags: {},
    canSelect: true,
    canInsert: true,
    canUpdate: true,
    canDelete: true
  }
};
const userUniques = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: {
      __proto__: null
    }
  }
}, {
  isPrimary: false,
  attributes: ["username"],
  description: undefined,
  extensions: {
    tags: {
      __proto__: null
    }
  }
}];
const registryConfig_pgResources_user_user = {
  executor: executor,
  name: "user",
  identifier: "main.public.user",
  from: userIdentifier,
  codec: userCodec,
  uniques: userUniques,
  isVirtual: false,
  description: undefined,
  extensions: {
    description: undefined,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "user"
    },
    isInsertable: true,
    isUpdatable: true,
    isDeletable: true,
    tags: {},
    canSelect: true,
    canInsert: true,
    canUpdate: true,
    canDelete: true
  }
};
const webhook_endpointUniques = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: {
      __proto__: null
    }
  }
}];
const registryConfig_pgResources_webhook_endpoint_webhook_endpoint = {
  executor: executor,
  name: "webhook_endpoint",
  identifier: "main.public.webhook_endpoint",
  from: webhookEndpointIdentifier,
  codec: webhookEndpointCodec,
  uniques: webhook_endpointUniques,
  isVirtual: false,
  description: undefined,
  extensions: {
    description: undefined,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "webhook_endpoint"
    },
    isInsertable: true,
    isUpdatable: true,
    isDeletable: true,
    tags: {},
    canSelect: true,
    canInsert: true,
    canUpdate: true,
    canDelete: true
  }
};
const workspaceUniques = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: {
      __proto__: null
    }
  }
}];
const donationUniques = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: {
      __proto__: null
    }
  }
}];
const registryConfig_pgResources_donation_donation = {
  executor: executor,
  name: "donation",
  identifier: "main.public.donation",
  from: donationIdentifier,
  codec: donationCodec,
  uniques: donationUniques,
  isVirtual: false,
  description: undefined,
  extensions: {
    description: undefined,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "donation"
    },
    isInsertable: true,
    isUpdatable: true,
    isDeletable: true,
    tags: {},
    canSelect: true,
    canInsert: true,
    canUpdate: true,
    canDelete: true
  }
};
const goalUniques = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: {
      __proto__: null
    }
  }
}];
const registryConfig_pgResources_goal_goal = {
  executor: executor,
  name: "goal",
  identifier: "main.public.goal",
  from: goalIdentifier,
  codec: goalCodec,
  uniques: goalUniques,
  isVirtual: false,
  description: undefined,
  extensions: {
    description: undefined,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "goal"
    },
    isInsertable: true,
    isUpdatable: true,
    isDeletable: true,
    tags: {},
    canSelect: true,
    canInsert: true,
    canUpdate: true,
    canDelete: true
  }
};
const user_identityUniques = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: {
      __proto__: null
    }
  }
}];
const registryConfig_pgResources_user_identity_user_identity = {
  executor: executor,
  name: "user_identity",
  identifier: "main.public.user_identity",
  from: userIdentityIdentifier,
  codec: userIdentityCodec,
  uniques: user_identityUniques,
  isVirtual: false,
  description: undefined,
  extensions: {
    description: undefined,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "user_identity"
    },
    isInsertable: true,
    isUpdatable: true,
    isDeletable: true,
    tags: {},
    canSelect: true,
    canInsert: true,
    canUpdate: true,
    canDelete: true
  }
};
const webhook_deliveryUniques = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: {
      __proto__: null
    }
  }
}];
const registryConfig_pgResources_webhook_delivery_webhook_delivery = {
  executor: executor,
  name: "webhook_delivery",
  identifier: "main.public.webhook_delivery",
  from: webhookDeliveryIdentifier,
  codec: webhookDeliveryCodec,
  uniques: webhook_deliveryUniques,
  isVirtual: false,
  description: undefined,
  extensions: {
    description: undefined,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "webhook_delivery"
    },
    isInsertable: true,
    isUpdatable: true,
    isDeletable: true,
    tags: {},
    canSelect: true,
    canInsert: true,
    canUpdate: true,
    canDelete: true
  }
};
const sponsorship_tierUniques = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: {
      __proto__: null
    }
  }
}];
const registryConfig_pgResources_sponsorship_tier_sponsorship_tier = {
  executor: executor,
  name: "sponsorship_tier",
  identifier: "main.public.sponsorship_tier",
  from: sponsorshipTierIdentifier,
  codec: sponsorshipTierCodec,
  uniques: sponsorship_tierUniques,
  isVirtual: false,
  description: undefined,
  extensions: {
    description: undefined,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "sponsorship_tier"
    },
    isInsertable: true,
    isUpdatable: true,
    isDeletable: true,
    tags: {},
    canSelect: true,
    canInsert: true,
    canUpdate: true,
    canDelete: true
  }
};
const payment_processor_connectionUniques = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: {
      __proto__: null
    }
  }
}];
const registryConfig_pgResources_payment_processor_connection_payment_processor_connection = {
  executor: executor,
  name: "payment_processor_connection",
  identifier: "main.public.payment_processor_connection",
  from: paymentProcessorConnectionIdentifier,
  codec: paymentProcessorConnectionCodec,
  uniques: payment_processor_connectionUniques,
  isVirtual: false,
  description: undefined,
  extensions: {
    description: undefined,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "payment_processor_connection"
    },
    isInsertable: true,
    isUpdatable: true,
    isDeletable: true,
    tags: {},
    canSelect: true,
    canInsert: true,
    canUpdate: true,
    canDelete: true
  }
};
const audit_logUniques = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: {
      __proto__: null
    }
  }
}];
const registryConfig_pgResources_audit_log_audit_log = {
  executor: executor,
  name: "audit_log",
  identifier: "main.public.audit_log",
  from: auditLogIdentifier,
  codec: auditLogCodec,
  uniques: audit_logUniques,
  isVirtual: false,
  description: undefined,
  extensions: {
    description: undefined,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "audit_log"
    },
    isInsertable: true,
    isUpdatable: true,
    isDeletable: true,
    tags: {},
    canSelect: true,
    canInsert: true,
    canUpdate: true,
    canDelete: true
  }
};
const postUniques = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: {
      __proto__: null
    }
  }
}];
const registryConfig_pgResources_post_post = {
  executor: executor,
  name: "post",
  identifier: "main.public.post",
  from: postIdentifier,
  codec: postCodec,
  uniques: postUniques,
  isVirtual: false,
  description: undefined,
  extensions: {
    description: undefined,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "post"
    },
    isInsertable: true,
    isUpdatable: true,
    isDeletable: true,
    tags: {},
    canSelect: true,
    canInsert: true,
    canUpdate: true,
    canDelete: true
  }
};
const grant_programUniques = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: {
      __proto__: null
    }
  }
}];
const registryConfig_pgResources_grant_program_grant_program = {
  executor: executor,
  name: "grant_program",
  identifier: "main.public.grant_program",
  from: grantProgramIdentifier,
  codec: grantProgramCodec,
  uniques: grant_programUniques,
  isVirtual: false,
  description: undefined,
  extensions: {
    description: undefined,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "grant_program"
    },
    isInsertable: true,
    isUpdatable: true,
    isDeletable: true,
    tags: {},
    canSelect: true,
    canInsert: true,
    canUpdate: true,
    canDelete: true
  }
};
const organizationUniques = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: {
      __proto__: null
    }
  }
}, {
  isPrimary: false,
  attributes: ["slug"],
  description: undefined,
  extensions: {
    tags: {
      __proto__: null
    }
  }
}];
const registryConfig_pgResources_organization_organization = {
  executor: executor,
  name: "organization",
  identifier: "main.public.organization",
  from: organizationIdentifier,
  codec: organizationCodec,
  uniques: organizationUniques,
  isVirtual: false,
  description: undefined,
  extensions: {
    description: undefined,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "organization"
    },
    isInsertable: true,
    isUpdatable: true,
    isDeletable: true,
    tags: {},
    canSelect: true,
    canInsert: true,
    canUpdate: true,
    canDelete: true
  }
};
const grant_applicationUniques = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: {
      __proto__: null
    }
  }
}];
const registryConfig_pgResources_grant_application_grant_application = {
  executor: executor,
  name: "grant_application",
  identifier: "main.public.grant_application",
  from: grantApplicationIdentifier,
  codec: grantApplicationCodec,
  uniques: grant_applicationUniques,
  isVirtual: false,
  description: undefined,
  extensions: {
    description: undefined,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "grant_application"
    },
    isInsertable: true,
    isUpdatable: true,
    isDeletable: true,
    tags: {},
    canSelect: true,
    canInsert: true,
    canUpdate: true,
    canDelete: true
  }
};
const payoutUniques = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: {
      __proto__: null
    }
  }
}];
const registryConfig_pgResources_payout_payout = {
  executor: executor,
  name: "payout",
  identifier: "main.public.payout",
  from: payoutIdentifier,
  codec: payoutCodec,
  uniques: payoutUniques,
  isVirtual: false,
  description: undefined,
  extensions: {
    description: undefined,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "payout"
    },
    isInsertable: true,
    isUpdatable: true,
    isDeletable: true,
    tags: {},
    canSelect: true,
    canInsert: true,
    canUpdate: true,
    canDelete: true
  }
};
const grant_milestoneUniques = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: {
      __proto__: null
    }
  }
}];
const registryConfig_pgResources_grant_milestone_grant_milestone = {
  executor: executor,
  name: "grant_milestone",
  identifier: "main.public.grant_milestone",
  from: grantMilestoneIdentifier,
  codec: grantMilestoneCodec,
  uniques: grant_milestoneUniques,
  isVirtual: false,
  description: undefined,
  extensions: {
    description: undefined,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "grant_milestone"
    },
    isInsertable: true,
    isUpdatable: true,
    isDeletable: true,
    tags: {},
    canSelect: true,
    canInsert: true,
    canUpdate: true,
    canDelete: true
  }
};
const bountyUniques = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: {
      __proto__: null
    }
  }
}];
const registryConfig_pgResources_bounty_bounty = {
  executor: executor,
  name: "bounty",
  identifier: "main.public.bounty",
  from: bountyIdentifier,
  codec: bountyCodec,
  uniques: bountyUniques,
  isVirtual: false,
  description: undefined,
  extensions: {
    description: undefined,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "bounty"
    },
    isInsertable: true,
    isUpdatable: true,
    isDeletable: true,
    tags: {},
    canSelect: true,
    canInsert: true,
    canUpdate: true,
    canDelete: true
  }
};
const transactionUniques = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: {
      __proto__: null
    }
  }
}];
const registryConfig_pgResources_transaction_transaction = {
  executor: executor,
  name: "transaction",
  identifier: "main.public.transaction",
  from: transactionIdentifier,
  codec: transactionCodec,
  uniques: transactionUniques,
  isVirtual: false,
  description: undefined,
  extensions: {
    description: undefined,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "transaction"
    },
    isInsertable: true,
    isUpdatable: true,
    isDeletable: true,
    tags: {},
    canSelect: true,
    canInsert: true,
    canUpdate: true,
    canDelete: true
  }
};
const sponsorshipUniques = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: {
      __proto__: null
    }
  }
}];
const registryConfig_pgResources_sponsorship_sponsorship = {
  executor: executor,
  name: "sponsorship",
  identifier: "main.public.sponsorship",
  from: sponsorshipIdentifier,
  codec: sponsorshipCodec,
  uniques: sponsorshipUniques,
  isVirtual: false,
  description: undefined,
  extensions: {
    description: undefined,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "sponsorship"
    },
    isInsertable: true,
    isUpdatable: true,
    isDeletable: true,
    tags: {},
    canSelect: true,
    canInsert: true,
    canUpdate: true,
    canDelete: true
  }
};
const registryConfig = {
  pgExecutors: {
    __proto__: null,
    main: executor
  },
  pgCodecs: {
    __proto__: null,
    userOrganization: userOrganizationCodec,
    uuid: TYPES.uuid,
    organizationRole: organizationRoleCodec,
    timestamptz: TYPES.timestamptz,
    bountyFunding: bountyFundingCodec,
    numeric: TYPES.numeric,
    text: TYPES.text,
    user: userCodec,
    webhookEndpoint: webhookEndpointCodec,
    bool: TYPES.boolean,
    workspace: workspaceCodec,
    timestamp: TYPES.timestamp,
    donation: donationCodec,
    goal: goalCodec,
    int4: TYPES.int,
    userIdentity: userIdentityCodec,
    identityProvider: identityProviderCodec,
    webhookDelivery: webhookDeliveryCodec,
    sponsorshipTier: sponsorshipTierCodec,
    paymentProcessorConnection: paymentProcessorConnectionCodec,
    paymentProcessor: paymentProcessorCodec,
    auditLog: auditLogCodec,
    auditAction: auditActionCodec,
    post: postCodec,
    postVisibility: postVisibilityCodec,
    grantProgram: grantProgramCodec,
    organization: organizationCodec,
    organizationType: organizationTypeCodec,
    grantApplication: grantApplicationCodec,
    grantApplicationStatus: grantApplicationStatusCodec,
    payout: payoutCodec,
    transactionStatus: transactionStatusCodec,
    grantMilestone: grantMilestoneCodec,
    grantMilestoneStatus: grantMilestoneStatusCodec,
    bounty: bountyCodec,
    bountySourceType: bountySourceTypeCodec,
    bountyStatus: bountyStatusCodec,
    sponsorshipFrequency: sponsorshipFrequencyCodec,
    sponsorshipStatus: sponsorshipStatusCodec,
    transactionType: transactionTypeCodec,
    sponsorship: sponsorshipCodec,
    transaction: transactionCodec
  },
  pgResources: {
    __proto__: null,
    user_organization: registryConfig_pgResources_user_organization_user_organization,
    bounty_funding: registryConfig_pgResources_bounty_funding_bounty_funding,
    user: registryConfig_pgResources_user_user,
    webhook_endpoint: registryConfig_pgResources_webhook_endpoint_webhook_endpoint,
    workspace: {
      executor: executor,
      name: "workspace",
      identifier: "main.public.workspace",
      from: workspaceIdentifier,
      codec: workspaceCodec,
      uniques: workspaceUniques,
      isVirtual: false,
      description: undefined,
      extensions: {
        description: undefined,
        pg: {
          serviceName: "main",
          schemaName: "public",
          name: "workspace"
        },
        isInsertable: true,
        isUpdatable: true,
        isDeletable: true,
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true,
        canDelete: true
      }
    },
    donation: registryConfig_pgResources_donation_donation,
    goal: registryConfig_pgResources_goal_goal,
    user_identity: registryConfig_pgResources_user_identity_user_identity,
    webhook_delivery: registryConfig_pgResources_webhook_delivery_webhook_delivery,
    sponsorship_tier: registryConfig_pgResources_sponsorship_tier_sponsorship_tier,
    payment_processor_connection: registryConfig_pgResources_payment_processor_connection_payment_processor_connection,
    audit_log: registryConfig_pgResources_audit_log_audit_log,
    post: registryConfig_pgResources_post_post,
    grant_program: registryConfig_pgResources_grant_program_grant_program,
    organization: registryConfig_pgResources_organization_organization,
    grant_application: registryConfig_pgResources_grant_application_grant_application,
    payout: registryConfig_pgResources_payout_payout,
    grant_milestone: registryConfig_pgResources_grant_milestone_grant_milestone,
    bounty: registryConfig_pgResources_bounty_bounty,
    transaction: registryConfig_pgResources_transaction_transaction,
    sponsorship: registryConfig_pgResources_sponsorship_sponsorship
  },
  pgRelations: {
    __proto__: null,
    auditLog: {
      __proto__: null,
      userByMyActorUserId: {
        localCodec: auditLogCodec,
        remoteResourceOptions: registryConfig_pgResources_user_user,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["actor_user_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      organizationByMyOrganizationId: {
        localCodec: auditLogCodec,
        remoteResourceOptions: registryConfig_pgResources_organization_organization,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["organization_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    },
    bounty: {
      __proto__: null,
      userByMyClaimantId: {
        localCodec: bountyCodec,
        remoteResourceOptions: registryConfig_pgResources_user_user,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["claimant_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      organizationByMyOrganizationId: {
        localCodec: bountyCodec,
        remoteResourceOptions: registryConfig_pgResources_organization_organization,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["organization_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      bountyFundingsByTheirBountyId: {
        localCodec: bountyCodec,
        remoteResourceOptions: registryConfig_pgResources_bounty_funding_bounty_funding,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["bounty_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    },
    bountyFunding: {
      __proto__: null,
      bountyByMyBountyId: {
        localCodec: bountyFundingCodec,
        remoteResourceOptions: registryConfig_pgResources_bounty_bounty,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["bounty_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      userByMyFunderId: {
        localCodec: bountyFundingCodec,
        remoteResourceOptions: registryConfig_pgResources_user_user,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["funder_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      transactionByMyTransactionId: {
        localCodec: bountyFundingCodec,
        remoteResourceOptions: registryConfig_pgResources_transaction_transaction,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["transaction_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    },
    donation: {
      __proto__: null,
      userByMyDonorId: {
        localCodec: donationCodec,
        remoteResourceOptions: registryConfig_pgResources_user_user,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["donor_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      organizationByMyOrganizationId: {
        localCodec: donationCodec,
        remoteResourceOptions: registryConfig_pgResources_organization_organization,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["organization_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      transactionByMyTransactionId: {
        localCodec: donationCodec,
        remoteResourceOptions: registryConfig_pgResources_transaction_transaction,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["transaction_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    },
    goal: {
      __proto__: null,
      organizationByMyOrganizationId: {
        localCodec: goalCodec,
        remoteResourceOptions: registryConfig_pgResources_organization_organization,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["organization_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    },
    grantApplication: {
      __proto__: null,
      userByMyApplicantId: {
        localCodec: grantApplicationCodec,
        remoteResourceOptions: registryConfig_pgResources_user_user,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["applicant_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      grantProgramByMyGrantProgramId: {
        localCodec: grantApplicationCodec,
        remoteResourceOptions: registryConfig_pgResources_grant_program_grant_program,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["grant_program_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      userByMyReviewedById: {
        localCodec: grantApplicationCodec,
        remoteResourceOptions: registryConfig_pgResources_user_user,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["reviewed_by_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      grantMilestonesByTheirGrantApplicationId: {
        localCodec: grantApplicationCodec,
        remoteResourceOptions: registryConfig_pgResources_grant_milestone_grant_milestone,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["grant_application_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    },
    grantMilestone: {
      __proto__: null,
      grantApplicationByMyGrantApplicationId: {
        localCodec: grantMilestoneCodec,
        remoteResourceOptions: registryConfig_pgResources_grant_application_grant_application,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["grant_application_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      transactionByMyTransactionId: {
        localCodec: grantMilestoneCodec,
        remoteResourceOptions: registryConfig_pgResources_transaction_transaction,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["transaction_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    },
    grantProgram: {
      __proto__: null,
      organizationByMyOrganizationId: {
        localCodec: grantProgramCodec,
        remoteResourceOptions: registryConfig_pgResources_organization_organization,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["organization_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      grantApplicationsByTheirGrantProgramId: {
        localCodec: grantProgramCodec,
        remoteResourceOptions: registryConfig_pgResources_grant_application_grant_application,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["grant_program_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    },
    organization: {
      __proto__: null,
      auditLogsByTheirOrganizationId: {
        localCodec: organizationCodec,
        remoteResourceOptions: registryConfig_pgResources_audit_log_audit_log,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["organization_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      bountiesByTheirOrganizationId: {
        localCodec: organizationCodec,
        remoteResourceOptions: registryConfig_pgResources_bounty_bounty,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["organization_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      donationsByTheirOrganizationId: {
        localCodec: organizationCodec,
        remoteResourceOptions: registryConfig_pgResources_donation_donation,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["organization_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      grantProgramsByTheirOrganizationId: {
        localCodec: organizationCodec,
        remoteResourceOptions: registryConfig_pgResources_grant_program_grant_program,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["organization_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      userOrganizationsByTheirOrganizationId: {
        localCodec: organizationCodec,
        remoteResourceOptions: registryConfig_pgResources_user_organization_user_organization,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["organization_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      sponsorshipTiersByTheirOrganizationId: {
        localCodec: organizationCodec,
        remoteResourceOptions: registryConfig_pgResources_sponsorship_tier_sponsorship_tier,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["organization_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      sponsorshipsByTheirOrganizationId: {
        localCodec: organizationCodec,
        remoteResourceOptions: registryConfig_pgResources_sponsorship_sponsorship,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["organization_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      paymentProcessorConnectionsByTheirOrganizationId: {
        localCodec: organizationCodec,
        remoteResourceOptions: registryConfig_pgResources_payment_processor_connection_payment_processor_connection,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["organization_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      transactionsByTheirToOrganizationId: {
        localCodec: organizationCodec,
        remoteResourceOptions: registryConfig_pgResources_transaction_transaction,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["to_organization_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      payoutsByTheirFromOrganizationId: {
        localCodec: organizationCodec,
        remoteResourceOptions: registryConfig_pgResources_payout_payout,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["from_organization_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      webhookEndpointsByTheirOrganizationId: {
        localCodec: organizationCodec,
        remoteResourceOptions: registryConfig_pgResources_webhook_endpoint_webhook_endpoint,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["organization_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      goalsByTheirOrganizationId: {
        localCodec: organizationCodec,
        remoteResourceOptions: registryConfig_pgResources_goal_goal,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["organization_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      postsByTheirOrganizationId: {
        localCodec: organizationCodec,
        remoteResourceOptions: registryConfig_pgResources_post_post,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["organization_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    },
    paymentProcessorConnection: {
      __proto__: null,
      organizationByMyOrganizationId: {
        localCodec: paymentProcessorConnectionCodec,
        remoteResourceOptions: registryConfig_pgResources_organization_organization,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["organization_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      transactionsByTheirProcessorConnectionId: {
        localCodec: paymentProcessorConnectionCodec,
        remoteResourceOptions: registryConfig_pgResources_transaction_transaction,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["processor_connection_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      payoutsByTheirProcessorConnectionId: {
        localCodec: paymentProcessorConnectionCodec,
        remoteResourceOptions: registryConfig_pgResources_payout_payout,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["processor_connection_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          },
          isIndexed: false
        }
      }
    },
    payout: {
      __proto__: null,
      organizationByMyFromOrganizationId: {
        localCodec: payoutCodec,
        remoteResourceOptions: registryConfig_pgResources_organization_organization,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["from_organization_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      paymentProcessorConnectionByMyProcessorConnectionId: {
        localCodec: payoutCodec,
        remoteResourceOptions: registryConfig_pgResources_payment_processor_connection_payment_processor_connection,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["processor_connection_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      userByMyRecipientUserId: {
        localCodec: payoutCodec,
        remoteResourceOptions: registryConfig_pgResources_user_user,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["recipient_user_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    },
    post: {
      __proto__: null,
      userByMyAuthorId: {
        localCodec: postCodec,
        remoteResourceOptions: registryConfig_pgResources_user_user,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["author_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      sponsorshipTierByMyMinimumTierId: {
        localCodec: postCodec,
        remoteResourceOptions: registryConfig_pgResources_sponsorship_tier_sponsorship_tier,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["minimum_tier_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      organizationByMyOrganizationId: {
        localCodec: postCodec,
        remoteResourceOptions: registryConfig_pgResources_organization_organization,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["organization_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    },
    sponsorship: {
      __proto__: null,
      organizationByMyOrganizationId: {
        localCodec: sponsorshipCodec,
        remoteResourceOptions: registryConfig_pgResources_organization_organization,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["organization_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      userByMySponsorId: {
        localCodec: sponsorshipCodec,
        remoteResourceOptions: registryConfig_pgResources_user_user,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["sponsor_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      sponsorshipTierByMyTierId: {
        localCodec: sponsorshipCodec,
        remoteResourceOptions: registryConfig_pgResources_sponsorship_tier_sponsorship_tier,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["tier_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    },
    sponsorshipTier: {
      __proto__: null,
      organizationByMyOrganizationId: {
        localCodec: sponsorshipTierCodec,
        remoteResourceOptions: registryConfig_pgResources_organization_organization,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["organization_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      sponsorshipsByTheirTierId: {
        localCodec: sponsorshipTierCodec,
        remoteResourceOptions: registryConfig_pgResources_sponsorship_sponsorship,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["tier_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      postsByTheirMinimumTierId: {
        localCodec: sponsorshipTierCodec,
        remoteResourceOptions: registryConfig_pgResources_post_post,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["minimum_tier_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          },
          isIndexed: false
        }
      }
    },
    transaction: {
      __proto__: null,
      userByMyFromUserId: {
        localCodec: transactionCodec,
        remoteResourceOptions: registryConfig_pgResources_user_user,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["from_user_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      paymentProcessorConnectionByMyProcessorConnectionId: {
        localCodec: transactionCodec,
        remoteResourceOptions: registryConfig_pgResources_payment_processor_connection_payment_processor_connection,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["processor_connection_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      organizationByMyToOrganizationId: {
        localCodec: transactionCodec,
        remoteResourceOptions: registryConfig_pgResources_organization_organization,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["to_organization_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      userByMyToUserId: {
        localCodec: transactionCodec,
        remoteResourceOptions: registryConfig_pgResources_user_user,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["to_user_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      bountyFundingsByTheirTransactionId: {
        localCodec: transactionCodec,
        remoteResourceOptions: registryConfig_pgResources_bounty_funding_bounty_funding,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["transaction_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      donationsByTheirTransactionId: {
        localCodec: transactionCodec,
        remoteResourceOptions: registryConfig_pgResources_donation_donation,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["transaction_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      grantMilestonesByTheirTransactionId: {
        localCodec: transactionCodec,
        remoteResourceOptions: registryConfig_pgResources_grant_milestone_grant_milestone,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["transaction_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          },
          isIndexed: false
        }
      }
    },
    user: {
      __proto__: null,
      auditLogsByTheirActorUserId: {
        localCodec: userCodec,
        remoteResourceOptions: registryConfig_pgResources_audit_log_audit_log,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["actor_user_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      bountiesByTheirClaimantId: {
        localCodec: userCodec,
        remoteResourceOptions: registryConfig_pgResources_bounty_bounty,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["claimant_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      bountyFundingsByTheirFunderId: {
        localCodec: userCodec,
        remoteResourceOptions: registryConfig_pgResources_bounty_funding_bounty_funding,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["funder_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      donationsByTheirDonorId: {
        localCodec: userCodec,
        remoteResourceOptions: registryConfig_pgResources_donation_donation,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["donor_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      grantApplicationsByTheirApplicantId: {
        localCodec: userCodec,
        remoteResourceOptions: registryConfig_pgResources_grant_application_grant_application,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["applicant_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      grantApplicationsByTheirReviewedById: {
        localCodec: userCodec,
        remoteResourceOptions: registryConfig_pgResources_grant_application_grant_application,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["reviewed_by_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          },
          isIndexed: false
        }
      },
      userIdentitiesByTheirUserId: {
        localCodec: userCodec,
        remoteResourceOptions: registryConfig_pgResources_user_identity_user_identity,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["user_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      userOrganizationsByTheirUserId: {
        localCodec: userCodec,
        remoteResourceOptions: registryConfig_pgResources_user_organization_user_organization,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["user_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      sponsorshipsByTheirSponsorId: {
        localCodec: userCodec,
        remoteResourceOptions: registryConfig_pgResources_sponsorship_sponsorship,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["sponsor_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      transactionsByTheirFromUserId: {
        localCodec: userCodec,
        remoteResourceOptions: registryConfig_pgResources_transaction_transaction,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["from_user_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      transactionsByTheirToUserId: {
        localCodec: userCodec,
        remoteResourceOptions: registryConfig_pgResources_transaction_transaction,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["to_user_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      payoutsByTheirRecipientUserId: {
        localCodec: userCodec,
        remoteResourceOptions: registryConfig_pgResources_payout_payout,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["recipient_user_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      postsByTheirAuthorId: {
        localCodec: userCodec,
        remoteResourceOptions: registryConfig_pgResources_post_post,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["author_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    },
    userIdentity: {
      __proto__: null,
      userByMyUserId: {
        localCodec: userIdentityCodec,
        remoteResourceOptions: registryConfig_pgResources_user_user,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["user_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    },
    userOrganization: {
      __proto__: null,
      organizationByMyOrganizationId: {
        localCodec: userOrganizationCodec,
        remoteResourceOptions: registryConfig_pgResources_organization_organization,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["organization_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      userByMyUserId: {
        localCodec: userOrganizationCodec,
        remoteResourceOptions: registryConfig_pgResources_user_user,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["user_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    },
    webhookDelivery: {
      __proto__: null,
      webhookEndpointByMyWebhookEndpointId: {
        localCodec: webhookDeliveryCodec,
        remoteResourceOptions: registryConfig_pgResources_webhook_endpoint_webhook_endpoint,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["webhook_endpoint_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    },
    webhookEndpoint: {
      __proto__: null,
      organizationByMyOrganizationId: {
        localCodec: webhookEndpointCodec,
        remoteResourceOptions: registryConfig_pgResources_organization_organization,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["organization_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      webhookDeliveriesByTheirWebhookEndpointId: {
        localCodec: webhookEndpointCodec,
        remoteResourceOptions: registryConfig_pgResources_webhook_delivery_webhook_delivery,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["webhook_endpoint_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    }
  }
};
const registry = makeRegistry(registryConfig);
const resource_user_organizationPgResource = registry.pgResources["user_organization"];
const resource_bounty_fundingPgResource = registry.pgResources["bounty_funding"];
const resource_userPgResource = registry.pgResources["user"];
const resource_webhook_endpointPgResource = registry.pgResources["webhook_endpoint"];
const resource_workspacePgResource = registry.pgResources["workspace"];
const resource_donationPgResource = registry.pgResources["donation"];
const resource_goalPgResource = registry.pgResources["goal"];
const resource_user_identityPgResource = registry.pgResources["user_identity"];
const resource_webhook_deliveryPgResource = registry.pgResources["webhook_delivery"];
const resource_sponsorship_tierPgResource = registry.pgResources["sponsorship_tier"];
const resource_payment_processor_connectionPgResource = registry.pgResources["payment_processor_connection"];
const resource_audit_logPgResource = registry.pgResources["audit_log"];
const resource_postPgResource = registry.pgResources["post"];
const resource_grant_programPgResource = registry.pgResources["grant_program"];
const resource_organizationPgResource = registry.pgResources["organization"];
const resource_grant_applicationPgResource = registry.pgResources["grant_application"];
const resource_payoutPgResource = registry.pgResources["payout"];
const resource_grant_milestonePgResource = registry.pgResources["grant_milestone"];
const resource_bountyPgResource = registry.pgResources["bounty"];
const resource_transactionPgResource = registry.pgResources["transaction"];
const resource_sponsorshipPgResource = registry.pgResources["sponsorship"];
const nodeIdHandler_UserOrganization = {
  typeName: "UserOrganization",
  codec: nodeIdCodecs_base64JSON_base64JSON,
  deprecationReason: undefined,
  plan($record) {
    return list([constant("UserOrganization", false), $record.get("id")]);
  },
  getSpec($list) {
    return {
      id: inhibitOnNull(access($list, [1]))
    };
  },
  getIdentifiers(value) {
    return value.slice(1);
  },
  get(spec) {
    return resource_user_organizationPgResource.get(spec);
  },
  match(obj) {
    return obj[0] === "UserOrganization";
  }
};
const specForHandlerCache = new Map();
function specForHandler(handler) {
  const existing = specForHandlerCache.get(handler);
  if (existing) return existing;
  function spec(nodeId) {
    if (nodeId == null) return null;
    try {
      const specifier = handler.codec.decode(nodeId);
      if (handler.match(specifier)) return specifier;
    } catch {}
    return null;
  }
  spec.displayName = `specifier_${handler.typeName}_${handler.codec.name}`;
  spec.isSyncAndSafe = !0;
  specForHandlerCache.set(handler, spec);
  return spec;
}
const nodeFetcher_UserOrganization = $nodeId => {
  const $decoded = lambda($nodeId, specForHandler(nodeIdHandler_UserOrganization));
  return nodeIdHandler_UserOrganization.get(nodeIdHandler_UserOrganization.getSpec($decoded));
};
const nodeIdHandler_BountyFunding = {
  typeName: "BountyFunding",
  codec: nodeIdCodecs_base64JSON_base64JSON,
  deprecationReason: undefined,
  plan($record) {
    return list([constant("BountyFunding", false), $record.get("id")]);
  },
  getSpec($list) {
    return {
      id: inhibitOnNull(access($list, [1]))
    };
  },
  getIdentifiers(value) {
    return value.slice(1);
  },
  get(spec) {
    return resource_bounty_fundingPgResource.get(spec);
  },
  match(obj) {
    return obj[0] === "BountyFunding";
  }
};
const nodeFetcher_BountyFunding = $nodeId => {
  const $decoded = lambda($nodeId, specForHandler(nodeIdHandler_BountyFunding));
  return nodeIdHandler_BountyFunding.get(nodeIdHandler_BountyFunding.getSpec($decoded));
};
const nodeIdHandler_User = {
  typeName: "User",
  codec: nodeIdCodecs_base64JSON_base64JSON,
  deprecationReason: undefined,
  plan($record) {
    return list([constant("User", false), $record.get("id")]);
  },
  getSpec($list) {
    return {
      id: inhibitOnNull(access($list, [1]))
    };
  },
  getIdentifiers(value) {
    return value.slice(1);
  },
  get(spec) {
    return resource_userPgResource.get(spec);
  },
  match(obj) {
    return obj[0] === "User";
  }
};
const nodeFetcher_User = $nodeId => {
  const $decoded = lambda($nodeId, specForHandler(nodeIdHandler_User));
  return nodeIdHandler_User.get(nodeIdHandler_User.getSpec($decoded));
};
const nodeIdHandler_WebhookEndpoint = {
  typeName: "WebhookEndpoint",
  codec: nodeIdCodecs_base64JSON_base64JSON,
  deprecationReason: undefined,
  plan($record) {
    return list([constant("WebhookEndpoint", false), $record.get("id")]);
  },
  getSpec($list) {
    return {
      id: inhibitOnNull(access($list, [1]))
    };
  },
  getIdentifiers(value) {
    return value.slice(1);
  },
  get(spec) {
    return resource_webhook_endpointPgResource.get(spec);
  },
  match(obj) {
    return obj[0] === "WebhookEndpoint";
  }
};
const nodeFetcher_WebhookEndpoint = $nodeId => {
  const $decoded = lambda($nodeId, specForHandler(nodeIdHandler_WebhookEndpoint));
  return nodeIdHandler_WebhookEndpoint.get(nodeIdHandler_WebhookEndpoint.getSpec($decoded));
};
const nodeIdHandler_Workspace = {
  typeName: "Workspace",
  codec: nodeIdCodecs_base64JSON_base64JSON,
  deprecationReason: undefined,
  plan($record) {
    return list([constant("Workspace", false), $record.get("id")]);
  },
  getSpec($list) {
    return {
      id: inhibitOnNull(access($list, [1]))
    };
  },
  getIdentifiers(value) {
    return value.slice(1);
  },
  get(spec) {
    return resource_workspacePgResource.get(spec);
  },
  match(obj) {
    return obj[0] === "Workspace";
  }
};
const nodeFetcher_Workspace = $nodeId => {
  const $decoded = lambda($nodeId, specForHandler(nodeIdHandler_Workspace));
  return nodeIdHandler_Workspace.get(nodeIdHandler_Workspace.getSpec($decoded));
};
const nodeIdHandler_Donation = {
  typeName: "Donation",
  codec: nodeIdCodecs_base64JSON_base64JSON,
  deprecationReason: undefined,
  plan($record) {
    return list([constant("Donation", false), $record.get("id")]);
  },
  getSpec($list) {
    return {
      id: inhibitOnNull(access($list, [1]))
    };
  },
  getIdentifiers(value) {
    return value.slice(1);
  },
  get(spec) {
    return resource_donationPgResource.get(spec);
  },
  match(obj) {
    return obj[0] === "Donation";
  }
};
const nodeFetcher_Donation = $nodeId => {
  const $decoded = lambda($nodeId, specForHandler(nodeIdHandler_Donation));
  return nodeIdHandler_Donation.get(nodeIdHandler_Donation.getSpec($decoded));
};
const nodeIdHandler_Goal = {
  typeName: "Goal",
  codec: nodeIdCodecs_base64JSON_base64JSON,
  deprecationReason: undefined,
  plan($record) {
    return list([constant("Goal", false), $record.get("id")]);
  },
  getSpec($list) {
    return {
      id: inhibitOnNull(access($list, [1]))
    };
  },
  getIdentifiers(value) {
    return value.slice(1);
  },
  get(spec) {
    return resource_goalPgResource.get(spec);
  },
  match(obj) {
    return obj[0] === "Goal";
  }
};
const nodeFetcher_Goal = $nodeId => {
  const $decoded = lambda($nodeId, specForHandler(nodeIdHandler_Goal));
  return nodeIdHandler_Goal.get(nodeIdHandler_Goal.getSpec($decoded));
};
const nodeIdHandler_UserIdentity = {
  typeName: "UserIdentity",
  codec: nodeIdCodecs_base64JSON_base64JSON,
  deprecationReason: undefined,
  plan($record) {
    return list([constant("UserIdentity", false), $record.get("id")]);
  },
  getSpec($list) {
    return {
      id: inhibitOnNull(access($list, [1]))
    };
  },
  getIdentifiers(value) {
    return value.slice(1);
  },
  get(spec) {
    return resource_user_identityPgResource.get(spec);
  },
  match(obj) {
    return obj[0] === "UserIdentity";
  }
};
const nodeFetcher_UserIdentity = $nodeId => {
  const $decoded = lambda($nodeId, specForHandler(nodeIdHandler_UserIdentity));
  return nodeIdHandler_UserIdentity.get(nodeIdHandler_UserIdentity.getSpec($decoded));
};
const nodeIdHandler_WebhookDelivery = {
  typeName: "WebhookDelivery",
  codec: nodeIdCodecs_base64JSON_base64JSON,
  deprecationReason: undefined,
  plan($record) {
    return list([constant("WebhookDelivery", false), $record.get("id")]);
  },
  getSpec($list) {
    return {
      id: inhibitOnNull(access($list, [1]))
    };
  },
  getIdentifiers(value) {
    return value.slice(1);
  },
  get(spec) {
    return resource_webhook_deliveryPgResource.get(spec);
  },
  match(obj) {
    return obj[0] === "WebhookDelivery";
  }
};
const nodeFetcher_WebhookDelivery = $nodeId => {
  const $decoded = lambda($nodeId, specForHandler(nodeIdHandler_WebhookDelivery));
  return nodeIdHandler_WebhookDelivery.get(nodeIdHandler_WebhookDelivery.getSpec($decoded));
};
const nodeIdHandler_SponsorshipTier = {
  typeName: "SponsorshipTier",
  codec: nodeIdCodecs_base64JSON_base64JSON,
  deprecationReason: undefined,
  plan($record) {
    return list([constant("SponsorshipTier", false), $record.get("id")]);
  },
  getSpec($list) {
    return {
      id: inhibitOnNull(access($list, [1]))
    };
  },
  getIdentifiers(value) {
    return value.slice(1);
  },
  get(spec) {
    return resource_sponsorship_tierPgResource.get(spec);
  },
  match(obj) {
    return obj[0] === "SponsorshipTier";
  }
};
const nodeFetcher_SponsorshipTier = $nodeId => {
  const $decoded = lambda($nodeId, specForHandler(nodeIdHandler_SponsorshipTier));
  return nodeIdHandler_SponsorshipTier.get(nodeIdHandler_SponsorshipTier.getSpec($decoded));
};
const nodeIdHandler_PaymentProcessorConnection = {
  typeName: "PaymentProcessorConnection",
  codec: nodeIdCodecs_base64JSON_base64JSON,
  deprecationReason: undefined,
  plan($record) {
    return list([constant("PaymentProcessorConnection", false), $record.get("id")]);
  },
  getSpec($list) {
    return {
      id: inhibitOnNull(access($list, [1]))
    };
  },
  getIdentifiers(value) {
    return value.slice(1);
  },
  get(spec) {
    return resource_payment_processor_connectionPgResource.get(spec);
  },
  match(obj) {
    return obj[0] === "PaymentProcessorConnection";
  }
};
const nodeFetcher_PaymentProcessorConnection = $nodeId => {
  const $decoded = lambda($nodeId, specForHandler(nodeIdHandler_PaymentProcessorConnection));
  return nodeIdHandler_PaymentProcessorConnection.get(nodeIdHandler_PaymentProcessorConnection.getSpec($decoded));
};
const nodeIdHandler_AuditLog = {
  typeName: "AuditLog",
  codec: nodeIdCodecs_base64JSON_base64JSON,
  deprecationReason: undefined,
  plan($record) {
    return list([constant("AuditLog", false), $record.get("id")]);
  },
  getSpec($list) {
    return {
      id: inhibitOnNull(access($list, [1]))
    };
  },
  getIdentifiers(value) {
    return value.slice(1);
  },
  get(spec) {
    return resource_audit_logPgResource.get(spec);
  },
  match(obj) {
    return obj[0] === "AuditLog";
  }
};
const nodeFetcher_AuditLog = $nodeId => {
  const $decoded = lambda($nodeId, specForHandler(nodeIdHandler_AuditLog));
  return nodeIdHandler_AuditLog.get(nodeIdHandler_AuditLog.getSpec($decoded));
};
const nodeIdHandler_Post = {
  typeName: "Post",
  codec: nodeIdCodecs_base64JSON_base64JSON,
  deprecationReason: undefined,
  plan($record) {
    return list([constant("Post", false), $record.get("id")]);
  },
  getSpec($list) {
    return {
      id: inhibitOnNull(access($list, [1]))
    };
  },
  getIdentifiers(value) {
    return value.slice(1);
  },
  get(spec) {
    return resource_postPgResource.get(spec);
  },
  match(obj) {
    return obj[0] === "Post";
  }
};
const nodeFetcher_Post = $nodeId => {
  const $decoded = lambda($nodeId, specForHandler(nodeIdHandler_Post));
  return nodeIdHandler_Post.get(nodeIdHandler_Post.getSpec($decoded));
};
const nodeIdHandler_GrantProgram = {
  typeName: "GrantProgram",
  codec: nodeIdCodecs_base64JSON_base64JSON,
  deprecationReason: undefined,
  plan($record) {
    return list([constant("GrantProgram", false), $record.get("id")]);
  },
  getSpec($list) {
    return {
      id: inhibitOnNull(access($list, [1]))
    };
  },
  getIdentifiers(value) {
    return value.slice(1);
  },
  get(spec) {
    return resource_grant_programPgResource.get(spec);
  },
  match(obj) {
    return obj[0] === "GrantProgram";
  }
};
const nodeFetcher_GrantProgram = $nodeId => {
  const $decoded = lambda($nodeId, specForHandler(nodeIdHandler_GrantProgram));
  return nodeIdHandler_GrantProgram.get(nodeIdHandler_GrantProgram.getSpec($decoded));
};
const nodeIdHandler_Organization = {
  typeName: "Organization",
  codec: nodeIdCodecs_base64JSON_base64JSON,
  deprecationReason: undefined,
  plan($record) {
    return list([constant("Organization", false), $record.get("id")]);
  },
  getSpec($list) {
    return {
      id: inhibitOnNull(access($list, [1]))
    };
  },
  getIdentifiers(value) {
    return value.slice(1);
  },
  get(spec) {
    return resource_organizationPgResource.get(spec);
  },
  match(obj) {
    return obj[0] === "Organization";
  }
};
const nodeFetcher_Organization = $nodeId => {
  const $decoded = lambda($nodeId, specForHandler(nodeIdHandler_Organization));
  return nodeIdHandler_Organization.get(nodeIdHandler_Organization.getSpec($decoded));
};
const nodeIdHandler_GrantApplication = {
  typeName: "GrantApplication",
  codec: nodeIdCodecs_base64JSON_base64JSON,
  deprecationReason: undefined,
  plan($record) {
    return list([constant("GrantApplication", false), $record.get("id")]);
  },
  getSpec($list) {
    return {
      id: inhibitOnNull(access($list, [1]))
    };
  },
  getIdentifiers(value) {
    return value.slice(1);
  },
  get(spec) {
    return resource_grant_applicationPgResource.get(spec);
  },
  match(obj) {
    return obj[0] === "GrantApplication";
  }
};
const nodeFetcher_GrantApplication = $nodeId => {
  const $decoded = lambda($nodeId, specForHandler(nodeIdHandler_GrantApplication));
  return nodeIdHandler_GrantApplication.get(nodeIdHandler_GrantApplication.getSpec($decoded));
};
const nodeIdHandler_Payout = {
  typeName: "Payout",
  codec: nodeIdCodecs_base64JSON_base64JSON,
  deprecationReason: undefined,
  plan($record) {
    return list([constant("Payout", false), $record.get("id")]);
  },
  getSpec($list) {
    return {
      id: inhibitOnNull(access($list, [1]))
    };
  },
  getIdentifiers(value) {
    return value.slice(1);
  },
  get(spec) {
    return resource_payoutPgResource.get(spec);
  },
  match(obj) {
    return obj[0] === "Payout";
  }
};
const nodeFetcher_Payout = $nodeId => {
  const $decoded = lambda($nodeId, specForHandler(nodeIdHandler_Payout));
  return nodeIdHandler_Payout.get(nodeIdHandler_Payout.getSpec($decoded));
};
const nodeIdHandler_GrantMilestone = {
  typeName: "GrantMilestone",
  codec: nodeIdCodecs_base64JSON_base64JSON,
  deprecationReason: undefined,
  plan($record) {
    return list([constant("GrantMilestone", false), $record.get("id")]);
  },
  getSpec($list) {
    return {
      id: inhibitOnNull(access($list, [1]))
    };
  },
  getIdentifiers(value) {
    return value.slice(1);
  },
  get(spec) {
    return resource_grant_milestonePgResource.get(spec);
  },
  match(obj) {
    return obj[0] === "GrantMilestone";
  }
};
const nodeFetcher_GrantMilestone = $nodeId => {
  const $decoded = lambda($nodeId, specForHandler(nodeIdHandler_GrantMilestone));
  return nodeIdHandler_GrantMilestone.get(nodeIdHandler_GrantMilestone.getSpec($decoded));
};
const nodeIdHandler_Bounty = {
  typeName: "Bounty",
  codec: nodeIdCodecs_base64JSON_base64JSON,
  deprecationReason: undefined,
  plan($record) {
    return list([constant("Bounty", false), $record.get("id")]);
  },
  getSpec($list) {
    return {
      id: inhibitOnNull(access($list, [1]))
    };
  },
  getIdentifiers(value) {
    return value.slice(1);
  },
  get(spec) {
    return resource_bountyPgResource.get(spec);
  },
  match(obj) {
    return obj[0] === "Bounty";
  }
};
const nodeFetcher_Bounty = $nodeId => {
  const $decoded = lambda($nodeId, specForHandler(nodeIdHandler_Bounty));
  return nodeIdHandler_Bounty.get(nodeIdHandler_Bounty.getSpec($decoded));
};
const nodeIdHandler_Transaction = {
  typeName: "Transaction",
  codec: nodeIdCodecs_base64JSON_base64JSON,
  deprecationReason: undefined,
  plan($record) {
    return list([constant("Transaction", false), $record.get("id")]);
  },
  getSpec($list) {
    return {
      id: inhibitOnNull(access($list, [1]))
    };
  },
  getIdentifiers(value) {
    return value.slice(1);
  },
  get(spec) {
    return resource_transactionPgResource.get(spec);
  },
  match(obj) {
    return obj[0] === "Transaction";
  }
};
const nodeFetcher_Transaction = $nodeId => {
  const $decoded = lambda($nodeId, specForHandler(nodeIdHandler_Transaction));
  return nodeIdHandler_Transaction.get(nodeIdHandler_Transaction.getSpec($decoded));
};
const nodeIdHandler_Sponsorship = {
  typeName: "Sponsorship",
  codec: nodeIdCodecs_base64JSON_base64JSON,
  deprecationReason: undefined,
  plan($record) {
    return list([constant("Sponsorship", false), $record.get("id")]);
  },
  getSpec($list) {
    return {
      id: inhibitOnNull(access($list, [1]))
    };
  },
  getIdentifiers(value) {
    return value.slice(1);
  },
  get(spec) {
    return resource_sponsorshipPgResource.get(spec);
  },
  match(obj) {
    return obj[0] === "Sponsorship";
  }
};
const nodeFetcher_Sponsorship = $nodeId => {
  const $decoded = lambda($nodeId, specForHandler(nodeIdHandler_Sponsorship));
  return nodeIdHandler_Sponsorship.get(nodeIdHandler_Sponsorship.getSpec($decoded));
};
function qbWhereBuilder(qb) {
  return qb.whereBuilder();
}
function isEmpty(o) {
  return typeof o === "object" && o !== null && Object.keys(o).length === 0;
}
function assertAllowed(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed2(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed3(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed4(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed5(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed6(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed7(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed8(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed9(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed10(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed11(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed12(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed13(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed14(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed15(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed16(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed17(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed18(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed19(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed20(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed21(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
const nodeIdHandlerByTypeName = {
  __proto__: null,
  Query: nodeIdHandler_Query,
  UserOrganization: nodeIdHandler_UserOrganization,
  BountyFunding: nodeIdHandler_BountyFunding,
  User: nodeIdHandler_User,
  WebhookEndpoint: nodeIdHandler_WebhookEndpoint,
  Workspace: nodeIdHandler_Workspace,
  Donation: nodeIdHandler_Donation,
  Goal: nodeIdHandler_Goal,
  UserIdentity: nodeIdHandler_UserIdentity,
  WebhookDelivery: nodeIdHandler_WebhookDelivery,
  SponsorshipTier: nodeIdHandler_SponsorshipTier,
  PaymentProcessorConnection: nodeIdHandler_PaymentProcessorConnection,
  AuditLog: nodeIdHandler_AuditLog,
  Post: nodeIdHandler_Post,
  GrantProgram: nodeIdHandler_GrantProgram,
  Organization: nodeIdHandler_Organization,
  GrantApplication: nodeIdHandler_GrantApplication,
  Payout: nodeIdHandler_Payout,
  GrantMilestone: nodeIdHandler_GrantMilestone,
  Bounty: nodeIdHandler_Bounty,
  Transaction: nodeIdHandler_Transaction,
  Sponsorship: nodeIdHandler_Sponsorship
};
const decodeNodeId = makeDecodeNodeId(Object.values(nodeIdHandlerByTypeName));
function findTypeNameMatch(specifier) {
  if (!specifier) return null;
  for (const [typeName, typeSpec] of Object.entries(nodeIdHandlerByTypeName)) {
    const value = specifier[typeSpec.codec.name];
    if (value != null && typeSpec.match(value)) return typeName;
  }
  console.warn(`Could not find a type that matched the specifier '${inspect(specifier)}'`);
  return null;
}
function UUIDSerialize(value) {
  return "" + value;
}
const coerce = string => {
  if (!/^[0-9a-f]{8}-?[0-9a-f]{4}-?[0-9a-f]{4}-?[0-9a-f]{4}-?[0-9a-f]{12}$/i.test(string)) throw new GraphQLError("Invalid UUID, expected 32 hexadecimal characters, optionally with hyphens");
  return string;
};
function assertAllowed22(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed23(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed24(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed25(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed26(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed27(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed28(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed29(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed30(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed31(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed32(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed33(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed34(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed35(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed36(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed37(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed38(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed39(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed40(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed41(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed42(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed43(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed44(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed45(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed46(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
const colSpec = {
  fieldName: "rowId",
  attributeName: "id",
  attribute: spec_auditLog.attributes.id
};
const colSpec2 = {
  fieldName: "actorUserId",
  attributeName: "actor_user_id",
  attribute: spec_auditLog.attributes.actor_user_id
};
const colSpec3 = {
  fieldName: "organizationId",
  attributeName: "organization_id",
  attribute: spec_auditLog.attributes.organization_id
};
const colSpec4 = {
  fieldName: "targetEntityType",
  attributeName: "target_entity_type",
  attribute: spec_auditLog.attributes.target_entity_type
};
const colSpec5 = {
  fieldName: "targetEntityId",
  attributeName: "target_entity_id",
  attribute: spec_auditLog.attributes.target_entity_id
};
const colSpec6 = {
  fieldName: "action",
  attributeName: "action",
  attribute: spec_auditLog.attributes.action
};
const colSpec7 = {
  fieldName: "createdAt",
  attributeName: "created_at",
  attribute: spec_auditLog.attributes.created_at
};
function assertAllowed47(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed48(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
const resolve = (i, _v, input) => sql`${i} ${input ? sql`IS NULL` : sql`IS NOT NULL`}`;
const resolveInputCodec = () => TYPES.boolean;
const resolveSqlValue = () => sql.null;
const resolve2 = (i, v) => sql`${i} = ${v}`;
const forceTextTypesSensitive = [TYPES.citext, TYPES.char, TYPES.bpchar];
function resolveDomains(c) {
  let current = c;
  while (current.domainOfCodec) current = current.domainOfCodec;
  return current;
}
function resolveInputCodec2(c) {
  if (c.arrayOfCodec) {
    if (forceTextTypesSensitive.includes(resolveDomains(c.arrayOfCodec))) return listOfCodec(TYPES.text, {
      extensions: {
        listItemNonNull: c.extensions?.listItemNonNull
      }
    });
    return c;
  } else {
    if (forceTextTypesSensitive.includes(resolveDomains(c))) return TYPES.text;
    return c;
  }
}
function resolveSqlIdentifier(identifier, c) {
  if (c.arrayOfCodec && forceTextTypesSensitive.includes(resolveDomains(c.arrayOfCodec))) return [sql`(${identifier})::text[]`, listOfCodec(TYPES.text, {
    extensions: {
      listItemNonNull: c.extensions?.listItemNonNull
    }
  })];else if (forceTextTypesSensitive.includes(resolveDomains(c))) return [sql`(${identifier})::text`, TYPES.text];else return [identifier, c];
}
const resolve3 = (i, v) => sql`${i} <> ${v}`;
const resolve4 = (i, v) => sql`${i} IS DISTINCT FROM ${v}`;
const resolve5 = (i, v) => sql`${i} IS NOT DISTINCT FROM ${v}`;
const resolve6 = (i, v) => sql`${i} = ANY(${v})`;
function resolveInputCodec3(c) {
  if (forceTextTypesSensitive.includes(resolveDomains(c))) return listOfCodec(TYPES.text, {
    extensions: {
      listItemNonNull: !0
    }
  });else return listOfCodec(c, {
    extensions: {
      listItemNonNull: !0
    }
  });
}
const resolve7 = (i, v) => sql`${i} <> ALL(${v})`;
const resolve8 = (i, v) => sql`${i} < ${v}`;
const resolve9 = (i, v) => sql`${i} <= ${v}`;
const resolve10 = (i, v) => sql`${i} > ${v}`;
const resolve11 = (i, v) => sql`${i} >= ${v}`;
const resolve12 = (i, _v, input) => sql`${i} ${input ? sql`IS NULL` : sql`IS NOT NULL`}`;
const resolveInputCodec4 = () => TYPES.boolean;
const resolveSqlValue2 = () => sql.null;
const resolve13 = (i, v) => sql`${i} = ${v}`;
const forceTextTypesSensitive2 = [TYPES.citext, TYPES.char, TYPES.bpchar];
function resolveDomains2(c) {
  let current = c;
  while (current.domainOfCodec) current = current.domainOfCodec;
  return current;
}
function resolveInputCodec5(c) {
  if (c.arrayOfCodec) {
    if (forceTextTypesSensitive2.includes(resolveDomains2(c.arrayOfCodec))) return listOfCodec(TYPES.text, {
      extensions: {
        listItemNonNull: c.extensions?.listItemNonNull
      }
    });
    return c;
  } else {
    if (forceTextTypesSensitive2.includes(resolveDomains2(c))) return TYPES.text;
    return c;
  }
}
function resolveSqlIdentifier2(identifier, c) {
  if (c.arrayOfCodec && forceTextTypesSensitive2.includes(resolveDomains2(c.arrayOfCodec))) return [sql`(${identifier})::text[]`, listOfCodec(TYPES.text, {
    extensions: {
      listItemNonNull: c.extensions?.listItemNonNull
    }
  })];else if (forceTextTypesSensitive2.includes(resolveDomains2(c))) return [sql`(${identifier})::text`, TYPES.text];else return [identifier, c];
}
const resolve14 = (i, v) => sql`${i} <> ${v}`;
const resolve15 = (i, v) => sql`${i} IS DISTINCT FROM ${v}`;
const resolve16 = (i, v) => sql`${i} IS NOT DISTINCT FROM ${v}`;
const resolve17 = (i, v) => sql`${i} = ANY(${v})`;
function resolveInputCodec6(c) {
  if (forceTextTypesSensitive2.includes(resolveDomains2(c))) return listOfCodec(TYPES.text, {
    extensions: {
      listItemNonNull: !0
    }
  });else return listOfCodec(c, {
    extensions: {
      listItemNonNull: !0
    }
  });
}
const resolve18 = (i, v) => sql`${i} <> ALL(${v})`;
const resolve19 = (i, v) => sql`${i} < ${v}`;
const resolve20 = (i, v) => sql`${i} <= ${v}`;
const resolve21 = (i, v) => sql`${i} > ${v}`;
const resolve22 = (i, v) => sql`${i} >= ${v}`;
const resolve23 = (i, v) => sql`${i} LIKE ${v}`;
function escapeLikeWildcards(input) {
  if (typeof input !== "string") throw Error("Non-string input was provided to escapeLikeWildcards");else return input.split("%").join("\\%").split("_").join("\\_");
}
const resolveInput = input => `%${escapeLikeWildcards(input)}%`;
const resolve24 = (i, v) => sql`${i} NOT LIKE ${v}`;
const resolveInput2 = input => `%${escapeLikeWildcards(input)}%`;
const resolve25 = (i, v) => sql`${i} ILIKE ${v}`;
const resolveInput3 = input => `%${escapeLikeWildcards(input)}%`;
const forceTextTypesInsensitive = [TYPES.char, TYPES.bpchar];
function resolveInputCodec7(c) {
  if (c.arrayOfCodec) {
    if (forceTextTypesInsensitive.includes(resolveDomains2(c.arrayOfCodec))) return listOfCodec(TYPES.text, {
      extensions: {
        listItemNonNull: c.extensions?.listItemNonNull
      }
    });
    return c;
  } else {
    if (forceTextTypesInsensitive.includes(resolveDomains2(c))) return TYPES.text;
    return c;
  }
}
function resolveSqlIdentifier3(identifier, c) {
  if (c.arrayOfCodec && forceTextTypesInsensitive.includes(resolveDomains2(c.arrayOfCodec))) return [sql`(${identifier})::text[]`, listOfCodec(TYPES.text, {
    extensions: {
      listItemNonNull: c.extensions?.listItemNonNull
    }
  })];else if (forceTextTypesInsensitive.includes(resolveDomains2(c))) return [sql`(${identifier})::text`, TYPES.text];else return [identifier, c];
}
const resolve26 = (i, v) => sql`${i} NOT ILIKE ${v}`;
const resolveInput4 = input => `%${escapeLikeWildcards(input)}%`;
const resolve27 = (i, v) => sql`${i} LIKE ${v}`;
const resolveInput5 = input => `${escapeLikeWildcards(input)}%`;
const resolve28 = (i, v) => sql`${i} NOT LIKE ${v}`;
const resolveInput6 = input => `${escapeLikeWildcards(input)}%`;
const resolve29 = (i, v) => sql`${i} ILIKE ${v}`;
const resolveInput7 = input => `${escapeLikeWildcards(input)}%`;
const resolve30 = (i, v) => sql`${i} NOT ILIKE ${v}`;
const resolveInput8 = input => `${escapeLikeWildcards(input)}%`;
const resolve31 = (i, v) => sql`${i} LIKE ${v}`;
const resolveInput9 = input => `%${escapeLikeWildcards(input)}`;
const resolve32 = (i, v) => sql`${i} NOT LIKE ${v}`;
const resolveInput10 = input => `%${escapeLikeWildcards(input)}`;
const resolve33 = (i, v) => sql`${i} ILIKE ${v}`;
const resolveInput11 = input => `%${escapeLikeWildcards(input)}`;
const resolve34 = (i, v) => sql`${i} NOT ILIKE ${v}`;
const resolveInput12 = input => `%${escapeLikeWildcards(input)}`;
const resolve35 = (i, v) => sql`${i} LIKE ${v}`;
const resolve36 = (i, v) => sql`${i} NOT LIKE ${v}`;
const resolve37 = (i, v) => sql`${i} ILIKE ${v}`;
const resolve38 = (i, v) => sql`${i} NOT ILIKE ${v}`;
function resolveInputCodec8(inputCodec) {
  if ("equalTo" === "in" || "equalTo" === "notIn") {
    const t = resolveDomains2(inputCodec) === TYPES.citext ? inputCodec : TYPES.text;
    return listOfCodec(t, {
      extensions: {
        listItemNonNull: !0
      }
    });
  } else return resolveDomains2(inputCodec) === TYPES.citext ? inputCodec : TYPES.text;
}
function resolveSqlIdentifier4(sourceAlias, codec) {
  return resolveDomains2(codec) === TYPES.citext ? [sourceAlias, codec] : [sql`lower(${sourceAlias}::text)`, TYPES.text];
}
function resolveSqlValue3(_unused, input, inputCodec) {
  if ("equalTo" === "in" || "equalTo" === "notIn") {
    const sqlList = sqlValueWithCodec(input, inputCodec);
    if (inputCodec.arrayOfCodec === TYPES.citext) return sqlList;else return sql`(select lower(t) from unnest(${sqlList}) t)`;
  } else {
    const sqlValue = sqlValueWithCodec(input, inputCodec);
    if (inputCodec === TYPES.citext) return sqlValue;else return sql`lower(${sqlValue})`;
  }
}
function resolveInputCodec9(inputCodec) {
  if ("notEqualTo" === "in" || "notEqualTo" === "notIn") {
    const t = resolveDomains2(inputCodec) === TYPES.citext ? inputCodec : TYPES.text;
    return listOfCodec(t, {
      extensions: {
        listItemNonNull: !0
      }
    });
  } else return resolveDomains2(inputCodec) === TYPES.citext ? inputCodec : TYPES.text;
}
function resolveSqlIdentifier5(sourceAlias, codec) {
  return resolveDomains2(codec) === TYPES.citext ? [sourceAlias, codec] : [sql`lower(${sourceAlias}::text)`, TYPES.text];
}
function resolveSqlValue4(_unused, input, inputCodec) {
  if ("notEqualTo" === "in" || "notEqualTo" === "notIn") {
    const sqlList = sqlValueWithCodec(input, inputCodec);
    if (inputCodec.arrayOfCodec === TYPES.citext) return sqlList;else return sql`(select lower(t) from unnest(${sqlList}) t)`;
  } else {
    const sqlValue = sqlValueWithCodec(input, inputCodec);
    if (inputCodec === TYPES.citext) return sqlValue;else return sql`lower(${sqlValue})`;
  }
}
function resolveInputCodec10(inputCodec) {
  if ("distinctFrom" === "in" || "distinctFrom" === "notIn") {
    const t = resolveDomains2(inputCodec) === TYPES.citext ? inputCodec : TYPES.text;
    return listOfCodec(t, {
      extensions: {
        listItemNonNull: !0
      }
    });
  } else return resolveDomains2(inputCodec) === TYPES.citext ? inputCodec : TYPES.text;
}
function resolveSqlIdentifier6(sourceAlias, codec) {
  return resolveDomains2(codec) === TYPES.citext ? [sourceAlias, codec] : [sql`lower(${sourceAlias}::text)`, TYPES.text];
}
function resolveSqlValue5(_unused, input, inputCodec) {
  if ("distinctFrom" === "in" || "distinctFrom" === "notIn") {
    const sqlList = sqlValueWithCodec(input, inputCodec);
    if (inputCodec.arrayOfCodec === TYPES.citext) return sqlList;else return sql`(select lower(t) from unnest(${sqlList}) t)`;
  } else {
    const sqlValue = sqlValueWithCodec(input, inputCodec);
    if (inputCodec === TYPES.citext) return sqlValue;else return sql`lower(${sqlValue})`;
  }
}
function resolveInputCodec11(inputCodec) {
  if ("notDistinctFrom" === "in" || "notDistinctFrom" === "notIn") {
    const t = resolveDomains2(inputCodec) === TYPES.citext ? inputCodec : TYPES.text;
    return listOfCodec(t, {
      extensions: {
        listItemNonNull: !0
      }
    });
  } else return resolveDomains2(inputCodec) === TYPES.citext ? inputCodec : TYPES.text;
}
function resolveSqlIdentifier7(sourceAlias, codec) {
  return resolveDomains2(codec) === TYPES.citext ? [sourceAlias, codec] : [sql`lower(${sourceAlias}::text)`, TYPES.text];
}
function resolveSqlValue6(_unused, input, inputCodec) {
  if ("notDistinctFrom" === "in" || "notDistinctFrom" === "notIn") {
    const sqlList = sqlValueWithCodec(input, inputCodec);
    if (inputCodec.arrayOfCodec === TYPES.citext) return sqlList;else return sql`(select lower(t) from unnest(${sqlList}) t)`;
  } else {
    const sqlValue = sqlValueWithCodec(input, inputCodec);
    if (inputCodec === TYPES.citext) return sqlValue;else return sql`lower(${sqlValue})`;
  }
}
function resolveInputCodec12(inputCodec) {
  if ("in" === "in" || "in" === "notIn") {
    const t = resolveDomains2(inputCodec) === TYPES.citext ? inputCodec : TYPES.text;
    return listOfCodec(t, {
      extensions: {
        listItemNonNull: !0
      }
    });
  } else return resolveDomains2(inputCodec) === TYPES.citext ? inputCodec : TYPES.text;
}
function resolveSqlIdentifier8(sourceAlias, codec) {
  return resolveDomains2(codec) === TYPES.citext ? [sourceAlias, codec] : [sql`lower(${sourceAlias}::text)`, TYPES.text];
}
function resolveSqlValue7(_unused, input, inputCodec) {
  if ("in" === "in" || "in" === "notIn") {
    const sqlList = sqlValueWithCodec(input, inputCodec);
    if (inputCodec.arrayOfCodec === TYPES.citext) return sqlList;else return sql`(select lower(t) from unnest(${sqlList}) t)`;
  } else {
    const sqlValue = sqlValueWithCodec(input, inputCodec);
    if (inputCodec === TYPES.citext) return sqlValue;else return sql`lower(${sqlValue})`;
  }
}
function resolveInputCodec13(inputCodec) {
  if ("notIn" === "in" || "notIn" === "notIn") {
    const t = resolveDomains2(inputCodec) === TYPES.citext ? inputCodec : TYPES.text;
    return listOfCodec(t, {
      extensions: {
        listItemNonNull: !0
      }
    });
  } else return resolveDomains2(inputCodec) === TYPES.citext ? inputCodec : TYPES.text;
}
function resolveSqlIdentifier9(sourceAlias, codec) {
  return resolveDomains2(codec) === TYPES.citext ? [sourceAlias, codec] : [sql`lower(${sourceAlias}::text)`, TYPES.text];
}
function resolveSqlValue8(_unused, input, inputCodec) {
  if ("notIn" === "in" || "notIn" === "notIn") {
    const sqlList = sqlValueWithCodec(input, inputCodec);
    if (inputCodec.arrayOfCodec === TYPES.citext) return sqlList;else return sql`(select lower(t) from unnest(${sqlList}) t)`;
  } else {
    const sqlValue = sqlValueWithCodec(input, inputCodec);
    if (inputCodec === TYPES.citext) return sqlValue;else return sql`lower(${sqlValue})`;
  }
}
function resolveInputCodec14(inputCodec) {
  if ("lessThan" === "in" || "lessThan" === "notIn") {
    const t = resolveDomains2(inputCodec) === TYPES.citext ? inputCodec : TYPES.text;
    return listOfCodec(t, {
      extensions: {
        listItemNonNull: !0
      }
    });
  } else return resolveDomains2(inputCodec) === TYPES.citext ? inputCodec : TYPES.text;
}
function resolveSqlIdentifier10(sourceAlias, codec) {
  return resolveDomains2(codec) === TYPES.citext ? [sourceAlias, codec] : [sql`lower(${sourceAlias}::text)`, TYPES.text];
}
function resolveSqlValue9(_unused, input, inputCodec) {
  if ("lessThan" === "in" || "lessThan" === "notIn") {
    const sqlList = sqlValueWithCodec(input, inputCodec);
    if (inputCodec.arrayOfCodec === TYPES.citext) return sqlList;else return sql`(select lower(t) from unnest(${sqlList}) t)`;
  } else {
    const sqlValue = sqlValueWithCodec(input, inputCodec);
    if (inputCodec === TYPES.citext) return sqlValue;else return sql`lower(${sqlValue})`;
  }
}
function resolveInputCodec15(inputCodec) {
  if ("lessThanOrEqualTo" === "in" || "lessThanOrEqualTo" === "notIn") {
    const t = resolveDomains2(inputCodec) === TYPES.citext ? inputCodec : TYPES.text;
    return listOfCodec(t, {
      extensions: {
        listItemNonNull: !0
      }
    });
  } else return resolveDomains2(inputCodec) === TYPES.citext ? inputCodec : TYPES.text;
}
function resolveSqlIdentifier11(sourceAlias, codec) {
  return resolveDomains2(codec) === TYPES.citext ? [sourceAlias, codec] : [sql`lower(${sourceAlias}::text)`, TYPES.text];
}
function resolveSqlValue10(_unused, input, inputCodec) {
  if ("lessThanOrEqualTo" === "in" || "lessThanOrEqualTo" === "notIn") {
    const sqlList = sqlValueWithCodec(input, inputCodec);
    if (inputCodec.arrayOfCodec === TYPES.citext) return sqlList;else return sql`(select lower(t) from unnest(${sqlList}) t)`;
  } else {
    const sqlValue = sqlValueWithCodec(input, inputCodec);
    if (inputCodec === TYPES.citext) return sqlValue;else return sql`lower(${sqlValue})`;
  }
}
function resolveInputCodec16(inputCodec) {
  if ("greaterThan" === "in" || "greaterThan" === "notIn") {
    const t = resolveDomains2(inputCodec) === TYPES.citext ? inputCodec : TYPES.text;
    return listOfCodec(t, {
      extensions: {
        listItemNonNull: !0
      }
    });
  } else return resolveDomains2(inputCodec) === TYPES.citext ? inputCodec : TYPES.text;
}
function resolveSqlIdentifier12(sourceAlias, codec) {
  return resolveDomains2(codec) === TYPES.citext ? [sourceAlias, codec] : [sql`lower(${sourceAlias}::text)`, TYPES.text];
}
function resolveSqlValue11(_unused, input, inputCodec) {
  if ("greaterThan" === "in" || "greaterThan" === "notIn") {
    const sqlList = sqlValueWithCodec(input, inputCodec);
    if (inputCodec.arrayOfCodec === TYPES.citext) return sqlList;else return sql`(select lower(t) from unnest(${sqlList}) t)`;
  } else {
    const sqlValue = sqlValueWithCodec(input, inputCodec);
    if (inputCodec === TYPES.citext) return sqlValue;else return sql`lower(${sqlValue})`;
  }
}
function resolveInputCodec17(inputCodec) {
  if ("greaterThanOrEqualTo" === "in" || "greaterThanOrEqualTo" === "notIn") {
    const t = resolveDomains2(inputCodec) === TYPES.citext ? inputCodec : TYPES.text;
    return listOfCodec(t, {
      extensions: {
        listItemNonNull: !0
      }
    });
  } else return resolveDomains2(inputCodec) === TYPES.citext ? inputCodec : TYPES.text;
}
function resolveSqlIdentifier13(sourceAlias, codec) {
  return resolveDomains2(codec) === TYPES.citext ? [sourceAlias, codec] : [sql`lower(${sourceAlias}::text)`, TYPES.text];
}
function resolveSqlValue12(_unused, input, inputCodec) {
  if ("greaterThanOrEqualTo" === "in" || "greaterThanOrEqualTo" === "notIn") {
    const sqlList = sqlValueWithCodec(input, inputCodec);
    if (inputCodec.arrayOfCodec === TYPES.citext) return sqlList;else return sql`(select lower(t) from unnest(${sqlList}) t)`;
  } else {
    const sqlValue = sqlValueWithCodec(input, inputCodec);
    if (inputCodec === TYPES.citext) return sqlValue;else return sql`lower(${sqlValue})`;
  }
}
const resolve39 = (i, _v, input) => sql`${i} ${input ? sql`IS NULL` : sql`IS NOT NULL`}`;
const resolveInputCodec18 = () => TYPES.boolean;
const resolveSqlValue13 = () => sql.null;
const resolve40 = (i, v) => sql`${i} = ${v}`;
const forceTextTypesSensitive3 = [TYPES.citext, TYPES.char, TYPES.bpchar];
function resolveDomains3(c) {
  let current = c;
  while (current.domainOfCodec) current = current.domainOfCodec;
  return current;
}
function resolveInputCodec19(c) {
  if (c.arrayOfCodec) {
    if (forceTextTypesSensitive3.includes(resolveDomains3(c.arrayOfCodec))) return listOfCodec(TYPES.text, {
      extensions: {
        listItemNonNull: c.extensions?.listItemNonNull
      }
    });
    return c;
  } else {
    if (forceTextTypesSensitive3.includes(resolveDomains3(c))) return TYPES.text;
    return c;
  }
}
function resolveSqlIdentifier14(identifier, c) {
  if (c.arrayOfCodec && forceTextTypesSensitive3.includes(resolveDomains3(c.arrayOfCodec))) return [sql`(${identifier})::text[]`, listOfCodec(TYPES.text, {
    extensions: {
      listItemNonNull: c.extensions?.listItemNonNull
    }
  })];else if (forceTextTypesSensitive3.includes(resolveDomains3(c))) return [sql`(${identifier})::text`, TYPES.text];else return [identifier, c];
}
const resolve41 = (i, v) => sql`${i} <> ${v}`;
const resolve42 = (i, v) => sql`${i} IS DISTINCT FROM ${v}`;
const resolve43 = (i, v) => sql`${i} IS NOT DISTINCT FROM ${v}`;
const resolve44 = (i, v) => sql`${i} = ANY(${v})`;
function resolveInputCodec20(c) {
  if (forceTextTypesSensitive3.includes(resolveDomains3(c))) return listOfCodec(TYPES.text, {
    extensions: {
      listItemNonNull: !0
    }
  });else return listOfCodec(c, {
    extensions: {
      listItemNonNull: !0
    }
  });
}
const resolve45 = (i, v) => sql`${i} <> ALL(${v})`;
const resolve46 = (i, v) => sql`${i} < ${v}`;
const resolve47 = (i, v) => sql`${i} <= ${v}`;
const resolve48 = (i, v) => sql`${i} > ${v}`;
const resolve49 = (i, v) => sql`${i} >= ${v}`;
const resolve50 = (i, _v, input) => sql`${i} ${input ? sql`IS NULL` : sql`IS NOT NULL`}`;
const resolveInputCodec21 = () => TYPES.boolean;
const resolveSqlValue14 = () => sql.null;
const resolve51 = (i, v) => sql`${i} = ${v}`;
const forceTextTypesSensitive4 = [TYPES.citext, TYPES.char, TYPES.bpchar];
function resolveDomains4(c) {
  let current = c;
  while (current.domainOfCodec) current = current.domainOfCodec;
  return current;
}
function resolveInputCodec22(c) {
  if (c.arrayOfCodec) {
    if (forceTextTypesSensitive4.includes(resolveDomains4(c.arrayOfCodec))) return listOfCodec(TYPES.text, {
      extensions: {
        listItemNonNull: c.extensions?.listItemNonNull
      }
    });
    return c;
  } else {
    if (forceTextTypesSensitive4.includes(resolveDomains4(c))) return TYPES.text;
    return c;
  }
}
function resolveSqlIdentifier15(identifier, c) {
  if (c.arrayOfCodec && forceTextTypesSensitive4.includes(resolveDomains4(c.arrayOfCodec))) return [sql`(${identifier})::text[]`, listOfCodec(TYPES.text, {
    extensions: {
      listItemNonNull: c.extensions?.listItemNonNull
    }
  })];else if (forceTextTypesSensitive4.includes(resolveDomains4(c))) return [sql`(${identifier})::text`, TYPES.text];else return [identifier, c];
}
const resolve52 = (i, v) => sql`${i} <> ${v}`;
const resolve53 = (i, v) => sql`${i} IS DISTINCT FROM ${v}`;
const resolve54 = (i, v) => sql`${i} IS NOT DISTINCT FROM ${v}`;
const resolve55 = (i, v) => sql`${i} = ANY(${v})`;
function resolveInputCodec23(c) {
  if (forceTextTypesSensitive4.includes(resolveDomains4(c))) return listOfCodec(TYPES.text, {
    extensions: {
      listItemNonNull: !0
    }
  });else return listOfCodec(c, {
    extensions: {
      listItemNonNull: !0
    }
  });
}
const resolve56 = (i, v) => sql`${i} <> ALL(${v})`;
const resolve57 = (i, v) => sql`${i} < ${v}`;
const resolve58 = (i, v) => sql`${i} <= ${v}`;
const resolve59 = (i, v) => sql`${i} > ${v}`;
const resolve60 = (i, v) => sql`${i} >= ${v}`;
const colSpec8 = {
  fieldName: "rowId",
  attributeName: "id",
  attribute: spec_user.attributes.id
};
const colSpec9 = {
  fieldName: "username",
  attributeName: "username",
  attribute: spec_user.attributes.username
};
function assertAllowed49(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed50(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed51(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed52(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
const colSpec10 = {
  fieldName: "rowId",
  attributeName: "id",
  attribute: spec_bounty.attributes.id
};
const colSpec11 = {
  fieldName: "organizationId",
  attributeName: "organization_id",
  attribute: spec_bounty.attributes.organization_id
};
const colSpec12 = {
  fieldName: "externalUrl",
  attributeName: "external_url",
  attribute: spec_bounty.attributes.external_url
};
const colSpec13 = {
  fieldName: "status",
  attributeName: "status",
  attribute: spec_bounty.attributes.status
};
const colSpec14 = {
  fieldName: "claimantId",
  attributeName: "claimant_id",
  attribute: spec_bounty.attributes.claimant_id
};
function assertAllowed53(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed54(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed55(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
const resolve61 = (i, _v, input) => sql`${i} ${input ? sql`IS NULL` : sql`IS NOT NULL`}`;
const resolveInputCodec24 = () => TYPES.boolean;
const resolveSqlValue15 = () => sql.null;
const resolve62 = (i, v) => sql`${i} = ${v}`;
const forceTextTypesSensitive5 = [TYPES.citext, TYPES.char, TYPES.bpchar];
function resolveDomains5(c) {
  let current = c;
  while (current.domainOfCodec) current = current.domainOfCodec;
  return current;
}
function resolveInputCodec25(c) {
  if (c.arrayOfCodec) {
    if (forceTextTypesSensitive5.includes(resolveDomains5(c.arrayOfCodec))) return listOfCodec(TYPES.text, {
      extensions: {
        listItemNonNull: c.extensions?.listItemNonNull
      }
    });
    return c;
  } else {
    if (forceTextTypesSensitive5.includes(resolveDomains5(c))) return TYPES.text;
    return c;
  }
}
function resolveSqlIdentifier16(identifier, c) {
  if (c.arrayOfCodec && forceTextTypesSensitive5.includes(resolveDomains5(c.arrayOfCodec))) return [sql`(${identifier})::text[]`, listOfCodec(TYPES.text, {
    extensions: {
      listItemNonNull: c.extensions?.listItemNonNull
    }
  })];else if (forceTextTypesSensitive5.includes(resolveDomains5(c))) return [sql`(${identifier})::text`, TYPES.text];else return [identifier, c];
}
const resolve63 = (i, v) => sql`${i} <> ${v}`;
const resolve64 = (i, v) => sql`${i} IS DISTINCT FROM ${v}`;
const resolve65 = (i, v) => sql`${i} IS NOT DISTINCT FROM ${v}`;
const resolve66 = (i, v) => sql`${i} = ANY(${v})`;
function resolveInputCodec26(c) {
  if (forceTextTypesSensitive5.includes(resolveDomains5(c))) return listOfCodec(TYPES.text, {
    extensions: {
      listItemNonNull: !0
    }
  });else return listOfCodec(c, {
    extensions: {
      listItemNonNull: !0
    }
  });
}
const resolve67 = (i, v) => sql`${i} <> ALL(${v})`;
const resolve68 = (i, v) => sql`${i} < ${v}`;
const resolve69 = (i, v) => sql`${i} <= ${v}`;
const resolve70 = (i, v) => sql`${i} > ${v}`;
const resolve71 = (i, v) => sql`${i} >= ${v}`;
function assertAllowed56(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
const colSpec15 = {
  fieldName: "rowId",
  attributeName: "id",
  attribute: spec_bountyFunding.attributes.id
};
const colSpec16 = {
  fieldName: "bountyId",
  attributeName: "bounty_id",
  attribute: spec_bountyFunding.attributes.bounty_id
};
const colSpec17 = {
  fieldName: "funderId",
  attributeName: "funder_id",
  attribute: spec_bountyFunding.attributes.funder_id
};
const colSpec18 = {
  fieldName: "transactionId",
  attributeName: "transaction_id",
  attribute: spec_bountyFunding.attributes.transaction_id
};
function assertAllowed57(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed58(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
const colSpec19 = {
  fieldName: "rowId",
  attributeName: "id",
  attribute: spec_transaction.attributes.id
};
const colSpec20 = {
  fieldName: "fromUserId",
  attributeName: "from_user_id",
  attribute: spec_transaction.attributes.from_user_id
};
const colSpec21 = {
  fieldName: "toOrganizationId",
  attributeName: "to_organization_id",
  attribute: spec_transaction.attributes.to_organization_id
};
const colSpec22 = {
  fieldName: "toUserId",
  attributeName: "to_user_id",
  attribute: spec_transaction.attributes.to_user_id
};
const colSpec23 = {
  fieldName: "processorConnectionId",
  attributeName: "processor_connection_id",
  attribute: spec_transaction.attributes.processor_connection_id
};
const colSpec24 = {
  fieldName: "externalTransactionId",
  attributeName: "external_transaction_id",
  attribute: spec_transaction.attributes.external_transaction_id
};
const colSpec25 = {
  fieldName: "transactionType",
  attributeName: "transaction_type",
  attribute: spec_transaction.attributes.transaction_type
};
const colSpec26 = {
  fieldName: "status",
  attributeName: "status",
  attribute: spec_transaction.attributes.status
};
const colSpec27 = {
  fieldName: "createdAt",
  attributeName: "created_at",
  attribute: spec_transaction.attributes.created_at
};
function assertAllowed59(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed60(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed61(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
const resolve72 = (i, _v, input) => sql`${i} ${input ? sql`IS NULL` : sql`IS NOT NULL`}`;
const resolveInputCodec27 = () => TYPES.boolean;
const resolveSqlValue16 = () => sql.null;
const resolve73 = (i, v) => sql`${i} = ${v}`;
const forceTextTypesSensitive6 = [TYPES.citext, TYPES.char, TYPES.bpchar];
function resolveDomains6(c) {
  let current = c;
  while (current.domainOfCodec) current = current.domainOfCodec;
  return current;
}
function resolveInputCodec28(c) {
  if (c.arrayOfCodec) {
    if (forceTextTypesSensitive6.includes(resolveDomains6(c.arrayOfCodec))) return listOfCodec(TYPES.text, {
      extensions: {
        listItemNonNull: c.extensions?.listItemNonNull
      }
    });
    return c;
  } else {
    if (forceTextTypesSensitive6.includes(resolveDomains6(c))) return TYPES.text;
    return c;
  }
}
function resolveSqlIdentifier17(identifier, c) {
  if (c.arrayOfCodec && forceTextTypesSensitive6.includes(resolveDomains6(c.arrayOfCodec))) return [sql`(${identifier})::text[]`, listOfCodec(TYPES.text, {
    extensions: {
      listItemNonNull: c.extensions?.listItemNonNull
    }
  })];else if (forceTextTypesSensitive6.includes(resolveDomains6(c))) return [sql`(${identifier})::text`, TYPES.text];else return [identifier, c];
}
const resolve74 = (i, v) => sql`${i} <> ${v}`;
const resolve75 = (i, v) => sql`${i} IS DISTINCT FROM ${v}`;
const resolve76 = (i, v) => sql`${i} IS NOT DISTINCT FROM ${v}`;
const resolve77 = (i, v) => sql`${i} = ANY(${v})`;
function resolveInputCodec29(c) {
  if (forceTextTypesSensitive6.includes(resolveDomains6(c))) return listOfCodec(TYPES.text, {
    extensions: {
      listItemNonNull: !0
    }
  });else return listOfCodec(c, {
    extensions: {
      listItemNonNull: !0
    }
  });
}
const resolve78 = (i, v) => sql`${i} <> ALL(${v})`;
const resolve79 = (i, v) => sql`${i} < ${v}`;
const resolve80 = (i, v) => sql`${i} <= ${v}`;
const resolve81 = (i, v) => sql`${i} > ${v}`;
const resolve82 = (i, v) => sql`${i} >= ${v}`;
const resolve83 = (i, _v, input) => sql`${i} ${input ? sql`IS NULL` : sql`IS NOT NULL`}`;
const resolveInputCodec30 = () => TYPES.boolean;
const resolveSqlValue17 = () => sql.null;
const resolve84 = (i, v) => sql`${i} = ${v}`;
const forceTextTypesSensitive7 = [TYPES.citext, TYPES.char, TYPES.bpchar];
function resolveDomains7(c) {
  let current = c;
  while (current.domainOfCodec) current = current.domainOfCodec;
  return current;
}
function resolveInputCodec31(c) {
  if (c.arrayOfCodec) {
    if (forceTextTypesSensitive7.includes(resolveDomains7(c.arrayOfCodec))) return listOfCodec(TYPES.text, {
      extensions: {
        listItemNonNull: c.extensions?.listItemNonNull
      }
    });
    return c;
  } else {
    if (forceTextTypesSensitive7.includes(resolveDomains7(c))) return TYPES.text;
    return c;
  }
}
function resolveSqlIdentifier18(identifier, c) {
  if (c.arrayOfCodec && forceTextTypesSensitive7.includes(resolveDomains7(c.arrayOfCodec))) return [sql`(${identifier})::text[]`, listOfCodec(TYPES.text, {
    extensions: {
      listItemNonNull: c.extensions?.listItemNonNull
    }
  })];else if (forceTextTypesSensitive7.includes(resolveDomains7(c))) return [sql`(${identifier})::text`, TYPES.text];else return [identifier, c];
}
const resolve85 = (i, v) => sql`${i} <> ${v}`;
const resolve86 = (i, v) => sql`${i} IS DISTINCT FROM ${v}`;
const resolve87 = (i, v) => sql`${i} IS NOT DISTINCT FROM ${v}`;
const resolve88 = (i, v) => sql`${i} = ANY(${v})`;
function resolveInputCodec32(c) {
  if (forceTextTypesSensitive7.includes(resolveDomains7(c))) return listOfCodec(TYPES.text, {
    extensions: {
      listItemNonNull: !0
    }
  });else return listOfCodec(c, {
    extensions: {
      listItemNonNull: !0
    }
  });
}
const resolve89 = (i, v) => sql`${i} <> ALL(${v})`;
const resolve90 = (i, v) => sql`${i} < ${v}`;
const resolve91 = (i, v) => sql`${i} <= ${v}`;
const resolve92 = (i, v) => sql`${i} > ${v}`;
const resolve93 = (i, v) => sql`${i} >= ${v}`;
function assertAllowed62(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed63(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
const colSpec28 = {
  fieldName: "rowId",
  attributeName: "id",
  attribute: spec_donation.attributes.id
};
const colSpec29 = {
  fieldName: "donorId",
  attributeName: "donor_id",
  attribute: spec_donation.attributes.donor_id
};
const colSpec30 = {
  fieldName: "organizationId",
  attributeName: "organization_id",
  attribute: spec_donation.attributes.organization_id
};
const colSpec31 = {
  fieldName: "transactionId",
  attributeName: "transaction_id",
  attribute: spec_donation.attributes.transaction_id
};
function assertAllowed64(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed65(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
const colSpec32 = {
  fieldName: "rowId",
  attributeName: "id",
  attribute: spec_organization.attributes.id
};
const colSpec33 = {
  fieldName: "slug",
  attributeName: "slug",
  attribute: spec_organization.attributes.slug
};
function assertAllowed66(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed67(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed68(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed69(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed70(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed71(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
const colSpec34 = {
  fieldName: "rowId",
  attributeName: "id",
  attribute: spec_grantProgram.attributes.id
};
const colSpec35 = {
  fieldName: "organizationId",
  attributeName: "organization_id",
  attribute: spec_grantProgram.attributes.organization_id
};
const colSpec36 = {
  fieldName: "slug",
  attributeName: "slug",
  attribute: spec_grantProgram.attributes.slug
};
const colSpec37 = {
  fieldName: "isActive",
  attributeName: "is_active",
  attribute: spec_grantProgram.attributes.is_active
};
function assertAllowed72(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed73(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed74(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
const resolve94 = (i, _v, input) => sql`${i} ${input ? sql`IS NULL` : sql`IS NOT NULL`}`;
const resolveInputCodec33 = () => TYPES.boolean;
const resolveSqlValue18 = () => sql.null;
const resolve95 = (i, v) => sql`${i} = ${v}`;
const forceTextTypesSensitive8 = [TYPES.citext, TYPES.char, TYPES.bpchar];
function resolveDomains8(c) {
  let current = c;
  while (current.domainOfCodec) current = current.domainOfCodec;
  return current;
}
function resolveInputCodec34(c) {
  if (c.arrayOfCodec) {
    if (forceTextTypesSensitive8.includes(resolveDomains8(c.arrayOfCodec))) return listOfCodec(TYPES.text, {
      extensions: {
        listItemNonNull: c.extensions?.listItemNonNull
      }
    });
    return c;
  } else {
    if (forceTextTypesSensitive8.includes(resolveDomains8(c))) return TYPES.text;
    return c;
  }
}
function resolveSqlIdentifier19(identifier, c) {
  if (c.arrayOfCodec && forceTextTypesSensitive8.includes(resolveDomains8(c.arrayOfCodec))) return [sql`(${identifier})::text[]`, listOfCodec(TYPES.text, {
    extensions: {
      listItemNonNull: c.extensions?.listItemNonNull
    }
  })];else if (forceTextTypesSensitive8.includes(resolveDomains8(c))) return [sql`(${identifier})::text`, TYPES.text];else return [identifier, c];
}
const resolve96 = (i, v) => sql`${i} <> ${v}`;
const resolve97 = (i, v) => sql`${i} IS DISTINCT FROM ${v}`;
const resolve98 = (i, v) => sql`${i} IS NOT DISTINCT FROM ${v}`;
const resolve99 = (i, v) => sql`${i} = ANY(${v})`;
function resolveInputCodec35(c) {
  if (forceTextTypesSensitive8.includes(resolveDomains8(c))) return listOfCodec(TYPES.text, {
    extensions: {
      listItemNonNull: !0
    }
  });else return listOfCodec(c, {
    extensions: {
      listItemNonNull: !0
    }
  });
}
const resolve100 = (i, v) => sql`${i} <> ALL(${v})`;
const resolve101 = (i, v) => sql`${i} < ${v}`;
const resolve102 = (i, v) => sql`${i} <= ${v}`;
const resolve103 = (i, v) => sql`${i} > ${v}`;
const resolve104 = (i, v) => sql`${i} >= ${v}`;
function assertAllowed75(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
const colSpec38 = {
  fieldName: "rowId",
  attributeName: "id",
  attribute: spec_grantApplication.attributes.id
};
const colSpec39 = {
  fieldName: "grantProgramId",
  attributeName: "grant_program_id",
  attribute: spec_grantApplication.attributes.grant_program_id
};
const colSpec40 = {
  fieldName: "applicantId",
  attributeName: "applicant_id",
  attribute: spec_grantApplication.attributes.applicant_id
};
const colSpec41 = {
  fieldName: "status",
  attributeName: "status",
  attribute: spec_grantApplication.attributes.status
};
function assertAllowed76(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed77(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed78(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
const resolve105 = (i, _v, input) => sql`${i} ${input ? sql`IS NULL` : sql`IS NOT NULL`}`;
const resolveInputCodec36 = () => TYPES.boolean;
const resolveSqlValue19 = () => sql.null;
const resolve106 = (i, v) => sql`${i} = ${v}`;
const forceTextTypesSensitive9 = [TYPES.citext, TYPES.char, TYPES.bpchar];
function resolveDomains9(c) {
  let current = c;
  while (current.domainOfCodec) current = current.domainOfCodec;
  return current;
}
function resolveInputCodec37(c) {
  if (c.arrayOfCodec) {
    if (forceTextTypesSensitive9.includes(resolveDomains9(c.arrayOfCodec))) return listOfCodec(TYPES.text, {
      extensions: {
        listItemNonNull: c.extensions?.listItemNonNull
      }
    });
    return c;
  } else {
    if (forceTextTypesSensitive9.includes(resolveDomains9(c))) return TYPES.text;
    return c;
  }
}
function resolveSqlIdentifier20(identifier, c) {
  if (c.arrayOfCodec && forceTextTypesSensitive9.includes(resolveDomains9(c.arrayOfCodec))) return [sql`(${identifier})::text[]`, listOfCodec(TYPES.text, {
    extensions: {
      listItemNonNull: c.extensions?.listItemNonNull
    }
  })];else if (forceTextTypesSensitive9.includes(resolveDomains9(c))) return [sql`(${identifier})::text`, TYPES.text];else return [identifier, c];
}
const resolve107 = (i, v) => sql`${i} <> ${v}`;
const resolve108 = (i, v) => sql`${i} IS DISTINCT FROM ${v}`;
const resolve109 = (i, v) => sql`${i} IS NOT DISTINCT FROM ${v}`;
const resolve110 = (i, v) => sql`${i} = ANY(${v})`;
function resolveInputCodec38(c) {
  if (forceTextTypesSensitive9.includes(resolveDomains9(c))) return listOfCodec(TYPES.text, {
    extensions: {
      listItemNonNull: !0
    }
  });else return listOfCodec(c, {
    extensions: {
      listItemNonNull: !0
    }
  });
}
const resolve111 = (i, v) => sql`${i} <> ALL(${v})`;
const resolve112 = (i, v) => sql`${i} < ${v}`;
const resolve113 = (i, v) => sql`${i} <= ${v}`;
const resolve114 = (i, v) => sql`${i} > ${v}`;
const resolve115 = (i, v) => sql`${i} >= ${v}`;
function assertAllowed79(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
const colSpec42 = {
  fieldName: "rowId",
  attributeName: "id",
  attribute: spec_grantMilestone.attributes.id
};
const colSpec43 = {
  fieldName: "grantApplicationId",
  attributeName: "grant_application_id",
  attribute: spec_grantMilestone.attributes.grant_application_id
};
const colSpec44 = {
  fieldName: "status",
  attributeName: "status",
  attribute: spec_grantMilestone.attributes.status
};
function assertAllowed80(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed81(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
const resolve116 = (i, _v, input) => sql`${i} ${input ? sql`IS NULL` : sql`IS NOT NULL`}`;
const resolveInputCodec39 = () => TYPES.boolean;
const resolveSqlValue20 = () => sql.null;
const resolve117 = (i, v) => sql`${i} = ${v}`;
const forceTextTypesSensitive10 = [TYPES.citext, TYPES.char, TYPES.bpchar];
function resolveDomains10(c) {
  let current = c;
  while (current.domainOfCodec) current = current.domainOfCodec;
  return current;
}
function resolveInputCodec40(c) {
  if (c.arrayOfCodec) {
    if (forceTextTypesSensitive10.includes(resolveDomains10(c.arrayOfCodec))) return listOfCodec(TYPES.text, {
      extensions: {
        listItemNonNull: c.extensions?.listItemNonNull
      }
    });
    return c;
  } else {
    if (forceTextTypesSensitive10.includes(resolveDomains10(c))) return TYPES.text;
    return c;
  }
}
function resolveSqlIdentifier21(identifier, c) {
  if (c.arrayOfCodec && forceTextTypesSensitive10.includes(resolveDomains10(c.arrayOfCodec))) return [sql`(${identifier})::text[]`, listOfCodec(TYPES.text, {
    extensions: {
      listItemNonNull: c.extensions?.listItemNonNull
    }
  })];else if (forceTextTypesSensitive10.includes(resolveDomains10(c))) return [sql`(${identifier})::text`, TYPES.text];else return [identifier, c];
}
const resolve118 = (i, v) => sql`${i} <> ${v}`;
const resolve119 = (i, v) => sql`${i} IS DISTINCT FROM ${v}`;
const resolve120 = (i, v) => sql`${i} IS NOT DISTINCT FROM ${v}`;
const resolve121 = (i, v) => sql`${i} = ANY(${v})`;
function resolveInputCodec41(c) {
  if (forceTextTypesSensitive10.includes(resolveDomains10(c))) return listOfCodec(TYPES.text, {
    extensions: {
      listItemNonNull: !0
    }
  });else return listOfCodec(c, {
    extensions: {
      listItemNonNull: !0
    }
  });
}
const resolve122 = (i, v) => sql`${i} <> ALL(${v})`;
const resolve123 = (i, v) => sql`${i} < ${v}`;
const resolve124 = (i, v) => sql`${i} <= ${v}`;
const resolve125 = (i, v) => sql`${i} > ${v}`;
const resolve126 = (i, v) => sql`${i} >= ${v}`;
function assertAllowed82(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
const colSpec45 = {
  fieldName: "rowId",
  attributeName: "id",
  attribute: spec_userOrganization.attributes.id
};
const colSpec46 = {
  fieldName: "userId",
  attributeName: "user_id",
  attribute: spec_userOrganization.attributes.user_id
};
const colSpec47 = {
  fieldName: "organizationId",
  attributeName: "organization_id",
  attribute: spec_userOrganization.attributes.organization_id
};
function assertAllowed83(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed84(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed85(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
const colSpec48 = {
  fieldName: "rowId",
  attributeName: "id",
  attribute: spec_sponsorshipTier.attributes.id
};
const colSpec49 = {
  fieldName: "organizationId",
  attributeName: "organization_id",
  attribute: spec_sponsorshipTier.attributes.organization_id
};
const colSpec50 = {
  fieldName: "isActive",
  attributeName: "is_active",
  attribute: spec_sponsorshipTier.attributes.is_active
};
function assertAllowed86(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed87(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed88(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed89(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
const colSpec51 = {
  fieldName: "rowId",
  attributeName: "id",
  attribute: spec_sponsorship.attributes.id
};
const colSpec52 = {
  fieldName: "sponsorId",
  attributeName: "sponsor_id",
  attribute: spec_sponsorship.attributes.sponsor_id
};
const colSpec53 = {
  fieldName: "organizationId",
  attributeName: "organization_id",
  attribute: spec_sponsorship.attributes.organization_id
};
const colSpec54 = {
  fieldName: "tierId",
  attributeName: "tier_id",
  attribute: spec_sponsorship.attributes.tier_id
};
const colSpec55 = {
  fieldName: "frequency",
  attributeName: "frequency",
  attribute: spec_sponsorship.attributes.frequency
};
const colSpec56 = {
  fieldName: "status",
  attributeName: "status",
  attribute: spec_sponsorship.attributes.status
};
function assertAllowed90(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed91(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
const resolve127 = (i, _v, input) => sql`${i} ${input ? sql`IS NULL` : sql`IS NOT NULL`}`;
const resolveInputCodec42 = () => TYPES.boolean;
const resolveSqlValue21 = () => sql.null;
const resolve128 = (i, v) => sql`${i} = ${v}`;
const forceTextTypesSensitive11 = [TYPES.citext, TYPES.char, TYPES.bpchar];
function resolveDomains11(c) {
  let current = c;
  while (current.domainOfCodec) current = current.domainOfCodec;
  return current;
}
function resolveInputCodec43(c) {
  if (c.arrayOfCodec) {
    if (forceTextTypesSensitive11.includes(resolveDomains11(c.arrayOfCodec))) return listOfCodec(TYPES.text, {
      extensions: {
        listItemNonNull: c.extensions?.listItemNonNull
      }
    });
    return c;
  } else {
    if (forceTextTypesSensitive11.includes(resolveDomains11(c))) return TYPES.text;
    return c;
  }
}
function resolveSqlIdentifier22(identifier, c) {
  if (c.arrayOfCodec && forceTextTypesSensitive11.includes(resolveDomains11(c.arrayOfCodec))) return [sql`(${identifier})::text[]`, listOfCodec(TYPES.text, {
    extensions: {
      listItemNonNull: c.extensions?.listItemNonNull
    }
  })];else if (forceTextTypesSensitive11.includes(resolveDomains11(c))) return [sql`(${identifier})::text`, TYPES.text];else return [identifier, c];
}
const resolve129 = (i, v) => sql`${i} <> ${v}`;
const resolve130 = (i, v) => sql`${i} IS DISTINCT FROM ${v}`;
const resolve131 = (i, v) => sql`${i} IS NOT DISTINCT FROM ${v}`;
const resolve132 = (i, v) => sql`${i} = ANY(${v})`;
function resolveInputCodec44(c) {
  if (forceTextTypesSensitive11.includes(resolveDomains11(c))) return listOfCodec(TYPES.text, {
    extensions: {
      listItemNonNull: !0
    }
  });else return listOfCodec(c, {
    extensions: {
      listItemNonNull: !0
    }
  });
}
const resolve133 = (i, v) => sql`${i} <> ALL(${v})`;
const resolve134 = (i, v) => sql`${i} < ${v}`;
const resolve135 = (i, v) => sql`${i} <= ${v}`;
const resolve136 = (i, v) => sql`${i} > ${v}`;
const resolve137 = (i, v) => sql`${i} >= ${v}`;
const resolve138 = (i, _v, input) => sql`${i} ${input ? sql`IS NULL` : sql`IS NOT NULL`}`;
const resolveInputCodec45 = () => TYPES.boolean;
const resolveSqlValue22 = () => sql.null;
const resolve139 = (i, v) => sql`${i} = ${v}`;
const forceTextTypesSensitive12 = [TYPES.citext, TYPES.char, TYPES.bpchar];
function resolveDomains12(c) {
  let current = c;
  while (current.domainOfCodec) current = current.domainOfCodec;
  return current;
}
function resolveInputCodec46(c) {
  if (c.arrayOfCodec) {
    if (forceTextTypesSensitive12.includes(resolveDomains12(c.arrayOfCodec))) return listOfCodec(TYPES.text, {
      extensions: {
        listItemNonNull: c.extensions?.listItemNonNull
      }
    });
    return c;
  } else {
    if (forceTextTypesSensitive12.includes(resolveDomains12(c))) return TYPES.text;
    return c;
  }
}
function resolveSqlIdentifier23(identifier, c) {
  if (c.arrayOfCodec && forceTextTypesSensitive12.includes(resolveDomains12(c.arrayOfCodec))) return [sql`(${identifier})::text[]`, listOfCodec(TYPES.text, {
    extensions: {
      listItemNonNull: c.extensions?.listItemNonNull
    }
  })];else if (forceTextTypesSensitive12.includes(resolveDomains12(c))) return [sql`(${identifier})::text`, TYPES.text];else return [identifier, c];
}
const resolve140 = (i, v) => sql`${i} <> ${v}`;
const resolve141 = (i, v) => sql`${i} IS DISTINCT FROM ${v}`;
const resolve142 = (i, v) => sql`${i} IS NOT DISTINCT FROM ${v}`;
const resolve143 = (i, v) => sql`${i} = ANY(${v})`;
function resolveInputCodec47(c) {
  if (forceTextTypesSensitive12.includes(resolveDomains12(c))) return listOfCodec(TYPES.text, {
    extensions: {
      listItemNonNull: !0
    }
  });else return listOfCodec(c, {
    extensions: {
      listItemNonNull: !0
    }
  });
}
const resolve144 = (i, v) => sql`${i} <> ALL(${v})`;
const resolve145 = (i, v) => sql`${i} < ${v}`;
const resolve146 = (i, v) => sql`${i} <= ${v}`;
const resolve147 = (i, v) => sql`${i} > ${v}`;
const resolve148 = (i, v) => sql`${i} >= ${v}`;
function assertAllowed92(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed93(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
const colSpec57 = {
  fieldName: "rowId",
  attributeName: "id",
  attribute: spec_paymentProcessorConnection.attributes.id
};
const colSpec58 = {
  fieldName: "organizationId",
  attributeName: "organization_id",
  attribute: spec_paymentProcessorConnection.attributes.organization_id
};
const colSpec59 = {
  fieldName: "processor",
  attributeName: "processor",
  attribute: spec_paymentProcessorConnection.attributes.processor
};
const colSpec60 = {
  fieldName: "externalAccountId",
  attributeName: "external_account_id",
  attribute: spec_paymentProcessorConnection.attributes.external_account_id
};
const colSpec61 = {
  fieldName: "isActive",
  attributeName: "is_active",
  attribute: spec_paymentProcessorConnection.attributes.is_active
};
function assertAllowed94(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed95(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed96(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
const resolve149 = (i, _v, input) => sql`${i} ${input ? sql`IS NULL` : sql`IS NOT NULL`}`;
const resolveInputCodec48 = () => TYPES.boolean;
const resolveSqlValue23 = () => sql.null;
const resolve150 = (i, v) => sql`${i} = ${v}`;
const forceTextTypesSensitive13 = [TYPES.citext, TYPES.char, TYPES.bpchar];
function resolveDomains13(c) {
  let current = c;
  while (current.domainOfCodec) current = current.domainOfCodec;
  return current;
}
function resolveInputCodec49(c) {
  if (c.arrayOfCodec) {
    if (forceTextTypesSensitive13.includes(resolveDomains13(c.arrayOfCodec))) return listOfCodec(TYPES.text, {
      extensions: {
        listItemNonNull: c.extensions?.listItemNonNull
      }
    });
    return c;
  } else {
    if (forceTextTypesSensitive13.includes(resolveDomains13(c))) return TYPES.text;
    return c;
  }
}
function resolveSqlIdentifier24(identifier, c) {
  if (c.arrayOfCodec && forceTextTypesSensitive13.includes(resolveDomains13(c.arrayOfCodec))) return [sql`(${identifier})::text[]`, listOfCodec(TYPES.text, {
    extensions: {
      listItemNonNull: c.extensions?.listItemNonNull
    }
  })];else if (forceTextTypesSensitive13.includes(resolveDomains13(c))) return [sql`(${identifier})::text`, TYPES.text];else return [identifier, c];
}
const resolve151 = (i, v) => sql`${i} <> ${v}`;
const resolve152 = (i, v) => sql`${i} IS DISTINCT FROM ${v}`;
const resolve153 = (i, v) => sql`${i} IS NOT DISTINCT FROM ${v}`;
const resolve154 = (i, v) => sql`${i} = ANY(${v})`;
function resolveInputCodec50(c) {
  if (forceTextTypesSensitive13.includes(resolveDomains13(c))) return listOfCodec(TYPES.text, {
    extensions: {
      listItemNonNull: !0
    }
  });else return listOfCodec(c, {
    extensions: {
      listItemNonNull: !0
    }
  });
}
const resolve155 = (i, v) => sql`${i} <> ALL(${v})`;
const resolve156 = (i, v) => sql`${i} < ${v}`;
const resolve157 = (i, v) => sql`${i} <= ${v}`;
const resolve158 = (i, v) => sql`${i} > ${v}`;
const resolve159 = (i, v) => sql`${i} >= ${v}`;
function assertAllowed97(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed98(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed99(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
const colSpec62 = {
  fieldName: "rowId",
  attributeName: "id",
  attribute: spec_payout.attributes.id
};
const colSpec63 = {
  fieldName: "recipientUserId",
  attributeName: "recipient_user_id",
  attribute: spec_payout.attributes.recipient_user_id
};
const colSpec64 = {
  fieldName: "fromOrganizationId",
  attributeName: "from_organization_id",
  attribute: spec_payout.attributes.from_organization_id
};
const colSpec65 = {
  fieldName: "status",
  attributeName: "status",
  attribute: spec_payout.attributes.status
};
const colSpec66 = {
  fieldName: "createdAt",
  attributeName: "created_at",
  attribute: spec_payout.attributes.created_at
};
function assertAllowed100(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed101(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed102(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
const colSpec67 = {
  fieldName: "rowId",
  attributeName: "id",
  attribute: spec_webhookEndpoint.attributes.id
};
const colSpec68 = {
  fieldName: "organizationId",
  attributeName: "organization_id",
  attribute: spec_webhookEndpoint.attributes.organization_id
};
const colSpec69 = {
  fieldName: "isActive",
  attributeName: "is_active",
  attribute: spec_webhookEndpoint.attributes.is_active
};
function assertAllowed103(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed104(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed105(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed106(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
const colSpec70 = {
  fieldName: "rowId",
  attributeName: "id",
  attribute: spec_webhookDelivery.attributes.id
};
const colSpec71 = {
  fieldName: "webhookEndpointId",
  attributeName: "webhook_endpoint_id",
  attribute: spec_webhookDelivery.attributes.webhook_endpoint_id
};
const colSpec72 = {
  fieldName: "isSuccessful",
  attributeName: "is_successful",
  attribute: spec_webhookDelivery.attributes.is_successful
};
const colSpec73 = {
  fieldName: "nextRetryAt",
  attributeName: "next_retry_at",
  attribute: spec_webhookDelivery.attributes.next_retry_at
};
const colSpec74 = {
  fieldName: "createdAt",
  attributeName: "created_at",
  attribute: spec_webhookDelivery.attributes.created_at
};
function assertAllowed107(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed108(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed109(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
const colSpec75 = {
  fieldName: "rowId",
  attributeName: "id",
  attribute: spec_goal.attributes.id
};
const colSpec76 = {
  fieldName: "organizationId",
  attributeName: "organization_id",
  attribute: spec_goal.attributes.organization_id
};
const colSpec77 = {
  fieldName: "isActive",
  attributeName: "is_active",
  attribute: spec_goal.attributes.is_active
};
function assertAllowed110(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed111(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed112(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
const colSpec78 = {
  fieldName: "rowId",
  attributeName: "id",
  attribute: spec_post.attributes.id
};
const colSpec79 = {
  fieldName: "organizationId",
  attributeName: "organization_id",
  attribute: spec_post.attributes.organization_id
};
const colSpec80 = {
  fieldName: "authorId",
  attributeName: "author_id",
  attribute: spec_post.attributes.author_id
};
const colSpec81 = {
  fieldName: "visibility",
  attributeName: "visibility",
  attribute: spec_post.attributes.visibility
};
const colSpec82 = {
  fieldName: "isPublished",
  attributeName: "is_published",
  attribute: spec_post.attributes.is_published
};
const colSpec83 = {
  fieldName: "publishedAt",
  attributeName: "published_at",
  attribute: spec_post.attributes.published_at
};
function assertAllowed113(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed114(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
const resolve160 = (i, _v, input) => sql`${i} ${input ? sql`IS NULL` : sql`IS NOT NULL`}`;
const resolveInputCodec51 = () => TYPES.boolean;
const resolveSqlValue24 = () => sql.null;
const resolve161 = (i, v) => sql`${i} = ${v}`;
const forceTextTypesSensitive14 = [TYPES.citext, TYPES.char, TYPES.bpchar];
function resolveDomains14(c) {
  let current = c;
  while (current.domainOfCodec) current = current.domainOfCodec;
  return current;
}
function resolveInputCodec52(c) {
  if (c.arrayOfCodec) {
    if (forceTextTypesSensitive14.includes(resolveDomains14(c.arrayOfCodec))) return listOfCodec(TYPES.text, {
      extensions: {
        listItemNonNull: c.extensions?.listItemNonNull
      }
    });
    return c;
  } else {
    if (forceTextTypesSensitive14.includes(resolveDomains14(c))) return TYPES.text;
    return c;
  }
}
function resolveSqlIdentifier25(identifier, c) {
  if (c.arrayOfCodec && forceTextTypesSensitive14.includes(resolveDomains14(c.arrayOfCodec))) return [sql`(${identifier})::text[]`, listOfCodec(TYPES.text, {
    extensions: {
      listItemNonNull: c.extensions?.listItemNonNull
    }
  })];else if (forceTextTypesSensitive14.includes(resolveDomains14(c))) return [sql`(${identifier})::text`, TYPES.text];else return [identifier, c];
}
const resolve162 = (i, v) => sql`${i} <> ${v}`;
const resolve163 = (i, v) => sql`${i} IS DISTINCT FROM ${v}`;
const resolve164 = (i, v) => sql`${i} IS NOT DISTINCT FROM ${v}`;
const resolve165 = (i, v) => sql`${i} = ANY(${v})`;
function resolveInputCodec53(c) {
  if (forceTextTypesSensitive14.includes(resolveDomains14(c))) return listOfCodec(TYPES.text, {
    extensions: {
      listItemNonNull: !0
    }
  });else return listOfCodec(c, {
    extensions: {
      listItemNonNull: !0
    }
  });
}
const resolve166 = (i, v) => sql`${i} <> ALL(${v})`;
const resolve167 = (i, v) => sql`${i} < ${v}`;
const resolve168 = (i, v) => sql`${i} <= ${v}`;
const resolve169 = (i, v) => sql`${i} > ${v}`;
const resolve170 = (i, v) => sql`${i} >= ${v}`;
function assertAllowed115(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed116(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed117(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed118(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
const colSpec84 = {
  fieldName: "rowId",
  attributeName: "id",
  attribute: spec_userIdentity.attributes.id
};
const colSpec85 = {
  fieldName: "userId",
  attributeName: "user_id",
  attribute: spec_userIdentity.attributes.user_id
};
const colSpec86 = {
  fieldName: "provider",
  attributeName: "provider",
  attribute: spec_userIdentity.attributes.provider
};
const colSpec87 = {
  fieldName: "providerUserId",
  attributeName: "provider_user_id",
  attribute: spec_userIdentity.attributes.provider_user_id
};
function assertAllowed119(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed120(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
const resolve171 = (i, _v, input) => sql`${i} ${input ? sql`IS NULL` : sql`IS NOT NULL`}`;
const resolveInputCodec54 = () => TYPES.boolean;
const resolveSqlValue25 = () => sql.null;
const resolve172 = (i, v) => sql`${i} = ${v}`;
const forceTextTypesSensitive15 = [TYPES.citext, TYPES.char, TYPES.bpchar];
function resolveDomains15(c) {
  let current = c;
  while (current.domainOfCodec) current = current.domainOfCodec;
  return current;
}
function resolveInputCodec55(c) {
  if (c.arrayOfCodec) {
    if (forceTextTypesSensitive15.includes(resolveDomains15(c.arrayOfCodec))) return listOfCodec(TYPES.text, {
      extensions: {
        listItemNonNull: c.extensions?.listItemNonNull
      }
    });
    return c;
  } else {
    if (forceTextTypesSensitive15.includes(resolveDomains15(c))) return TYPES.text;
    return c;
  }
}
function resolveSqlIdentifier26(identifier, c) {
  if (c.arrayOfCodec && forceTextTypesSensitive15.includes(resolveDomains15(c.arrayOfCodec))) return [sql`(${identifier})::text[]`, listOfCodec(TYPES.text, {
    extensions: {
      listItemNonNull: c.extensions?.listItemNonNull
    }
  })];else if (forceTextTypesSensitive15.includes(resolveDomains15(c))) return [sql`(${identifier})::text`, TYPES.text];else return [identifier, c];
}
const resolve173 = (i, v) => sql`${i} <> ${v}`;
const resolve174 = (i, v) => sql`${i} IS DISTINCT FROM ${v}`;
const resolve175 = (i, v) => sql`${i} IS NOT DISTINCT FROM ${v}`;
const resolve176 = (i, v) => sql`${i} = ANY(${v})`;
function resolveInputCodec56(c) {
  if (forceTextTypesSensitive15.includes(resolveDomains15(c))) return listOfCodec(TYPES.text, {
    extensions: {
      listItemNonNull: !0
    }
  });else return listOfCodec(c, {
    extensions: {
      listItemNonNull: !0
    }
  });
}
const resolve177 = (i, v) => sql`${i} <> ALL(${v})`;
const resolve178 = (i, v) => sql`${i} < ${v}`;
const resolve179 = (i, v) => sql`${i} <= ${v}`;
const resolve180 = (i, v) => sql`${i} > ${v}`;
const resolve181 = (i, v) => sql`${i} >= ${v}`;
function assertAllowed121(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed122(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed123(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed124(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed125(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed126(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed127(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed128(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed129(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed130(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed131(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed132(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed133(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
const colSpec88 = {
  fieldName: "rowId",
  attributeName: "id",
  attribute: spec_workspace.attributes.id
};
const colSpec89 = {
  fieldName: "organizationId",
  attributeName: "organization_id",
  attribute: spec_workspace.attributes.organization_id
};
const colSpec90 = {
  fieldName: "slug",
  attributeName: "slug",
  attribute: spec_workspace.attributes.slug
};
function assertAllowed134(value, mode) {
  if (mode === "object" && !false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
}
const specFromArgs_UserOrganization = args => {
  const $nodeId = args.getRaw(["input", "id"]);
  return specFromNodeId(nodeIdHandler_UserOrganization, $nodeId);
};
const specFromArgs_BountyFunding = args => {
  const $nodeId = args.getRaw(["input", "id"]);
  return specFromNodeId(nodeIdHandler_BountyFunding, $nodeId);
};
const specFromArgs_User = args => {
  const $nodeId = args.getRaw(["input", "id"]);
  return specFromNodeId(nodeIdHandler_User, $nodeId);
};
const specFromArgs_WebhookEndpoint = args => {
  const $nodeId = args.getRaw(["input", "id"]);
  return specFromNodeId(nodeIdHandler_WebhookEndpoint, $nodeId);
};
const specFromArgs_Workspace = args => {
  const $nodeId = args.getRaw(["input", "id"]);
  return specFromNodeId(nodeIdHandler_Workspace, $nodeId);
};
const specFromArgs_Donation = args => {
  const $nodeId = args.getRaw(["input", "id"]);
  return specFromNodeId(nodeIdHandler_Donation, $nodeId);
};
const specFromArgs_Goal = args => {
  const $nodeId = args.getRaw(["input", "id"]);
  return specFromNodeId(nodeIdHandler_Goal, $nodeId);
};
const specFromArgs_UserIdentity = args => {
  const $nodeId = args.getRaw(["input", "id"]);
  return specFromNodeId(nodeIdHandler_UserIdentity, $nodeId);
};
const specFromArgs_WebhookDelivery = args => {
  const $nodeId = args.getRaw(["input", "id"]);
  return specFromNodeId(nodeIdHandler_WebhookDelivery, $nodeId);
};
const specFromArgs_SponsorshipTier = args => {
  const $nodeId = args.getRaw(["input", "id"]);
  return specFromNodeId(nodeIdHandler_SponsorshipTier, $nodeId);
};
const specFromArgs_PaymentProcessorConnection = args => {
  const $nodeId = args.getRaw(["input", "id"]);
  return specFromNodeId(nodeIdHandler_PaymentProcessorConnection, $nodeId);
};
const specFromArgs_AuditLog = args => {
  const $nodeId = args.getRaw(["input", "id"]);
  return specFromNodeId(nodeIdHandler_AuditLog, $nodeId);
};
const specFromArgs_Post = args => {
  const $nodeId = args.getRaw(["input", "id"]);
  return specFromNodeId(nodeIdHandler_Post, $nodeId);
};
const specFromArgs_GrantProgram = args => {
  const $nodeId = args.getRaw(["input", "id"]);
  return specFromNodeId(nodeIdHandler_GrantProgram, $nodeId);
};
const specFromArgs_Organization = args => {
  const $nodeId = args.getRaw(["input", "id"]);
  return specFromNodeId(nodeIdHandler_Organization, $nodeId);
};
const specFromArgs_GrantApplication = args => {
  const $nodeId = args.getRaw(["input", "id"]);
  return specFromNodeId(nodeIdHandler_GrantApplication, $nodeId);
};
const specFromArgs_Payout = args => {
  const $nodeId = args.getRaw(["input", "id"]);
  return specFromNodeId(nodeIdHandler_Payout, $nodeId);
};
const specFromArgs_GrantMilestone = args => {
  const $nodeId = args.getRaw(["input", "id"]);
  return specFromNodeId(nodeIdHandler_GrantMilestone, $nodeId);
};
const specFromArgs_Bounty = args => {
  const $nodeId = args.getRaw(["input", "id"]);
  return specFromNodeId(nodeIdHandler_Bounty, $nodeId);
};
const specFromArgs_Transaction = args => {
  const $nodeId = args.getRaw(["input", "id"]);
  return specFromNodeId(nodeIdHandler_Transaction, $nodeId);
};
const specFromArgs_Sponsorship = args => {
  const $nodeId = args.getRaw(["input", "id"]);
  return specFromNodeId(nodeIdHandler_Sponsorship, $nodeId);
};
const specFromArgs_UserOrganization2 = args => {
  const $nodeId = args.getRaw(["input", "id"]);
  return specFromNodeId(nodeIdHandler_UserOrganization, $nodeId);
};
const specFromArgs_BountyFunding2 = args => {
  const $nodeId = args.getRaw(["input", "id"]);
  return specFromNodeId(nodeIdHandler_BountyFunding, $nodeId);
};
const specFromArgs_User2 = args => {
  const $nodeId = args.getRaw(["input", "id"]);
  return specFromNodeId(nodeIdHandler_User, $nodeId);
};
const specFromArgs_WebhookEndpoint2 = args => {
  const $nodeId = args.getRaw(["input", "id"]);
  return specFromNodeId(nodeIdHandler_WebhookEndpoint, $nodeId);
};
const specFromArgs_Workspace2 = args => {
  const $nodeId = args.getRaw(["input", "id"]);
  return specFromNodeId(nodeIdHandler_Workspace, $nodeId);
};
const specFromArgs_Donation2 = args => {
  const $nodeId = args.getRaw(["input", "id"]);
  return specFromNodeId(nodeIdHandler_Donation, $nodeId);
};
const specFromArgs_Goal2 = args => {
  const $nodeId = args.getRaw(["input", "id"]);
  return specFromNodeId(nodeIdHandler_Goal, $nodeId);
};
const specFromArgs_UserIdentity2 = args => {
  const $nodeId = args.getRaw(["input", "id"]);
  return specFromNodeId(nodeIdHandler_UserIdentity, $nodeId);
};
const specFromArgs_WebhookDelivery2 = args => {
  const $nodeId = args.getRaw(["input", "id"]);
  return specFromNodeId(nodeIdHandler_WebhookDelivery, $nodeId);
};
const specFromArgs_SponsorshipTier2 = args => {
  const $nodeId = args.getRaw(["input", "id"]);
  return specFromNodeId(nodeIdHandler_SponsorshipTier, $nodeId);
};
const specFromArgs_PaymentProcessorConnection2 = args => {
  const $nodeId = args.getRaw(["input", "id"]);
  return specFromNodeId(nodeIdHandler_PaymentProcessorConnection, $nodeId);
};
const specFromArgs_AuditLog2 = args => {
  const $nodeId = args.getRaw(["input", "id"]);
  return specFromNodeId(nodeIdHandler_AuditLog, $nodeId);
};
const specFromArgs_Post2 = args => {
  const $nodeId = args.getRaw(["input", "id"]);
  return specFromNodeId(nodeIdHandler_Post, $nodeId);
};
const specFromArgs_GrantProgram2 = args => {
  const $nodeId = args.getRaw(["input", "id"]);
  return specFromNodeId(nodeIdHandler_GrantProgram, $nodeId);
};
const specFromArgs_Organization2 = args => {
  const $nodeId = args.getRaw(["input", "id"]);
  return specFromNodeId(nodeIdHandler_Organization, $nodeId);
};
const specFromArgs_GrantApplication2 = args => {
  const $nodeId = args.getRaw(["input", "id"]);
  return specFromNodeId(nodeIdHandler_GrantApplication, $nodeId);
};
const specFromArgs_Payout2 = args => {
  const $nodeId = args.getRaw(["input", "id"]);
  return specFromNodeId(nodeIdHandler_Payout, $nodeId);
};
const specFromArgs_GrantMilestone2 = args => {
  const $nodeId = args.getRaw(["input", "id"]);
  return specFromNodeId(nodeIdHandler_GrantMilestone, $nodeId);
};
const specFromArgs_Bounty2 = args => {
  const $nodeId = args.getRaw(["input", "id"]);
  return specFromNodeId(nodeIdHandler_Bounty, $nodeId);
};
const specFromArgs_Transaction2 = args => {
  const $nodeId = args.getRaw(["input", "id"]);
  return specFromNodeId(nodeIdHandler_Transaction, $nodeId);
};
const specFromArgs_Sponsorship2 = args => {
  const $nodeId = args.getRaw(["input", "id"]);
  return specFromNodeId(nodeIdHandler_Sponsorship, $nodeId);
};
const getPgSelectSingleFromMutationResult = (resource, pkAttributes, $mutation) => {
  const $result = $mutation.getStepForKey("result", !0);
  if (!$result) return null;
  if ($result instanceof PgDeleteSingleStep) return pgSelectFromRecord($result.resource, $result.record());else {
    const spec = pkAttributes.reduce((memo, attributeName) => {
      memo[attributeName] = $result.get(attributeName);
      return memo;
    }, Object.create(null));
    return resource.find(spec);
  }
};
const pgMutationPayloadEdge = (resource, pkAttributes, $mutation, fieldArgs) => {
  const $select = getPgSelectSingleFromMutationResult(resource, pkAttributes, $mutation);
  if (!$select) return constant(null);
  fieldArgs.apply($select, "orderBy");
  const $connection = connection($select);
  return new EdgeStep($connection, first($connection));
};
export const typeDefs = /* GraphQL */`"""The root query type which gives access points into the data universe."""
type Query implements Node {
  """
  Exposes the root query type nested one level down. This is helpful for Relay 1
  which can only query top level fields if they are in a particular form.
  """
  query: Query!

  """
  The root query type must be a \`Node\` to work well with Relay 1 mutations. This just resolves to \`query\`.
  """
  id: ID!

  """Fetches an object given its globally unique \`ID\`."""
  node(
    """The globally unique \`ID\`."""
    id: ID!
  ): Node

  """Get a single \`UserOrganization\`."""
  userOrganization(rowId: UUID!): UserOrganization

  """Get a single \`BountyFunding\`."""
  bountyFunding(rowId: UUID!): BountyFunding

  """Get a single \`User\`."""
  user(rowId: UUID!): User

  """Get a single \`User\`."""
  userByUsername(username: String!): User

  """Get a single \`WebhookEndpoint\`."""
  webhookEndpoint(rowId: UUID!): WebhookEndpoint

  """Get a single \`Workspace\`."""
  workspace(rowId: UUID!): Workspace

  """Get a single \`Donation\`."""
  donation(rowId: UUID!): Donation

  """Get a single \`Goal\`."""
  goal(rowId: UUID!): Goal

  """Get a single \`UserIdentity\`."""
  userIdentity(rowId: UUID!): UserIdentity

  """Get a single \`WebhookDelivery\`."""
  webhookDelivery(rowId: UUID!): WebhookDelivery

  """Get a single \`SponsorshipTier\`."""
  sponsorshipTier(rowId: UUID!): SponsorshipTier

  """Get a single \`PaymentProcessorConnection\`."""
  paymentProcessorConnection(rowId: UUID!): PaymentProcessorConnection

  """Get a single \`AuditLog\`."""
  auditLog(rowId: UUID!): AuditLog

  """Get a single \`Post\`."""
  post(rowId: UUID!): Post

  """Get a single \`GrantProgram\`."""
  grantProgram(rowId: UUID!): GrantProgram

  """Get a single \`Organization\`."""
  organization(rowId: UUID!): Organization

  """Get a single \`Organization\`."""
  organizationBySlug(slug: String!): Organization

  """Get a single \`GrantApplication\`."""
  grantApplication(rowId: UUID!): GrantApplication

  """Get a single \`Payout\`."""
  payout(rowId: UUID!): Payout

  """Get a single \`GrantMilestone\`."""
  grantMilestone(rowId: UUID!): GrantMilestone

  """Get a single \`Bounty\`."""
  bounty(rowId: UUID!): Bounty

  """Get a single \`Transaction\`."""
  transaction(rowId: UUID!): Transaction

  """Get a single \`Sponsorship\`."""
  sponsorship(rowId: UUID!): Sponsorship

  """Reads a single \`UserOrganization\` using its globally unique \`ID\`."""
  userOrganizationById(
    """
    The globally unique \`ID\` to be used in selecting a single \`UserOrganization\`.
    """
    id: ID!
  ): UserOrganization

  """Reads a single \`BountyFunding\` using its globally unique \`ID\`."""
  bountyFundingById(
    """
    The globally unique \`ID\` to be used in selecting a single \`BountyFunding\`.
    """
    id: ID!
  ): BountyFunding

  """Reads a single \`User\` using its globally unique \`ID\`."""
  userById(
    """The globally unique \`ID\` to be used in selecting a single \`User\`."""
    id: ID!
  ): User

  """Reads a single \`WebhookEndpoint\` using its globally unique \`ID\`."""
  webhookEndpointById(
    """
    The globally unique \`ID\` to be used in selecting a single \`WebhookEndpoint\`.
    """
    id: ID!
  ): WebhookEndpoint

  """Reads a single \`Workspace\` using its globally unique \`ID\`."""
  workspaceById(
    """The globally unique \`ID\` to be used in selecting a single \`Workspace\`."""
    id: ID!
  ): Workspace

  """Reads a single \`Donation\` using its globally unique \`ID\`."""
  donationById(
    """The globally unique \`ID\` to be used in selecting a single \`Donation\`."""
    id: ID!
  ): Donation

  """Reads a single \`Goal\` using its globally unique \`ID\`."""
  goalById(
    """The globally unique \`ID\` to be used in selecting a single \`Goal\`."""
    id: ID!
  ): Goal

  """Reads a single \`UserIdentity\` using its globally unique \`ID\`."""
  userIdentityById(
    """
    The globally unique \`ID\` to be used in selecting a single \`UserIdentity\`.
    """
    id: ID!
  ): UserIdentity

  """Reads a single \`WebhookDelivery\` using its globally unique \`ID\`."""
  webhookDeliveryById(
    """
    The globally unique \`ID\` to be used in selecting a single \`WebhookDelivery\`.
    """
    id: ID!
  ): WebhookDelivery

  """Reads a single \`SponsorshipTier\` using its globally unique \`ID\`."""
  sponsorshipTierById(
    """
    The globally unique \`ID\` to be used in selecting a single \`SponsorshipTier\`.
    """
    id: ID!
  ): SponsorshipTier

  """
  Reads a single \`PaymentProcessorConnection\` using its globally unique \`ID\`.
  """
  paymentProcessorConnectionById(
    """
    The globally unique \`ID\` to be used in selecting a single \`PaymentProcessorConnection\`.
    """
    id: ID!
  ): PaymentProcessorConnection

  """Reads a single \`AuditLog\` using its globally unique \`ID\`."""
  auditLogById(
    """The globally unique \`ID\` to be used in selecting a single \`AuditLog\`."""
    id: ID!
  ): AuditLog

  """Reads a single \`Post\` using its globally unique \`ID\`."""
  postById(
    """The globally unique \`ID\` to be used in selecting a single \`Post\`."""
    id: ID!
  ): Post

  """Reads a single \`GrantProgram\` using its globally unique \`ID\`."""
  grantProgramById(
    """
    The globally unique \`ID\` to be used in selecting a single \`GrantProgram\`.
    """
    id: ID!
  ): GrantProgram

  """Reads a single \`Organization\` using its globally unique \`ID\`."""
  organizationById(
    """
    The globally unique \`ID\` to be used in selecting a single \`Organization\`.
    """
    id: ID!
  ): Organization

  """Reads a single \`GrantApplication\` using its globally unique \`ID\`."""
  grantApplicationById(
    """
    The globally unique \`ID\` to be used in selecting a single \`GrantApplication\`.
    """
    id: ID!
  ): GrantApplication

  """Reads a single \`Payout\` using its globally unique \`ID\`."""
  payoutById(
    """The globally unique \`ID\` to be used in selecting a single \`Payout\`."""
    id: ID!
  ): Payout

  """Reads a single \`GrantMilestone\` using its globally unique \`ID\`."""
  grantMilestoneById(
    """
    The globally unique \`ID\` to be used in selecting a single \`GrantMilestone\`.
    """
    id: ID!
  ): GrantMilestone

  """Reads a single \`Bounty\` using its globally unique \`ID\`."""
  bountyById(
    """The globally unique \`ID\` to be used in selecting a single \`Bounty\`."""
    id: ID!
  ): Bounty

  """Reads a single \`Transaction\` using its globally unique \`ID\`."""
  transactionById(
    """
    The globally unique \`ID\` to be used in selecting a single \`Transaction\`.
    """
    id: ID!
  ): Transaction

  """Reads a single \`Sponsorship\` using its globally unique \`ID\`."""
  sponsorshipById(
    """
    The globally unique \`ID\` to be used in selecting a single \`Sponsorship\`.
    """
    id: ID!
  ): Sponsorship

  """Reads and enables pagination through a set of \`UserOrganization\`."""
  userOrganizations(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserOrganizationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserOrganizationFilter

    """The method to use when ordering \`UserOrganization\`."""
    orderBy: [UserOrganizationOrderBy!] = [PRIMARY_KEY_ASC]
  ): UserOrganizationConnection

  """Reads and enables pagination through a set of \`BountyFunding\`."""
  bountyFundings(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BountyFundingCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: BountyFundingFilter

    """The method to use when ordering \`BountyFunding\`."""
    orderBy: [BountyFundingOrderBy!] = [PRIMARY_KEY_ASC]
  ): BountyFundingConnection

  """Reads and enables pagination through a set of \`User\`."""
  users(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserFilter

    """The method to use when ordering \`User\`."""
    orderBy: [UserOrderBy!] = [PRIMARY_KEY_ASC]
  ): UserConnection

  """Reads and enables pagination through a set of \`WebhookEndpoint\`."""
  webhookEndpoints(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: WebhookEndpointCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: WebhookEndpointFilter

    """The method to use when ordering \`WebhookEndpoint\`."""
    orderBy: [WebhookEndpointOrderBy!] = [PRIMARY_KEY_ASC]
  ): WebhookEndpointConnection

  """Reads and enables pagination through a set of \`Workspace\`."""
  workspaces(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: WorkspaceCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: WorkspaceFilter

    """The method to use when ordering \`Workspace\`."""
    orderBy: [WorkspaceOrderBy!] = [PRIMARY_KEY_ASC]
  ): WorkspaceConnection

  """Reads and enables pagination through a set of \`Donation\`."""
  donations(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DonationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: DonationFilter

    """The method to use when ordering \`Donation\`."""
    orderBy: [DonationOrderBy!] = [PRIMARY_KEY_ASC]
  ): DonationConnection

  """Reads and enables pagination through a set of \`Goal\`."""
  goals(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: GoalCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: GoalFilter

    """The method to use when ordering \`Goal\`."""
    orderBy: [GoalOrderBy!] = [PRIMARY_KEY_ASC]
  ): GoalConnection

  """Reads and enables pagination through a set of \`UserIdentity\`."""
  userIdentities(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserIdentityCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserIdentityFilter

    """The method to use when ordering \`UserIdentity\`."""
    orderBy: [UserIdentityOrderBy!] = [PRIMARY_KEY_ASC]
  ): UserIdentityConnection

  """Reads and enables pagination through a set of \`WebhookDelivery\`."""
  webhookDeliveries(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: WebhookDeliveryCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: WebhookDeliveryFilter

    """The method to use when ordering \`WebhookDelivery\`."""
    orderBy: [WebhookDeliveryOrderBy!] = [PRIMARY_KEY_ASC]
  ): WebhookDeliveryConnection

  """Reads and enables pagination through a set of \`SponsorshipTier\`."""
  sponsorshipTiers(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SponsorshipTierCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: SponsorshipTierFilter

    """The method to use when ordering \`SponsorshipTier\`."""
    orderBy: [SponsorshipTierOrderBy!] = [PRIMARY_KEY_ASC]
  ): SponsorshipTierConnection

  """
  Reads and enables pagination through a set of \`PaymentProcessorConnection\`.
  """
  paymentProcessorConnections(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PaymentProcessorConnectionCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PaymentProcessorConnectionFilter

    """The method to use when ordering \`PaymentProcessorConnection\`."""
    orderBy: [PaymentProcessorConnectionOrderBy!] = [PRIMARY_KEY_ASC]
  ): PaymentProcessorConnectionConnection

  """Reads and enables pagination through a set of \`AuditLog\`."""
  auditLogs(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AuditLogCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AuditLogFilter

    """The method to use when ordering \`AuditLog\`."""
    orderBy: [AuditLogOrderBy!] = [PRIMARY_KEY_ASC]
  ): AuditLogConnection

  """Reads and enables pagination through a set of \`Post\`."""
  posts(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PostCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PostFilter

    """The method to use when ordering \`Post\`."""
    orderBy: [PostOrderBy!] = [PRIMARY_KEY_ASC]
  ): PostConnection

  """Reads and enables pagination through a set of \`GrantProgram\`."""
  grantPrograms(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: GrantProgramCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: GrantProgramFilter

    """The method to use when ordering \`GrantProgram\`."""
    orderBy: [GrantProgramOrderBy!] = [PRIMARY_KEY_ASC]
  ): GrantProgramConnection

  """Reads and enables pagination through a set of \`Organization\`."""
  organizations(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: OrganizationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: OrganizationFilter

    """The method to use when ordering \`Organization\`."""
    orderBy: [OrganizationOrderBy!] = [PRIMARY_KEY_ASC]
  ): OrganizationConnection

  """Reads and enables pagination through a set of \`GrantApplication\`."""
  grantApplications(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: GrantApplicationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: GrantApplicationFilter

    """The method to use when ordering \`GrantApplication\`."""
    orderBy: [GrantApplicationOrderBy!] = [PRIMARY_KEY_ASC]
  ): GrantApplicationConnection

  """Reads and enables pagination through a set of \`Payout\`."""
  payouts(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PayoutCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PayoutFilter

    """The method to use when ordering \`Payout\`."""
    orderBy: [PayoutOrderBy!] = [PRIMARY_KEY_ASC]
  ): PayoutConnection

  """Reads and enables pagination through a set of \`GrantMilestone\`."""
  grantMilestones(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: GrantMilestoneCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: GrantMilestoneFilter

    """The method to use when ordering \`GrantMilestone\`."""
    orderBy: [GrantMilestoneOrderBy!] = [PRIMARY_KEY_ASC]
  ): GrantMilestoneConnection

  """Reads and enables pagination through a set of \`Bounty\`."""
  bounties(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BountyCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: BountyFilter

    """The method to use when ordering \`Bounty\`."""
    orderBy: [BountyOrderBy!] = [PRIMARY_KEY_ASC]
  ): BountyConnection

  """Reads and enables pagination through a set of \`Transaction\`."""
  transactions(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TransactionCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TransactionFilter

    """The method to use when ordering \`Transaction\`."""
    orderBy: [TransactionOrderBy!] = [PRIMARY_KEY_ASC]
  ): TransactionConnection

  """Reads and enables pagination through a set of \`Sponsorship\`."""
  sponsorships(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SponsorshipCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: SponsorshipFilter

    """The method to use when ordering \`Sponsorship\`."""
    orderBy: [SponsorshipOrderBy!] = [PRIMARY_KEY_ASC]
  ): SponsorshipConnection
}

"""An object with a globally unique \`ID\`."""
interface Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
}

type UserOrganization implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
  rowId: UUID!
  userId: UUID!
  organizationId: UUID!
  role: OrganizationRole!
  createdAt: Datetime
  updatedAt: Datetime

  """
  Reads a single \`Organization\` that is related to this \`UserOrganization\`.
  """
  organization: Organization

  """Reads a single \`User\` that is related to this \`UserOrganization\`."""
  user: User
}

"""
A universally unique identifier as defined by [RFC 4122](https://tools.ietf.org/html/rfc4122).
"""
scalar UUID

enum OrganizationRole {
  owner
  admin
  member
}

"""
A point in time as described by the [ISO
8601](https://en.wikipedia.org/wiki/ISO_8601) and, if it has a timezone, [RFC
3339](https://datatracker.ietf.org/doc/html/rfc3339) standards. Input values
that do not conform to both ISO 8601 and RFC 3339 may be coerced, which may lead
to unexpected results.
"""
scalar Datetime

type Organization implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
  rowId: UUID!
  name: String!
  slug: String!
  description: String
  avatarUrl: String
  websiteUrl: String
  organizationType: OrganizationType!
  platformFeePercent: BigFloat!
  isVerified: Boolean!
  verifiedAt: Datetime
  createdAt: Datetime
  updatedAt: Datetime
  deletedAt: Datetime

  """Reads and enables pagination through a set of \`AuditLog\`."""
  auditLogs(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AuditLogCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AuditLogFilter

    """The method to use when ordering \`AuditLog\`."""
    orderBy: [AuditLogOrderBy!] = [PRIMARY_KEY_ASC]
  ): AuditLogConnection!

  """Reads and enables pagination through a set of \`Bounty\`."""
  bounties(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BountyCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: BountyFilter

    """The method to use when ordering \`Bounty\`."""
    orderBy: [BountyOrderBy!] = [PRIMARY_KEY_ASC]
  ): BountyConnection!

  """Reads and enables pagination through a set of \`Donation\`."""
  donations(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DonationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: DonationFilter

    """The method to use when ordering \`Donation\`."""
    orderBy: [DonationOrderBy!] = [PRIMARY_KEY_ASC]
  ): DonationConnection!

  """Reads and enables pagination through a set of \`GrantProgram\`."""
  grantPrograms(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: GrantProgramCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: GrantProgramFilter

    """The method to use when ordering \`GrantProgram\`."""
    orderBy: [GrantProgramOrderBy!] = [PRIMARY_KEY_ASC]
  ): GrantProgramConnection!

  """Reads and enables pagination through a set of \`UserOrganization\`."""
  userOrganizations(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserOrganizationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserOrganizationFilter

    """The method to use when ordering \`UserOrganization\`."""
    orderBy: [UserOrganizationOrderBy!] = [PRIMARY_KEY_ASC]
  ): UserOrganizationConnection!

  """Reads and enables pagination through a set of \`SponsorshipTier\`."""
  sponsorshipTiers(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SponsorshipTierCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: SponsorshipTierFilter

    """The method to use when ordering \`SponsorshipTier\`."""
    orderBy: [SponsorshipTierOrderBy!] = [PRIMARY_KEY_ASC]
  ): SponsorshipTierConnection!

  """Reads and enables pagination through a set of \`Sponsorship\`."""
  sponsorships(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SponsorshipCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: SponsorshipFilter

    """The method to use when ordering \`Sponsorship\`."""
    orderBy: [SponsorshipOrderBy!] = [PRIMARY_KEY_ASC]
  ): SponsorshipConnection!

  """
  Reads and enables pagination through a set of \`PaymentProcessorConnection\`.
  """
  paymentProcessorConnections(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PaymentProcessorConnectionCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PaymentProcessorConnectionFilter

    """The method to use when ordering \`PaymentProcessorConnection\`."""
    orderBy: [PaymentProcessorConnectionOrderBy!] = [PRIMARY_KEY_ASC]
  ): PaymentProcessorConnectionConnection!

  """Reads and enables pagination through a set of \`Transaction\`."""
  transactionsByToOrganizationId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TransactionCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TransactionFilter

    """The method to use when ordering \`Transaction\`."""
    orderBy: [TransactionOrderBy!] = [PRIMARY_KEY_ASC]
  ): TransactionConnection!

  """Reads and enables pagination through a set of \`Payout\`."""
  payoutsByFromOrganizationId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PayoutCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PayoutFilter

    """The method to use when ordering \`Payout\`."""
    orderBy: [PayoutOrderBy!] = [PRIMARY_KEY_ASC]
  ): PayoutConnection!

  """Reads and enables pagination through a set of \`WebhookEndpoint\`."""
  webhookEndpoints(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: WebhookEndpointCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: WebhookEndpointFilter

    """The method to use when ordering \`WebhookEndpoint\`."""
    orderBy: [WebhookEndpointOrderBy!] = [PRIMARY_KEY_ASC]
  ): WebhookEndpointConnection!

  """Reads and enables pagination through a set of \`Goal\`."""
  goals(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: GoalCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: GoalFilter

    """The method to use when ordering \`Goal\`."""
    orderBy: [GoalOrderBy!] = [PRIMARY_KEY_ASC]
  ): GoalConnection!

  """Reads and enables pagination through a set of \`Post\`."""
  posts(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PostCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PostFilter

    """The method to use when ordering \`Post\`."""
    orderBy: [PostOrderBy!] = [PRIMARY_KEY_ASC]
  ): PostConnection!
}

enum OrganizationType {
  foss_project
  nonprofit
  commercial
}

"""
A floating point number that requires more precision than IEEE 754 binary 64
"""
scalar BigFloat

"""A connection to a list of \`AuditLog\` values."""
type AuditLogConnection {
  """A list of \`AuditLog\` objects."""
  nodes: [AuditLog]!

  """
  A list of edges which contains the \`AuditLog\` and cursor to aid in pagination.
  """
  edges: [AuditLogEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`AuditLog\` you could get from the connection."""
  totalCount: Int!
}

type AuditLog implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
  rowId: UUID!
  actorUserId: UUID
  actorIpAddress: String
  actorUserAgent: String
  organizationId: UUID
  targetEntityType: String!
  targetEntityId: UUID!
  action: AuditAction!
  previousState: String
  newState: String
  metadata: String
  createdAt: Datetime

  """Reads a single \`User\` that is related to this \`AuditLog\`."""
  actorUser: User

  """Reads a single \`Organization\` that is related to this \`AuditLog\`."""
  organization: Organization
}

enum AuditAction {
  create
  update
  delete
  status_change
  payment_initiated
  payment_completed
  payment_failed
  refund_initiated
  refund_completed
}

type User implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
  rowId: UUID!
  createdAt: Datetime
  updatedAt: Datetime
  displayName: String
  username: String
  avatarUrl: String
  bio: String
  websiteUrl: String
  deletedAt: Datetime

  """Reads and enables pagination through a set of \`AuditLog\`."""
  auditLogsByActorUserId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AuditLogCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AuditLogFilter

    """The method to use when ordering \`AuditLog\`."""
    orderBy: [AuditLogOrderBy!] = [PRIMARY_KEY_ASC]
  ): AuditLogConnection!

  """Reads and enables pagination through a set of \`Bounty\`."""
  bountiesByClaimantId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BountyCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: BountyFilter

    """The method to use when ordering \`Bounty\`."""
    orderBy: [BountyOrderBy!] = [PRIMARY_KEY_ASC]
  ): BountyConnection!

  """Reads and enables pagination through a set of \`BountyFunding\`."""
  bountyFundingsByFunderId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BountyFundingCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: BountyFundingFilter

    """The method to use when ordering \`BountyFunding\`."""
    orderBy: [BountyFundingOrderBy!] = [PRIMARY_KEY_ASC]
  ): BountyFundingConnection!

  """Reads and enables pagination through a set of \`Donation\`."""
  donationsByDonorId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DonationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: DonationFilter

    """The method to use when ordering \`Donation\`."""
    orderBy: [DonationOrderBy!] = [PRIMARY_KEY_ASC]
  ): DonationConnection!

  """Reads and enables pagination through a set of \`GrantApplication\`."""
  grantApplicationsByApplicantId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: GrantApplicationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: GrantApplicationFilter

    """The method to use when ordering \`GrantApplication\`."""
    orderBy: [GrantApplicationOrderBy!] = [PRIMARY_KEY_ASC]
  ): GrantApplicationConnection!

  """Reads and enables pagination through a set of \`UserIdentity\`."""
  userIdentities(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserIdentityCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserIdentityFilter

    """The method to use when ordering \`UserIdentity\`."""
    orderBy: [UserIdentityOrderBy!] = [PRIMARY_KEY_ASC]
  ): UserIdentityConnection!

  """Reads and enables pagination through a set of \`UserOrganization\`."""
  userOrganizations(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserOrganizationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserOrganizationFilter

    """The method to use when ordering \`UserOrganization\`."""
    orderBy: [UserOrganizationOrderBy!] = [PRIMARY_KEY_ASC]
  ): UserOrganizationConnection!

  """Reads and enables pagination through a set of \`Sponsorship\`."""
  sponsorshipsBySponsorId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SponsorshipCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: SponsorshipFilter

    """The method to use when ordering \`Sponsorship\`."""
    orderBy: [SponsorshipOrderBy!] = [PRIMARY_KEY_ASC]
  ): SponsorshipConnection!

  """Reads and enables pagination through a set of \`Transaction\`."""
  transactionsByFromUserId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TransactionCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TransactionFilter

    """The method to use when ordering \`Transaction\`."""
    orderBy: [TransactionOrderBy!] = [PRIMARY_KEY_ASC]
  ): TransactionConnection!

  """Reads and enables pagination through a set of \`Transaction\`."""
  transactionsByToUserId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TransactionCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TransactionFilter

    """The method to use when ordering \`Transaction\`."""
    orderBy: [TransactionOrderBy!] = [PRIMARY_KEY_ASC]
  ): TransactionConnection!

  """Reads and enables pagination through a set of \`Payout\`."""
  payoutsByRecipientUserId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PayoutCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PayoutFilter

    """The method to use when ordering \`Payout\`."""
    orderBy: [PayoutOrderBy!] = [PRIMARY_KEY_ASC]
  ): PayoutConnection!

  """Reads and enables pagination through a set of \`Post\`."""
  authoredPosts(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PostCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PostFilter

    """The method to use when ordering \`Post\`."""
    orderBy: [PostOrderBy!] = [PRIMARY_KEY_ASC]
  ): PostConnection!
}

"""A location in a connection that can be used for resuming pagination."""
scalar Cursor

"""
A condition to be used against \`AuditLog\` object types. All fields are tested
for equality and combined with a logical and.
"""
input AuditLogCondition {
  """Checks for equality with the objects \`rowId\` field."""
  rowId: UUID

  """Checks for equality with the objects \`actorUserId\` field."""
  actorUserId: UUID

  """Checks for equality with the objects \`organizationId\` field."""
  organizationId: UUID

  """Checks for equality with the objects \`targetEntityType\` field."""
  targetEntityType: String

  """Checks for equality with the objects \`targetEntityId\` field."""
  targetEntityId: UUID

  """Checks for equality with the objects \`action\` field."""
  action: AuditAction

  """Checks for equality with the objects \`createdAt\` field."""
  createdAt: Datetime
}

"""
A filter to be used against \`AuditLog\` object types. All fields are combined with a logical and.
"""
input AuditLogFilter {
  """Filter by the objects \`rowId\` field."""
  rowId: UUIDFilter

  """Filter by the objects \`actorUserId\` field."""
  actorUserId: UUIDFilter

  """Filter by the objects \`organizationId\` field."""
  organizationId: UUIDFilter

  """Filter by the objects \`targetEntityType\` field."""
  targetEntityType: StringFilter

  """Filter by the objects \`targetEntityId\` field."""
  targetEntityId: UUIDFilter

  """Filter by the objects \`action\` field."""
  action: AuditActionFilter

  """Filter by the objects \`createdAt\` field."""
  createdAt: DatetimeFilter

  """Filter by the objects \`actorUser\` relation."""
  actorUser: UserFilter

  """A related \`actorUser\` exists."""
  actorUserExists: Boolean

  """Filter by the objects \`organization\` relation."""
  organization: OrganizationFilter

  """A related \`organization\` exists."""
  organizationExists: Boolean

  """Checks for all expressions in this list."""
  and: [AuditLogFilter!]

  """Checks for any expressions in this list."""
  or: [AuditLogFilter!]

  """Negates the expression."""
  not: AuditLogFilter
}

"""
A filter to be used against UUID fields. All fields are combined with a logical and.
"""
input UUIDFilter {
  """
  Is null (if \`true\` is specified) or is not null (if \`false\` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: UUID

  """Not equal to the specified value."""
  notEqualTo: UUID

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: UUID

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: UUID

  """Included in the specified list."""
  in: [UUID!]

  """Not included in the specified list."""
  notIn: [UUID!]

  """Less than the specified value."""
  lessThan: UUID

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: UUID

  """Greater than the specified value."""
  greaterThan: UUID

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: UUID
}

"""
A filter to be used against String fields. All fields are combined with a logical and.
"""
input StringFilter {
  """
  Is null (if \`true\` is specified) or is not null (if \`false\` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: String

  """Not equal to the specified value."""
  notEqualTo: String

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: String

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: String

  """Included in the specified list."""
  in: [String!]

  """Not included in the specified list."""
  notIn: [String!]

  """Less than the specified value."""
  lessThan: String

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: String

  """Greater than the specified value."""
  greaterThan: String

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: String

  """Contains the specified string (case-sensitive)."""
  includes: String

  """Does not contain the specified string (case-sensitive)."""
  notIncludes: String

  """Contains the specified string (case-insensitive)."""
  includesInsensitive: String

  """Does not contain the specified string (case-insensitive)."""
  notIncludesInsensitive: String

  """Starts with the specified string (case-sensitive)."""
  startsWith: String

  """Does not start with the specified string (case-sensitive)."""
  notStartsWith: String

  """Starts with the specified string (case-insensitive)."""
  startsWithInsensitive: String

  """Does not start with the specified string (case-insensitive)."""
  notStartsWithInsensitive: String

  """Ends with the specified string (case-sensitive)."""
  endsWith: String

  """Does not end with the specified string (case-sensitive)."""
  notEndsWith: String

  """Ends with the specified string (case-insensitive)."""
  endsWithInsensitive: String

  """Does not end with the specified string (case-insensitive)."""
  notEndsWithInsensitive: String

  """
  Matches the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  like: String

  """
  Does not match the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  notLike: String

  """
  Matches the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  likeInsensitive: String

  """
  Does not match the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  notLikeInsensitive: String

  """Equal to the specified value (case-insensitive)."""
  equalToInsensitive: String

  """Not equal to the specified value (case-insensitive)."""
  notEqualToInsensitive: String

  """
  Not equal to the specified value, treating null like an ordinary value (case-insensitive).
  """
  distinctFromInsensitive: String

  """
  Equal to the specified value, treating null like an ordinary value (case-insensitive).
  """
  notDistinctFromInsensitive: String

  """Included in the specified list (case-insensitive)."""
  inInsensitive: [String!]

  """Not included in the specified list (case-insensitive)."""
  notInInsensitive: [String!]

  """Less than the specified value (case-insensitive)."""
  lessThanInsensitive: String

  """Less than or equal to the specified value (case-insensitive)."""
  lessThanOrEqualToInsensitive: String

  """Greater than the specified value (case-insensitive)."""
  greaterThanInsensitive: String

  """Greater than or equal to the specified value (case-insensitive)."""
  greaterThanOrEqualToInsensitive: String
}

"""
A filter to be used against AuditAction fields. All fields are combined with a logical and.
"""
input AuditActionFilter {
  """
  Is null (if \`true\` is specified) or is not null (if \`false\` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: AuditAction

  """Not equal to the specified value."""
  notEqualTo: AuditAction

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: AuditAction

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: AuditAction

  """Included in the specified list."""
  in: [AuditAction!]

  """Not included in the specified list."""
  notIn: [AuditAction!]

  """Less than the specified value."""
  lessThan: AuditAction

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: AuditAction

  """Greater than the specified value."""
  greaterThan: AuditAction

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: AuditAction
}

"""
A filter to be used against Datetime fields. All fields are combined with a logical and.
"""
input DatetimeFilter {
  """
  Is null (if \`true\` is specified) or is not null (if \`false\` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: Datetime

  """Not equal to the specified value."""
  notEqualTo: Datetime

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Datetime

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: Datetime

  """Included in the specified list."""
  in: [Datetime!]

  """Not included in the specified list."""
  notIn: [Datetime!]

  """Less than the specified value."""
  lessThan: Datetime

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: Datetime

  """Greater than the specified value."""
  greaterThan: Datetime

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: Datetime
}

"""
A filter to be used against \`User\` object types. All fields are combined with a logical and.
"""
input UserFilter {
  """Filter by the objects \`rowId\` field."""
  rowId: UUIDFilter

  """Filter by the objects \`username\` field."""
  username: StringFilter

  """Filter by the objects \`auditLogsByActorUserId\` relation."""
  auditLogsByActorUserId: UserToManyAuditLogFilter

  """Some related \`auditLogsByActorUserId\` exist."""
  auditLogsByActorUserIdExist: Boolean

  """Filter by the objects \`bountiesByClaimantId\` relation."""
  bountiesByClaimantId: UserToManyBountyFilter

  """Some related \`bountiesByClaimantId\` exist."""
  bountiesByClaimantIdExist: Boolean

  """Filter by the objects \`bountyFundingsByFunderId\` relation."""
  bountyFundingsByFunderId: UserToManyBountyFundingFilter

  """Some related \`bountyFundingsByFunderId\` exist."""
  bountyFundingsByFunderIdExist: Boolean

  """Filter by the objects \`donationsByDonorId\` relation."""
  donationsByDonorId: UserToManyDonationFilter

  """Some related \`donationsByDonorId\` exist."""
  donationsByDonorIdExist: Boolean

  """Filter by the objects \`grantApplicationsByApplicantId\` relation."""
  grantApplicationsByApplicantId: UserToManyGrantApplicationFilter

  """Some related \`grantApplicationsByApplicantId\` exist."""
  grantApplicationsByApplicantIdExist: Boolean

  """Filter by the objects \`userIdentities\` relation."""
  userIdentities: UserToManyUserIdentityFilter

  """Some related \`userIdentities\` exist."""
  userIdentitiesExist: Boolean

  """Filter by the objects \`userOrganizations\` relation."""
  userOrganizations: UserToManyUserOrganizationFilter

  """Some related \`userOrganizations\` exist."""
  userOrganizationsExist: Boolean

  """Filter by the objects \`sponsorshipsBySponsorId\` relation."""
  sponsorshipsBySponsorId: UserToManySponsorshipFilter

  """Some related \`sponsorshipsBySponsorId\` exist."""
  sponsorshipsBySponsorIdExist: Boolean

  """Filter by the objects \`transactionsByFromUserId\` relation."""
  transactionsByFromUserId: UserToManyTransactionFilter

  """Some related \`transactionsByFromUserId\` exist."""
  transactionsByFromUserIdExist: Boolean

  """Filter by the objects \`transactionsByToUserId\` relation."""
  transactionsByToUserId: UserToManyTransactionFilter

  """Some related \`transactionsByToUserId\` exist."""
  transactionsByToUserIdExist: Boolean

  """Filter by the objects \`payoutsByRecipientUserId\` relation."""
  payoutsByRecipientUserId: UserToManyPayoutFilter

  """Some related \`payoutsByRecipientUserId\` exist."""
  payoutsByRecipientUserIdExist: Boolean

  """Filter by the objects \`authoredPosts\` relation."""
  authoredPosts: UserToManyPostFilter

  """Some related \`authoredPosts\` exist."""
  authoredPostsExist: Boolean

  """Checks for all expressions in this list."""
  and: [UserFilter!]

  """Checks for any expressions in this list."""
  or: [UserFilter!]

  """Negates the expression."""
  not: UserFilter
}

"""
A filter to be used against many \`AuditLog\` object types. All fields are combined with a logical and.
"""
input UserToManyAuditLogFilter {
  """
  Every related \`AuditLog\` matches the filter criteria. All fields are combined with a logical and.
  """
  every: AuditLogFilter

  """
  Some related \`AuditLog\` matches the filter criteria. All fields are combined with a logical and.
  """
  some: AuditLogFilter

  """
  No related \`AuditLog\` matches the filter criteria. All fields are combined with a logical and.
  """
  none: AuditLogFilter
}

"""
A filter to be used against many \`Bounty\` object types. All fields are combined with a logical and.
"""
input UserToManyBountyFilter {
  """
  Every related \`Bounty\` matches the filter criteria. All fields are combined with a logical and.
  """
  every: BountyFilter

  """
  Some related \`Bounty\` matches the filter criteria. All fields are combined with a logical and.
  """
  some: BountyFilter

  """
  No related \`Bounty\` matches the filter criteria. All fields are combined with a logical and.
  """
  none: BountyFilter
}

"""
A filter to be used against \`Bounty\` object types. All fields are combined with a logical and.
"""
input BountyFilter {
  """Filter by the objects \`rowId\` field."""
  rowId: UUIDFilter

  """Filter by the objects \`organizationId\` field."""
  organizationId: UUIDFilter

  """Filter by the objects \`externalUrl\` field."""
  externalUrl: StringFilter

  """Filter by the objects \`status\` field."""
  status: BountyStatusFilter

  """Filter by the objects \`claimantId\` field."""
  claimantId: UUIDFilter

  """Filter by the objects \`bountyFundings\` relation."""
  bountyFundings: BountyToManyBountyFundingFilter

  """Some related \`bountyFundings\` exist."""
  bountyFundingsExist: Boolean

  """Filter by the objects \`claimant\` relation."""
  claimant: UserFilter

  """A related \`claimant\` exists."""
  claimantExists: Boolean

  """Filter by the objects \`organization\` relation."""
  organization: OrganizationFilter

  """Checks for all expressions in this list."""
  and: [BountyFilter!]

  """Checks for any expressions in this list."""
  or: [BountyFilter!]

  """Negates the expression."""
  not: BountyFilter
}

"""
A filter to be used against BountyStatus fields. All fields are combined with a logical and.
"""
input BountyStatusFilter {
  """
  Is null (if \`true\` is specified) or is not null (if \`false\` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: BountyStatus

  """Not equal to the specified value."""
  notEqualTo: BountyStatus

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: BountyStatus

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: BountyStatus

  """Included in the specified list."""
  in: [BountyStatus!]

  """Not included in the specified list."""
  notIn: [BountyStatus!]

  """Less than the specified value."""
  lessThan: BountyStatus

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: BountyStatus

  """Greater than the specified value."""
  greaterThan: BountyStatus

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: BountyStatus
}

enum BountyStatus {
  open
  in_progress
  completed
  cancelled
}

"""
A filter to be used against many \`BountyFunding\` object types. All fields are combined with a logical and.
"""
input BountyToManyBountyFundingFilter {
  """
  Every related \`BountyFunding\` matches the filter criteria. All fields are combined with a logical and.
  """
  every: BountyFundingFilter

  """
  Some related \`BountyFunding\` matches the filter criteria. All fields are combined with a logical and.
  """
  some: BountyFundingFilter

  """
  No related \`BountyFunding\` matches the filter criteria. All fields are combined with a logical and.
  """
  none: BountyFundingFilter
}

"""
A filter to be used against \`BountyFunding\` object types. All fields are combined with a logical and.
"""
input BountyFundingFilter {
  """Filter by the objects \`rowId\` field."""
  rowId: UUIDFilter

  """Filter by the objects \`bountyId\` field."""
  bountyId: UUIDFilter

  """Filter by the objects \`funderId\` field."""
  funderId: UUIDFilter

  """Filter by the objects \`transactionId\` field."""
  transactionId: UUIDFilter

  """Filter by the objects \`bounty\` relation."""
  bounty: BountyFilter

  """Filter by the objects \`funder\` relation."""
  funder: UserFilter

  """Filter by the objects \`transaction\` relation."""
  transaction: TransactionFilter

  """A related \`transaction\` exists."""
  transactionExists: Boolean

  """Checks for all expressions in this list."""
  and: [BountyFundingFilter!]

  """Checks for any expressions in this list."""
  or: [BountyFundingFilter!]

  """Negates the expression."""
  not: BountyFundingFilter
}

"""
A filter to be used against \`Transaction\` object types. All fields are combined with a logical and.
"""
input TransactionFilter {
  """Filter by the objects \`rowId\` field."""
  rowId: UUIDFilter

  """Filter by the objects \`fromUserId\` field."""
  fromUserId: UUIDFilter

  """Filter by the objects \`toOrganizationId\` field."""
  toOrganizationId: UUIDFilter

  """Filter by the objects \`toUserId\` field."""
  toUserId: UUIDFilter

  """Filter by the objects \`processorConnectionId\` field."""
  processorConnectionId: UUIDFilter

  """Filter by the objects \`externalTransactionId\` field."""
  externalTransactionId: StringFilter

  """Filter by the objects \`transactionType\` field."""
  transactionType: TransactionTypeFilter

  """Filter by the objects \`status\` field."""
  status: TransactionStatusFilter

  """Filter by the objects \`createdAt\` field."""
  createdAt: DatetimeFilter

  """Filter by the objects \`bountyFundings\` relation."""
  bountyFundings: TransactionToManyBountyFundingFilter

  """Some related \`bountyFundings\` exist."""
  bountyFundingsExist: Boolean

  """Filter by the objects \`donations\` relation."""
  donations: TransactionToManyDonationFilter

  """Some related \`donations\` exist."""
  donationsExist: Boolean

  """Filter by the objects \`fromUser\` relation."""
  fromUser: UserFilter

  """A related \`fromUser\` exists."""
  fromUserExists: Boolean

  """Filter by the objects \`processorConnection\` relation."""
  processorConnection: PaymentProcessorConnectionFilter

  """A related \`processorConnection\` exists."""
  processorConnectionExists: Boolean

  """Filter by the objects \`toOrganization\` relation."""
  toOrganization: OrganizationFilter

  """A related \`toOrganization\` exists."""
  toOrganizationExists: Boolean

  """Filter by the objects \`toUser\` relation."""
  toUser: UserFilter

  """A related \`toUser\` exists."""
  toUserExists: Boolean

  """Checks for all expressions in this list."""
  and: [TransactionFilter!]

  """Checks for any expressions in this list."""
  or: [TransactionFilter!]

  """Negates the expression."""
  not: TransactionFilter
}

"""
A filter to be used against TransactionType fields. All fields are combined with a logical and.
"""
input TransactionTypeFilter {
  """
  Is null (if \`true\` is specified) or is not null (if \`false\` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: TransactionType

  """Not equal to the specified value."""
  notEqualTo: TransactionType

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: TransactionType

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: TransactionType

  """Included in the specified list."""
  in: [TransactionType!]

  """Not included in the specified list."""
  notIn: [TransactionType!]

  """Less than the specified value."""
  lessThan: TransactionType

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: TransactionType

  """Greater than the specified value."""
  greaterThan: TransactionType

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: TransactionType
}

enum TransactionType {
  bounty_funding
  bounty_payout
  grant_funding
  grant_milestone_payout
  sponsorship
  donation
  refund
  fee
}

"""
A filter to be used against TransactionStatus fields. All fields are combined with a logical and.
"""
input TransactionStatusFilter {
  """
  Is null (if \`true\` is specified) or is not null (if \`false\` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: TransactionStatus

  """Not equal to the specified value."""
  notEqualTo: TransactionStatus

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: TransactionStatus

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: TransactionStatus

  """Included in the specified list."""
  in: [TransactionStatus!]

  """Not included in the specified list."""
  notIn: [TransactionStatus!]

  """Less than the specified value."""
  lessThan: TransactionStatus

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: TransactionStatus

  """Greater than the specified value."""
  greaterThan: TransactionStatus

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: TransactionStatus
}

enum TransactionStatus {
  pending
  processing
  completed
  failed
  refunded
  partially_refunded
}

"""
A filter to be used against many \`BountyFunding\` object types. All fields are combined with a logical and.
"""
input TransactionToManyBountyFundingFilter {
  """
  Every related \`BountyFunding\` matches the filter criteria. All fields are combined with a logical and.
  """
  every: BountyFundingFilter

  """
  Some related \`BountyFunding\` matches the filter criteria. All fields are combined with a logical and.
  """
  some: BountyFundingFilter

  """
  No related \`BountyFunding\` matches the filter criteria. All fields are combined with a logical and.
  """
  none: BountyFundingFilter
}

"""
A filter to be used against many \`Donation\` object types. All fields are combined with a logical and.
"""
input TransactionToManyDonationFilter {
  """
  Every related \`Donation\` matches the filter criteria. All fields are combined with a logical and.
  """
  every: DonationFilter

  """
  Some related \`Donation\` matches the filter criteria. All fields are combined with a logical and.
  """
  some: DonationFilter

  """
  No related \`Donation\` matches the filter criteria. All fields are combined with a logical and.
  """
  none: DonationFilter
}

"""
A filter to be used against \`Donation\` object types. All fields are combined with a logical and.
"""
input DonationFilter {
  """Filter by the objects \`rowId\` field."""
  rowId: UUIDFilter

  """Filter by the objects \`donorId\` field."""
  donorId: UUIDFilter

  """Filter by the objects \`organizationId\` field."""
  organizationId: UUIDFilter

  """Filter by the objects \`transactionId\` field."""
  transactionId: UUIDFilter

  """Filter by the objects \`donor\` relation."""
  donor: UserFilter

  """A related \`donor\` exists."""
  donorExists: Boolean

  """Filter by the objects \`organization\` relation."""
  organization: OrganizationFilter

  """Filter by the objects \`transaction\` relation."""
  transaction: TransactionFilter

  """A related \`transaction\` exists."""
  transactionExists: Boolean

  """Checks for all expressions in this list."""
  and: [DonationFilter!]

  """Checks for any expressions in this list."""
  or: [DonationFilter!]

  """Negates the expression."""
  not: DonationFilter
}

"""
A filter to be used against \`Organization\` object types. All fields are combined with a logical and.
"""
input OrganizationFilter {
  """Filter by the objects \`rowId\` field."""
  rowId: UUIDFilter

  """Filter by the objects \`slug\` field."""
  slug: StringFilter

  """Filter by the objects \`auditLogs\` relation."""
  auditLogs: OrganizationToManyAuditLogFilter

  """Some related \`auditLogs\` exist."""
  auditLogsExist: Boolean

  """Filter by the objects \`bounties\` relation."""
  bounties: OrganizationToManyBountyFilter

  """Some related \`bounties\` exist."""
  bountiesExist: Boolean

  """Filter by the objects \`donations\` relation."""
  donations: OrganizationToManyDonationFilter

  """Some related \`donations\` exist."""
  donationsExist: Boolean

  """Filter by the objects \`grantPrograms\` relation."""
  grantPrograms: OrganizationToManyGrantProgramFilter

  """Some related \`grantPrograms\` exist."""
  grantProgramsExist: Boolean

  """Filter by the objects \`userOrganizations\` relation."""
  userOrganizations: OrganizationToManyUserOrganizationFilter

  """Some related \`userOrganizations\` exist."""
  userOrganizationsExist: Boolean

  """Filter by the objects \`sponsorshipTiers\` relation."""
  sponsorshipTiers: OrganizationToManySponsorshipTierFilter

  """Some related \`sponsorshipTiers\` exist."""
  sponsorshipTiersExist: Boolean

  """Filter by the objects \`sponsorships\` relation."""
  sponsorships: OrganizationToManySponsorshipFilter

  """Some related \`sponsorships\` exist."""
  sponsorshipsExist: Boolean

  """Filter by the objects \`paymentProcessorConnections\` relation."""
  paymentProcessorConnections: OrganizationToManyPaymentProcessorConnectionFilter

  """Some related \`paymentProcessorConnections\` exist."""
  paymentProcessorConnectionsExist: Boolean

  """Filter by the objects \`transactionsByToOrganizationId\` relation."""
  transactionsByToOrganizationId: OrganizationToManyTransactionFilter

  """Some related \`transactionsByToOrganizationId\` exist."""
  transactionsByToOrganizationIdExist: Boolean

  """Filter by the objects \`payoutsByFromOrganizationId\` relation."""
  payoutsByFromOrganizationId: OrganizationToManyPayoutFilter

  """Some related \`payoutsByFromOrganizationId\` exist."""
  payoutsByFromOrganizationIdExist: Boolean

  """Filter by the objects \`webhookEndpoints\` relation."""
  webhookEndpoints: OrganizationToManyWebhookEndpointFilter

  """Some related \`webhookEndpoints\` exist."""
  webhookEndpointsExist: Boolean

  """Filter by the objects \`goals\` relation."""
  goals: OrganizationToManyGoalFilter

  """Some related \`goals\` exist."""
  goalsExist: Boolean

  """Filter by the objects \`posts\` relation."""
  posts: OrganizationToManyPostFilter

  """Some related \`posts\` exist."""
  postsExist: Boolean

  """Checks for all expressions in this list."""
  and: [OrganizationFilter!]

  """Checks for any expressions in this list."""
  or: [OrganizationFilter!]

  """Negates the expression."""
  not: OrganizationFilter
}

"""
A filter to be used against many \`AuditLog\` object types. All fields are combined with a logical and.
"""
input OrganizationToManyAuditLogFilter {
  """
  Every related \`AuditLog\` matches the filter criteria. All fields are combined with a logical and.
  """
  every: AuditLogFilter

  """
  Some related \`AuditLog\` matches the filter criteria. All fields are combined with a logical and.
  """
  some: AuditLogFilter

  """
  No related \`AuditLog\` matches the filter criteria. All fields are combined with a logical and.
  """
  none: AuditLogFilter
}

"""
A filter to be used against many \`Bounty\` object types. All fields are combined with a logical and.
"""
input OrganizationToManyBountyFilter {
  """
  Every related \`Bounty\` matches the filter criteria. All fields are combined with a logical and.
  """
  every: BountyFilter

  """
  Some related \`Bounty\` matches the filter criteria. All fields are combined with a logical and.
  """
  some: BountyFilter

  """
  No related \`Bounty\` matches the filter criteria. All fields are combined with a logical and.
  """
  none: BountyFilter
}

"""
A filter to be used against many \`Donation\` object types. All fields are combined with a logical and.
"""
input OrganizationToManyDonationFilter {
  """
  Every related \`Donation\` matches the filter criteria. All fields are combined with a logical and.
  """
  every: DonationFilter

  """
  Some related \`Donation\` matches the filter criteria. All fields are combined with a logical and.
  """
  some: DonationFilter

  """
  No related \`Donation\` matches the filter criteria. All fields are combined with a logical and.
  """
  none: DonationFilter
}

"""
A filter to be used against many \`GrantProgram\` object types. All fields are combined with a logical and.
"""
input OrganizationToManyGrantProgramFilter {
  """
  Every related \`GrantProgram\` matches the filter criteria. All fields are combined with a logical and.
  """
  every: GrantProgramFilter

  """
  Some related \`GrantProgram\` matches the filter criteria. All fields are combined with a logical and.
  """
  some: GrantProgramFilter

  """
  No related \`GrantProgram\` matches the filter criteria. All fields are combined with a logical and.
  """
  none: GrantProgramFilter
}

"""
A filter to be used against \`GrantProgram\` object types. All fields are combined with a logical and.
"""
input GrantProgramFilter {
  """Filter by the objects \`rowId\` field."""
  rowId: UUIDFilter

  """Filter by the objects \`organizationId\` field."""
  organizationId: UUIDFilter

  """Filter by the objects \`slug\` field."""
  slug: StringFilter

  """Filter by the objects \`isActive\` field."""
  isActive: BooleanFilter

  """Filter by the objects \`grantApplications\` relation."""
  grantApplications: GrantProgramToManyGrantApplicationFilter

  """Some related \`grantApplications\` exist."""
  grantApplicationsExist: Boolean

  """Filter by the objects \`organization\` relation."""
  organization: OrganizationFilter

  """Checks for all expressions in this list."""
  and: [GrantProgramFilter!]

  """Checks for any expressions in this list."""
  or: [GrantProgramFilter!]

  """Negates the expression."""
  not: GrantProgramFilter
}

"""
A filter to be used against Boolean fields. All fields are combined with a logical and.
"""
input BooleanFilter {
  """
  Is null (if \`true\` is specified) or is not null (if \`false\` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: Boolean

  """Not equal to the specified value."""
  notEqualTo: Boolean

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Boolean

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: Boolean

  """Included in the specified list."""
  in: [Boolean!]

  """Not included in the specified list."""
  notIn: [Boolean!]

  """Less than the specified value."""
  lessThan: Boolean

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: Boolean

  """Greater than the specified value."""
  greaterThan: Boolean

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: Boolean
}

"""
A filter to be used against many \`GrantApplication\` object types. All fields are combined with a logical and.
"""
input GrantProgramToManyGrantApplicationFilter {
  """
  Every related \`GrantApplication\` matches the filter criteria. All fields are combined with a logical and.
  """
  every: GrantApplicationFilter

  """
  Some related \`GrantApplication\` matches the filter criteria. All fields are combined with a logical and.
  """
  some: GrantApplicationFilter

  """
  No related \`GrantApplication\` matches the filter criteria. All fields are combined with a logical and.
  """
  none: GrantApplicationFilter
}

"""
A filter to be used against \`GrantApplication\` object types. All fields are combined with a logical and.
"""
input GrantApplicationFilter {
  """Filter by the objects \`rowId\` field."""
  rowId: UUIDFilter

  """Filter by the objects \`grantProgramId\` field."""
  grantProgramId: UUIDFilter

  """Filter by the objects \`applicantId\` field."""
  applicantId: UUIDFilter

  """Filter by the objects \`status\` field."""
  status: GrantApplicationStatusFilter

  """Filter by the objects \`grantMilestones\` relation."""
  grantMilestones: GrantApplicationToManyGrantMilestoneFilter

  """Some related \`grantMilestones\` exist."""
  grantMilestonesExist: Boolean

  """Filter by the objects \`applicant\` relation."""
  applicant: UserFilter

  """Filter by the objects \`grantProgram\` relation."""
  grantProgram: GrantProgramFilter

  """Filter by the objects \`reviewedBy\` relation."""
  reviewedBy: UserFilter

  """A related \`reviewedBy\` exists."""
  reviewedByExists: Boolean

  """Checks for all expressions in this list."""
  and: [GrantApplicationFilter!]

  """Checks for any expressions in this list."""
  or: [GrantApplicationFilter!]

  """Negates the expression."""
  not: GrantApplicationFilter
}

"""
A filter to be used against GrantApplicationStatus fields. All fields are combined with a logical and.
"""
input GrantApplicationStatusFilter {
  """
  Is null (if \`true\` is specified) or is not null (if \`false\` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: GrantApplicationStatus

  """Not equal to the specified value."""
  notEqualTo: GrantApplicationStatus

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: GrantApplicationStatus

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: GrantApplicationStatus

  """Included in the specified list."""
  in: [GrantApplicationStatus!]

  """Not included in the specified list."""
  notIn: [GrantApplicationStatus!]

  """Less than the specified value."""
  lessThan: GrantApplicationStatus

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: GrantApplicationStatus

  """Greater than the specified value."""
  greaterThan: GrantApplicationStatus

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: GrantApplicationStatus
}

enum GrantApplicationStatus {
  draft
  submitted
  under_review
  approved
  rejected
  funded
  completed
  cancelled
}

"""
A filter to be used against many \`GrantMilestone\` object types. All fields are combined with a logical and.
"""
input GrantApplicationToManyGrantMilestoneFilter {
  """
  Every related \`GrantMilestone\` matches the filter criteria. All fields are combined with a logical and.
  """
  every: GrantMilestoneFilter

  """
  Some related \`GrantMilestone\` matches the filter criteria. All fields are combined with a logical and.
  """
  some: GrantMilestoneFilter

  """
  No related \`GrantMilestone\` matches the filter criteria. All fields are combined with a logical and.
  """
  none: GrantMilestoneFilter
}

"""
A filter to be used against \`GrantMilestone\` object types. All fields are combined with a logical and.
"""
input GrantMilestoneFilter {
  """Filter by the objects \`rowId\` field."""
  rowId: UUIDFilter

  """Filter by the objects \`grantApplicationId\` field."""
  grantApplicationId: UUIDFilter

  """Filter by the objects \`status\` field."""
  status: GrantMilestoneStatusFilter

  """Filter by the objects \`grantApplication\` relation."""
  grantApplication: GrantApplicationFilter

  """Filter by the objects \`transaction\` relation."""
  transaction: TransactionFilter

  """A related \`transaction\` exists."""
  transactionExists: Boolean

  """Checks for all expressions in this list."""
  and: [GrantMilestoneFilter!]

  """Checks for any expressions in this list."""
  or: [GrantMilestoneFilter!]

  """Negates the expression."""
  not: GrantMilestoneFilter
}

"""
A filter to be used against GrantMilestoneStatus fields. All fields are combined with a logical and.
"""
input GrantMilestoneStatusFilter {
  """
  Is null (if \`true\` is specified) or is not null (if \`false\` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: GrantMilestoneStatus

  """Not equal to the specified value."""
  notEqualTo: GrantMilestoneStatus

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: GrantMilestoneStatus

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: GrantMilestoneStatus

  """Included in the specified list."""
  in: [GrantMilestoneStatus!]

  """Not included in the specified list."""
  notIn: [GrantMilestoneStatus!]

  """Less than the specified value."""
  lessThan: GrantMilestoneStatus

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: GrantMilestoneStatus

  """Greater than the specified value."""
  greaterThan: GrantMilestoneStatus

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: GrantMilestoneStatus
}

enum GrantMilestoneStatus {
  pending
  in_progress
  submitted
  approved
  rejected
  paid
}

"""
A filter to be used against many \`UserOrganization\` object types. All fields are combined with a logical and.
"""
input OrganizationToManyUserOrganizationFilter {
  """
  Every related \`UserOrganization\` matches the filter criteria. All fields are combined with a logical and.
  """
  every: UserOrganizationFilter

  """
  Some related \`UserOrganization\` matches the filter criteria. All fields are combined with a logical and.
  """
  some: UserOrganizationFilter

  """
  No related \`UserOrganization\` matches the filter criteria. All fields are combined with a logical and.
  """
  none: UserOrganizationFilter
}

"""
A filter to be used against \`UserOrganization\` object types. All fields are combined with a logical and.
"""
input UserOrganizationFilter {
  """Filter by the objects \`rowId\` field."""
  rowId: UUIDFilter

  """Filter by the objects \`userId\` field."""
  userId: UUIDFilter

  """Filter by the objects \`organizationId\` field."""
  organizationId: UUIDFilter

  """Filter by the objects \`organization\` relation."""
  organization: OrganizationFilter

  """Filter by the objects \`user\` relation."""
  user: UserFilter

  """Checks for all expressions in this list."""
  and: [UserOrganizationFilter!]

  """Checks for any expressions in this list."""
  or: [UserOrganizationFilter!]

  """Negates the expression."""
  not: UserOrganizationFilter
}

"""
A filter to be used against many \`SponsorshipTier\` object types. All fields are combined with a logical and.
"""
input OrganizationToManySponsorshipTierFilter {
  """
  Every related \`SponsorshipTier\` matches the filter criteria. All fields are combined with a logical and.
  """
  every: SponsorshipTierFilter

  """
  Some related \`SponsorshipTier\` matches the filter criteria. All fields are combined with a logical and.
  """
  some: SponsorshipTierFilter

  """
  No related \`SponsorshipTier\` matches the filter criteria. All fields are combined with a logical and.
  """
  none: SponsorshipTierFilter
}

"""
A filter to be used against \`SponsorshipTier\` object types. All fields are combined with a logical and.
"""
input SponsorshipTierFilter {
  """Filter by the objects \`rowId\` field."""
  rowId: UUIDFilter

  """Filter by the objects \`organizationId\` field."""
  organizationId: UUIDFilter

  """Filter by the objects \`isActive\` field."""
  isActive: BooleanFilter

  """Filter by the objects \`sponsorshipsByTierId\` relation."""
  sponsorshipsByTierId: SponsorshipTierToManySponsorshipFilter

  """Some related \`sponsorshipsByTierId\` exist."""
  sponsorshipsByTierIdExist: Boolean

  """Filter by the objects \`organization\` relation."""
  organization: OrganizationFilter

  """Checks for all expressions in this list."""
  and: [SponsorshipTierFilter!]

  """Checks for any expressions in this list."""
  or: [SponsorshipTierFilter!]

  """Negates the expression."""
  not: SponsorshipTierFilter
}

"""
A filter to be used against many \`Sponsorship\` object types. All fields are combined with a logical and.
"""
input SponsorshipTierToManySponsorshipFilter {
  """
  Every related \`Sponsorship\` matches the filter criteria. All fields are combined with a logical and.
  """
  every: SponsorshipFilter

  """
  Some related \`Sponsorship\` matches the filter criteria. All fields are combined with a logical and.
  """
  some: SponsorshipFilter

  """
  No related \`Sponsorship\` matches the filter criteria. All fields are combined with a logical and.
  """
  none: SponsorshipFilter
}

"""
A filter to be used against \`Sponsorship\` object types. All fields are combined with a logical and.
"""
input SponsorshipFilter {
  """Filter by the objects \`rowId\` field."""
  rowId: UUIDFilter

  """Filter by the objects \`sponsorId\` field."""
  sponsorId: UUIDFilter

  """Filter by the objects \`organizationId\` field."""
  organizationId: UUIDFilter

  """Filter by the objects \`tierId\` field."""
  tierId: UUIDFilter

  """Filter by the objects \`frequency\` field."""
  frequency: SponsorshipFrequencyFilter

  """Filter by the objects \`status\` field."""
  status: SponsorshipStatusFilter

  """Filter by the objects \`organization\` relation."""
  organization: OrganizationFilter

  """Filter by the objects \`sponsor\` relation."""
  sponsor: UserFilter

  """Filter by the objects \`tier\` relation."""
  tier: SponsorshipTierFilter

  """A related \`tier\` exists."""
  tierExists: Boolean

  """Checks for all expressions in this list."""
  and: [SponsorshipFilter!]

  """Checks for any expressions in this list."""
  or: [SponsorshipFilter!]

  """Negates the expression."""
  not: SponsorshipFilter
}

"""
A filter to be used against SponsorshipFrequency fields. All fields are combined with a logical and.
"""
input SponsorshipFrequencyFilter {
  """
  Is null (if \`true\` is specified) or is not null (if \`false\` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: SponsorshipFrequency

  """Not equal to the specified value."""
  notEqualTo: SponsorshipFrequency

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: SponsorshipFrequency

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: SponsorshipFrequency

  """Included in the specified list."""
  in: [SponsorshipFrequency!]

  """Not included in the specified list."""
  notIn: [SponsorshipFrequency!]

  """Less than the specified value."""
  lessThan: SponsorshipFrequency

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: SponsorshipFrequency

  """Greater than the specified value."""
  greaterThan: SponsorshipFrequency

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: SponsorshipFrequency
}

enum SponsorshipFrequency {
  one_time
  monthly
  yearly
}

"""
A filter to be used against SponsorshipStatus fields. All fields are combined with a logical and.
"""
input SponsorshipStatusFilter {
  """
  Is null (if \`true\` is specified) or is not null (if \`false\` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: SponsorshipStatus

  """Not equal to the specified value."""
  notEqualTo: SponsorshipStatus

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: SponsorshipStatus

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: SponsorshipStatus

  """Included in the specified list."""
  in: [SponsorshipStatus!]

  """Not included in the specified list."""
  notIn: [SponsorshipStatus!]

  """Less than the specified value."""
  lessThan: SponsorshipStatus

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: SponsorshipStatus

  """Greater than the specified value."""
  greaterThan: SponsorshipStatus

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: SponsorshipStatus
}

enum SponsorshipStatus {
  active
  paused
  cancelled
  expired
}

"""
A filter to be used against many \`Sponsorship\` object types. All fields are combined with a logical and.
"""
input OrganizationToManySponsorshipFilter {
  """
  Every related \`Sponsorship\` matches the filter criteria. All fields are combined with a logical and.
  """
  every: SponsorshipFilter

  """
  Some related \`Sponsorship\` matches the filter criteria. All fields are combined with a logical and.
  """
  some: SponsorshipFilter

  """
  No related \`Sponsorship\` matches the filter criteria. All fields are combined with a logical and.
  """
  none: SponsorshipFilter
}

"""
A filter to be used against many \`PaymentProcessorConnection\` object types. All fields are combined with a logical and.
"""
input OrganizationToManyPaymentProcessorConnectionFilter {
  """
  Every related \`PaymentProcessorConnection\` matches the filter criteria. All fields are combined with a logical and.
  """
  every: PaymentProcessorConnectionFilter

  """
  Some related \`PaymentProcessorConnection\` matches the filter criteria. All fields are combined with a logical and.
  """
  some: PaymentProcessorConnectionFilter

  """
  No related \`PaymentProcessorConnection\` matches the filter criteria. All fields are combined with a logical and.
  """
  none: PaymentProcessorConnectionFilter
}

"""
A filter to be used against \`PaymentProcessorConnection\` object types. All fields are combined with a logical and.
"""
input PaymentProcessorConnectionFilter {
  """Filter by the objects \`rowId\` field."""
  rowId: UUIDFilter

  """Filter by the objects \`organizationId\` field."""
  organizationId: UUIDFilter

  """Filter by the objects \`processor\` field."""
  processor: PaymentProcessorFilter

  """Filter by the objects \`externalAccountId\` field."""
  externalAccountId: StringFilter

  """Filter by the objects \`isActive\` field."""
  isActive: BooleanFilter

  """Filter by the objects \`transactionsByProcessorConnectionId\` relation."""
  transactionsByProcessorConnectionId: PaymentProcessorConnectionToManyTransactionFilter

  """Some related \`transactionsByProcessorConnectionId\` exist."""
  transactionsByProcessorConnectionIdExist: Boolean

  """Filter by the objects \`organization\` relation."""
  organization: OrganizationFilter

  """Checks for all expressions in this list."""
  and: [PaymentProcessorConnectionFilter!]

  """Checks for any expressions in this list."""
  or: [PaymentProcessorConnectionFilter!]

  """Negates the expression."""
  not: PaymentProcessorConnectionFilter
}

"""
A filter to be used against PaymentProcessor fields. All fields are combined with a logical and.
"""
input PaymentProcessorFilter {
  """
  Is null (if \`true\` is specified) or is not null (if \`false\` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: PaymentProcessor

  """Not equal to the specified value."""
  notEqualTo: PaymentProcessor

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: PaymentProcessor

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: PaymentProcessor

  """Included in the specified list."""
  in: [PaymentProcessor!]

  """Not included in the specified list."""
  notIn: [PaymentProcessor!]

  """Less than the specified value."""
  lessThan: PaymentProcessor

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: PaymentProcessor

  """Greater than the specified value."""
  greaterThan: PaymentProcessor

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: PaymentProcessor
}

enum PaymentProcessor {
  stripe_connect
  paypal
  venmo
  crypto_btc
  crypto_eth
  crypto_usdc
}

"""
A filter to be used against many \`Transaction\` object types. All fields are combined with a logical and.
"""
input PaymentProcessorConnectionToManyTransactionFilter {
  """
  Every related \`Transaction\` matches the filter criteria. All fields are combined with a logical and.
  """
  every: TransactionFilter

  """
  Some related \`Transaction\` matches the filter criteria. All fields are combined with a logical and.
  """
  some: TransactionFilter

  """
  No related \`Transaction\` matches the filter criteria. All fields are combined with a logical and.
  """
  none: TransactionFilter
}

"""
A filter to be used against many \`Transaction\` object types. All fields are combined with a logical and.
"""
input OrganizationToManyTransactionFilter {
  """
  Every related \`Transaction\` matches the filter criteria. All fields are combined with a logical and.
  """
  every: TransactionFilter

  """
  Some related \`Transaction\` matches the filter criteria. All fields are combined with a logical and.
  """
  some: TransactionFilter

  """
  No related \`Transaction\` matches the filter criteria. All fields are combined with a logical and.
  """
  none: TransactionFilter
}

"""
A filter to be used against many \`Payout\` object types. All fields are combined with a logical and.
"""
input OrganizationToManyPayoutFilter {
  """
  Every related \`Payout\` matches the filter criteria. All fields are combined with a logical and.
  """
  every: PayoutFilter

  """
  Some related \`Payout\` matches the filter criteria. All fields are combined with a logical and.
  """
  some: PayoutFilter

  """
  No related \`Payout\` matches the filter criteria. All fields are combined with a logical and.
  """
  none: PayoutFilter
}

"""
A filter to be used against \`Payout\` object types. All fields are combined with a logical and.
"""
input PayoutFilter {
  """Filter by the objects \`rowId\` field."""
  rowId: UUIDFilter

  """Filter by the objects \`recipientUserId\` field."""
  recipientUserId: UUIDFilter

  """Filter by the objects \`fromOrganizationId\` field."""
  fromOrganizationId: UUIDFilter

  """Filter by the objects \`status\` field."""
  status: TransactionStatusFilter

  """Filter by the objects \`createdAt\` field."""
  createdAt: DatetimeFilter

  """Filter by the objects \`fromOrganization\` relation."""
  fromOrganization: OrganizationFilter

  """Filter by the objects \`processorConnection\` relation."""
  processorConnection: PaymentProcessorConnectionFilter

  """A related \`processorConnection\` exists."""
  processorConnectionExists: Boolean

  """Filter by the objects \`recipientUser\` relation."""
  recipientUser: UserFilter

  """A related \`recipientUser\` exists."""
  recipientUserExists: Boolean

  """Checks for all expressions in this list."""
  and: [PayoutFilter!]

  """Checks for any expressions in this list."""
  or: [PayoutFilter!]

  """Negates the expression."""
  not: PayoutFilter
}

"""
A filter to be used against many \`WebhookEndpoint\` object types. All fields are combined with a logical and.
"""
input OrganizationToManyWebhookEndpointFilter {
  """
  Every related \`WebhookEndpoint\` matches the filter criteria. All fields are combined with a logical and.
  """
  every: WebhookEndpointFilter

  """
  Some related \`WebhookEndpoint\` matches the filter criteria. All fields are combined with a logical and.
  """
  some: WebhookEndpointFilter

  """
  No related \`WebhookEndpoint\` matches the filter criteria. All fields are combined with a logical and.
  """
  none: WebhookEndpointFilter
}

"""
A filter to be used against \`WebhookEndpoint\` object types. All fields are combined with a logical and.
"""
input WebhookEndpointFilter {
  """Filter by the objects \`rowId\` field."""
  rowId: UUIDFilter

  """Filter by the objects \`organizationId\` field."""
  organizationId: UUIDFilter

  """Filter by the objects \`isActive\` field."""
  isActive: BooleanFilter

  """Filter by the objects \`webhookDeliveries\` relation."""
  webhookDeliveries: WebhookEndpointToManyWebhookDeliveryFilter

  """Some related \`webhookDeliveries\` exist."""
  webhookDeliveriesExist: Boolean

  """Filter by the objects \`organization\` relation."""
  organization: OrganizationFilter

  """Checks for all expressions in this list."""
  and: [WebhookEndpointFilter!]

  """Checks for any expressions in this list."""
  or: [WebhookEndpointFilter!]

  """Negates the expression."""
  not: WebhookEndpointFilter
}

"""
A filter to be used against many \`WebhookDelivery\` object types. All fields are combined with a logical and.
"""
input WebhookEndpointToManyWebhookDeliveryFilter {
  """
  Every related \`WebhookDelivery\` matches the filter criteria. All fields are combined with a logical and.
  """
  every: WebhookDeliveryFilter

  """
  Some related \`WebhookDelivery\` matches the filter criteria. All fields are combined with a logical and.
  """
  some: WebhookDeliveryFilter

  """
  No related \`WebhookDelivery\` matches the filter criteria. All fields are combined with a logical and.
  """
  none: WebhookDeliveryFilter
}

"""
A filter to be used against \`WebhookDelivery\` object types. All fields are combined with a logical and.
"""
input WebhookDeliveryFilter {
  """Filter by the objects \`rowId\` field."""
  rowId: UUIDFilter

  """Filter by the objects \`webhookEndpointId\` field."""
  webhookEndpointId: UUIDFilter

  """Filter by the objects \`isSuccessful\` field."""
  isSuccessful: BooleanFilter

  """Filter by the objects \`nextRetryAt\` field."""
  nextRetryAt: DatetimeFilter

  """Filter by the objects \`createdAt\` field."""
  createdAt: DatetimeFilter

  """Filter by the objects \`webhookEndpoint\` relation."""
  webhookEndpoint: WebhookEndpointFilter

  """Checks for all expressions in this list."""
  and: [WebhookDeliveryFilter!]

  """Checks for any expressions in this list."""
  or: [WebhookDeliveryFilter!]

  """Negates the expression."""
  not: WebhookDeliveryFilter
}

"""
A filter to be used against many \`Goal\` object types. All fields are combined with a logical and.
"""
input OrganizationToManyGoalFilter {
  """
  Every related \`Goal\` matches the filter criteria. All fields are combined with a logical and.
  """
  every: GoalFilter

  """
  Some related \`Goal\` matches the filter criteria. All fields are combined with a logical and.
  """
  some: GoalFilter

  """
  No related \`Goal\` matches the filter criteria. All fields are combined with a logical and.
  """
  none: GoalFilter
}

"""
A filter to be used against \`Goal\` object types. All fields are combined with a logical and.
"""
input GoalFilter {
  """Filter by the objects \`rowId\` field."""
  rowId: UUIDFilter

  """Filter by the objects \`organizationId\` field."""
  organizationId: UUIDFilter

  """Filter by the objects \`isActive\` field."""
  isActive: BooleanFilter

  """Filter by the objects \`organization\` relation."""
  organization: OrganizationFilter

  """Checks for all expressions in this list."""
  and: [GoalFilter!]

  """Checks for any expressions in this list."""
  or: [GoalFilter!]

  """Negates the expression."""
  not: GoalFilter
}

"""
A filter to be used against many \`Post\` object types. All fields are combined with a logical and.
"""
input OrganizationToManyPostFilter {
  """
  Every related \`Post\` matches the filter criteria. All fields are combined with a logical and.
  """
  every: PostFilter

  """
  Some related \`Post\` matches the filter criteria. All fields are combined with a logical and.
  """
  some: PostFilter

  """
  No related \`Post\` matches the filter criteria. All fields are combined with a logical and.
  """
  none: PostFilter
}

"""
A filter to be used against \`Post\` object types. All fields are combined with a logical and.
"""
input PostFilter {
  """Filter by the objects \`rowId\` field."""
  rowId: UUIDFilter

  """Filter by the objects \`organizationId\` field."""
  organizationId: UUIDFilter

  """Filter by the objects \`authorId\` field."""
  authorId: UUIDFilter

  """Filter by the objects \`visibility\` field."""
  visibility: PostVisibilityFilter

  """Filter by the objects \`isPublished\` field."""
  isPublished: BooleanFilter

  """Filter by the objects \`publishedAt\` field."""
  publishedAt: DatetimeFilter

  """Filter by the objects \`author\` relation."""
  author: UserFilter

  """Filter by the objects \`minimumTier\` relation."""
  minimumTier: SponsorshipTierFilter

  """A related \`minimumTier\` exists."""
  minimumTierExists: Boolean

  """Filter by the objects \`organization\` relation."""
  organization: OrganizationFilter

  """Checks for all expressions in this list."""
  and: [PostFilter!]

  """Checks for any expressions in this list."""
  or: [PostFilter!]

  """Negates the expression."""
  not: PostFilter
}

"""
A filter to be used against PostVisibility fields. All fields are combined with a logical and.
"""
input PostVisibilityFilter {
  """
  Is null (if \`true\` is specified) or is not null (if \`false\` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: PostVisibility

  """Not equal to the specified value."""
  notEqualTo: PostVisibility

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: PostVisibility

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: PostVisibility

  """Included in the specified list."""
  in: [PostVisibility!]

  """Not included in the specified list."""
  notIn: [PostVisibility!]

  """Less than the specified value."""
  lessThan: PostVisibility

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: PostVisibility

  """Greater than the specified value."""
  greaterThan: PostVisibility

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: PostVisibility
}

enum PostVisibility {
  public
  supporters_only
  tier_gated
}

"""
A filter to be used against many \`BountyFunding\` object types. All fields are combined with a logical and.
"""
input UserToManyBountyFundingFilter {
  """
  Every related \`BountyFunding\` matches the filter criteria. All fields are combined with a logical and.
  """
  every: BountyFundingFilter

  """
  Some related \`BountyFunding\` matches the filter criteria. All fields are combined with a logical and.
  """
  some: BountyFundingFilter

  """
  No related \`BountyFunding\` matches the filter criteria. All fields are combined with a logical and.
  """
  none: BountyFundingFilter
}

"""
A filter to be used against many \`Donation\` object types. All fields are combined with a logical and.
"""
input UserToManyDonationFilter {
  """
  Every related \`Donation\` matches the filter criteria. All fields are combined with a logical and.
  """
  every: DonationFilter

  """
  Some related \`Donation\` matches the filter criteria. All fields are combined with a logical and.
  """
  some: DonationFilter

  """
  No related \`Donation\` matches the filter criteria. All fields are combined with a logical and.
  """
  none: DonationFilter
}

"""
A filter to be used against many \`GrantApplication\` object types. All fields are combined with a logical and.
"""
input UserToManyGrantApplicationFilter {
  """
  Every related \`GrantApplication\` matches the filter criteria. All fields are combined with a logical and.
  """
  every: GrantApplicationFilter

  """
  Some related \`GrantApplication\` matches the filter criteria. All fields are combined with a logical and.
  """
  some: GrantApplicationFilter

  """
  No related \`GrantApplication\` matches the filter criteria. All fields are combined with a logical and.
  """
  none: GrantApplicationFilter
}

"""
A filter to be used against many \`UserIdentity\` object types. All fields are combined with a logical and.
"""
input UserToManyUserIdentityFilter {
  """
  Every related \`UserIdentity\` matches the filter criteria. All fields are combined with a logical and.
  """
  every: UserIdentityFilter

  """
  Some related \`UserIdentity\` matches the filter criteria. All fields are combined with a logical and.
  """
  some: UserIdentityFilter

  """
  No related \`UserIdentity\` matches the filter criteria. All fields are combined with a logical and.
  """
  none: UserIdentityFilter
}

"""
A filter to be used against \`UserIdentity\` object types. All fields are combined with a logical and.
"""
input UserIdentityFilter {
  """Filter by the objects \`rowId\` field."""
  rowId: UUIDFilter

  """Filter by the objects \`userId\` field."""
  userId: UUIDFilter

  """Filter by the objects \`provider\` field."""
  provider: IdentityProviderFilter

  """Filter by the objects \`providerUserId\` field."""
  providerUserId: StringFilter

  """Filter by the objects \`user\` relation."""
  user: UserFilter

  """Checks for all expressions in this list."""
  and: [UserIdentityFilter!]

  """Checks for any expressions in this list."""
  or: [UserIdentityFilter!]

  """Negates the expression."""
  not: UserIdentityFilter
}

"""
A filter to be used against IdentityProvider fields. All fields are combined with a logical and.
"""
input IdentityProviderFilter {
  """
  Is null (if \`true\` is specified) or is not null (if \`false\` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: IdentityProvider

  """Not equal to the specified value."""
  notEqualTo: IdentityProvider

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: IdentityProvider

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: IdentityProvider

  """Included in the specified list."""
  in: [IdentityProvider!]

  """Not included in the specified list."""
  notIn: [IdentityProvider!]

  """Less than the specified value."""
  lessThan: IdentityProvider

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: IdentityProvider

  """Greater than the specified value."""
  greaterThan: IdentityProvider

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: IdentityProvider
}

enum IdentityProvider {
  github
  gitlab
  hidra
}

"""
A filter to be used against many \`UserOrganization\` object types. All fields are combined with a logical and.
"""
input UserToManyUserOrganizationFilter {
  """
  Every related \`UserOrganization\` matches the filter criteria. All fields are combined with a logical and.
  """
  every: UserOrganizationFilter

  """
  Some related \`UserOrganization\` matches the filter criteria. All fields are combined with a logical and.
  """
  some: UserOrganizationFilter

  """
  No related \`UserOrganization\` matches the filter criteria. All fields are combined with a logical and.
  """
  none: UserOrganizationFilter
}

"""
A filter to be used against many \`Sponsorship\` object types. All fields are combined with a logical and.
"""
input UserToManySponsorshipFilter {
  """
  Every related \`Sponsorship\` matches the filter criteria. All fields are combined with a logical and.
  """
  every: SponsorshipFilter

  """
  Some related \`Sponsorship\` matches the filter criteria. All fields are combined with a logical and.
  """
  some: SponsorshipFilter

  """
  No related \`Sponsorship\` matches the filter criteria. All fields are combined with a logical and.
  """
  none: SponsorshipFilter
}

"""
A filter to be used against many \`Transaction\` object types. All fields are combined with a logical and.
"""
input UserToManyTransactionFilter {
  """
  Every related \`Transaction\` matches the filter criteria. All fields are combined with a logical and.
  """
  every: TransactionFilter

  """
  Some related \`Transaction\` matches the filter criteria. All fields are combined with a logical and.
  """
  some: TransactionFilter

  """
  No related \`Transaction\` matches the filter criteria. All fields are combined with a logical and.
  """
  none: TransactionFilter
}

"""
A filter to be used against many \`Payout\` object types. All fields are combined with a logical and.
"""
input UserToManyPayoutFilter {
  """
  Every related \`Payout\` matches the filter criteria. All fields are combined with a logical and.
  """
  every: PayoutFilter

  """
  Some related \`Payout\` matches the filter criteria. All fields are combined with a logical and.
  """
  some: PayoutFilter

  """
  No related \`Payout\` matches the filter criteria. All fields are combined with a logical and.
  """
  none: PayoutFilter
}

"""
A filter to be used against many \`Post\` object types. All fields are combined with a logical and.
"""
input UserToManyPostFilter {
  """
  Every related \`Post\` matches the filter criteria. All fields are combined with a logical and.
  """
  every: PostFilter

  """
  Some related \`Post\` matches the filter criteria. All fields are combined with a logical and.
  """
  some: PostFilter

  """
  No related \`Post\` matches the filter criteria. All fields are combined with a logical and.
  """
  none: PostFilter
}

"""Methods to use when ordering \`AuditLog\`."""
enum AuditLogOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  ACTOR_USER_ID_ASC
  ACTOR_USER_ID_DESC
  ORGANIZATION_ID_ASC
  ORGANIZATION_ID_DESC
  TARGET_ENTITY_TYPE_ASC
  TARGET_ENTITY_TYPE_DESC
  TARGET_ENTITY_ID_ASC
  TARGET_ENTITY_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
}

"""A connection to a list of \`Bounty\` values."""
type BountyConnection {
  """A list of \`Bounty\` objects."""
  nodes: [Bounty]!

  """
  A list of edges which contains the \`Bounty\` and cursor to aid in pagination.
  """
  edges: [BountyEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`Bounty\` you could get from the connection."""
  totalCount: Int!
}

type Bounty implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
  rowId: UUID!
  organizationId: UUID!
  sourceType: BountySourceType!
  externalUrl: String
  arborIssueId: UUID
  title: String!
  description: String
  targetAmount: BigFloat
  currency: String!
  status: BountyStatus!
  claimantId: UUID
  claimedAt: Datetime
  completedAt: Datetime
  expiresAt: Datetime
  createdAt: Datetime
  updatedAt: Datetime
  deletedAt: Datetime

  """Reads a single \`User\` that is related to this \`Bounty\`."""
  claimant: User

  """Reads a single \`Organization\` that is related to this \`Bounty\`."""
  organization: Organization

  """Reads and enables pagination through a set of \`BountyFunding\`."""
  bountyFundings(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BountyFundingCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: BountyFundingFilter

    """The method to use when ordering \`BountyFunding\`."""
    orderBy: [BountyFundingOrderBy!] = [PRIMARY_KEY_ASC]
  ): BountyFundingConnection!
}

enum BountySourceType {
  external_url
  arbor
}

"""A connection to a list of \`BountyFunding\` values."""
type BountyFundingConnection {
  """A list of \`BountyFunding\` objects."""
  nodes: [BountyFunding]!

  """
  A list of edges which contains the \`BountyFunding\` and cursor to aid in pagination.
  """
  edges: [BountyFundingEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`BountyFunding\` you could get from the connection."""
  totalCount: Int!
}

type BountyFunding implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
  rowId: UUID!
  bountyId: UUID!
  funderId: UUID!
  amount: BigFloat!
  currency: String!
  message: String
  transactionId: UUID
  createdAt: Datetime
  updatedAt: Datetime

  """Reads a single \`Bounty\` that is related to this \`BountyFunding\`."""
  bounty: Bounty

  """Reads a single \`User\` that is related to this \`BountyFunding\`."""
  funder: User

  """Reads a single \`Transaction\` that is related to this \`BountyFunding\`."""
  transaction: Transaction
}

type Transaction implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
  rowId: UUID!
  fromUserId: UUID
  toOrganizationId: UUID
  toUserId: UUID
  processorConnectionId: UUID
  processor: PaymentProcessor
  externalTransactionId: String
  grossAmount: BigFloat!
  platformFeeAmount: BigFloat!
  processorFeeAmount: BigFloat!
  netAmount: BigFloat!
  currency: String!
  transactionType: TransactionType!
  status: TransactionStatus!
  description: String
  metadata: String
  failureReason: String
  refundedAmount: BigFloat
  originalTransactionId: UUID
  processedAt: Datetime
  createdAt: Datetime
  updatedAt: Datetime

  """Reads a single \`User\` that is related to this \`Transaction\`."""
  fromUser: User

  """
  Reads a single \`PaymentProcessorConnection\` that is related to this \`Transaction\`.
  """
  processorConnection: PaymentProcessorConnection

  """Reads a single \`Organization\` that is related to this \`Transaction\`."""
  toOrganization: Organization

  """Reads a single \`User\` that is related to this \`Transaction\`."""
  toUser: User

  """Reads and enables pagination through a set of \`BountyFunding\`."""
  bountyFundings(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BountyFundingCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: BountyFundingFilter

    """The method to use when ordering \`BountyFunding\`."""
    orderBy: [BountyFundingOrderBy!] = [PRIMARY_KEY_ASC]
  ): BountyFundingConnection!

  """Reads and enables pagination through a set of \`Donation\`."""
  donations(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DonationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: DonationFilter

    """The method to use when ordering \`Donation\`."""
    orderBy: [DonationOrderBy!] = [PRIMARY_KEY_ASC]
  ): DonationConnection!
}

type PaymentProcessorConnection implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
  rowId: UUID!
  organizationId: UUID!
  processor: PaymentProcessor!
  externalAccountId: String!
  displayName: String
  isActive: Boolean!
  isPrimary: Boolean!
  isVerified: Boolean!
  verifiedAt: Datetime
  metadata: String
  createdAt: Datetime
  updatedAt: Datetime
  deletedAt: Datetime

  """
  Reads a single \`Organization\` that is related to this \`PaymentProcessorConnection\`.
  """
  organization: Organization

  """Reads and enables pagination through a set of \`Transaction\`."""
  transactionsByProcessorConnectionId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TransactionCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TransactionFilter

    """The method to use when ordering \`Transaction\`."""
    orderBy: [TransactionOrderBy!] = [PRIMARY_KEY_ASC]
  ): TransactionConnection!
}

"""A connection to a list of \`Transaction\` values."""
type TransactionConnection {
  """A list of \`Transaction\` objects."""
  nodes: [Transaction]!

  """
  A list of edges which contains the \`Transaction\` and cursor to aid in pagination.
  """
  edges: [TransactionEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`Transaction\` you could get from the connection."""
  totalCount: Int!
}

"""A \`Transaction\` edge in the connection."""
type TransactionEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`Transaction\` at the end of the edge."""
  node: Transaction
}

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: Cursor

  """When paginating forwards, the cursor to continue."""
  endCursor: Cursor
}

"""
A condition to be used against \`Transaction\` object types. All fields are tested
for equality and combined with a logical and.
"""
input TransactionCondition {
  """Checks for equality with the objects \`rowId\` field."""
  rowId: UUID

  """Checks for equality with the objects \`fromUserId\` field."""
  fromUserId: UUID

  """Checks for equality with the objects \`toOrganizationId\` field."""
  toOrganizationId: UUID

  """Checks for equality with the objects \`toUserId\` field."""
  toUserId: UUID

  """Checks for equality with the objects \`processorConnectionId\` field."""
  processorConnectionId: UUID

  """Checks for equality with the objects \`externalTransactionId\` field."""
  externalTransactionId: String

  """Checks for equality with the objects \`transactionType\` field."""
  transactionType: TransactionType

  """Checks for equality with the objects \`status\` field."""
  status: TransactionStatus

  """Checks for equality with the objects \`createdAt\` field."""
  createdAt: Datetime
}

"""Methods to use when ordering \`Transaction\`."""
enum TransactionOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  FROM_USER_ID_ASC
  FROM_USER_ID_DESC
  TO_ORGANIZATION_ID_ASC
  TO_ORGANIZATION_ID_DESC
  TO_USER_ID_ASC
  TO_USER_ID_DESC
  PROCESSOR_CONNECTION_ID_ASC
  PROCESSOR_CONNECTION_ID_DESC
  EXTERNAL_TRANSACTION_ID_ASC
  EXTERNAL_TRANSACTION_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
}

"""
A condition to be used against \`BountyFunding\` object types. All fields are
tested for equality and combined with a logical and.
"""
input BountyFundingCondition {
  """Checks for equality with the objects \`rowId\` field."""
  rowId: UUID

  """Checks for equality with the objects \`bountyId\` field."""
  bountyId: UUID

  """Checks for equality with the objects \`funderId\` field."""
  funderId: UUID

  """Checks for equality with the objects \`transactionId\` field."""
  transactionId: UUID
}

"""Methods to use when ordering \`BountyFunding\`."""
enum BountyFundingOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  BOUNTY_ID_ASC
  BOUNTY_ID_DESC
  FUNDER_ID_ASC
  FUNDER_ID_DESC
  TRANSACTION_ID_ASC
  TRANSACTION_ID_DESC
}

"""A connection to a list of \`Donation\` values."""
type DonationConnection {
  """A list of \`Donation\` objects."""
  nodes: [Donation]!

  """
  A list of edges which contains the \`Donation\` and cursor to aid in pagination.
  """
  edges: [DonationEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`Donation\` you could get from the connection."""
  totalCount: Int!
}

type Donation implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
  rowId: UUID!
  donorId: UUID
  organizationId: UUID!
  amount: BigFloat!
  currency: String!
  isPublic: Boolean!
  isAnonymous: Boolean!
  publicMessage: String
  transactionId: UUID
  createdAt: Datetime

  """Reads a single \`User\` that is related to this \`Donation\`."""
  donor: User

  """Reads a single \`Organization\` that is related to this \`Donation\`."""
  organization: Organization

  """Reads a single \`Transaction\` that is related to this \`Donation\`."""
  transaction: Transaction
}

"""A \`Donation\` edge in the connection."""
type DonationEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`Donation\` at the end of the edge."""
  node: Donation
}

"""
A condition to be used against \`Donation\` object types. All fields are tested
for equality and combined with a logical and.
"""
input DonationCondition {
  """Checks for equality with the objects \`rowId\` field."""
  rowId: UUID

  """Checks for equality with the objects \`donorId\` field."""
  donorId: UUID

  """Checks for equality with the objects \`organizationId\` field."""
  organizationId: UUID

  """Checks for equality with the objects \`transactionId\` field."""
  transactionId: UUID
}

"""Methods to use when ordering \`Donation\`."""
enum DonationOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  DONOR_ID_ASC
  DONOR_ID_DESC
  ORGANIZATION_ID_ASC
  ORGANIZATION_ID_DESC
  TRANSACTION_ID_ASC
  TRANSACTION_ID_DESC
}

"""A \`BountyFunding\` edge in the connection."""
type BountyFundingEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`BountyFunding\` at the end of the edge."""
  node: BountyFunding
}

"""A \`Bounty\` edge in the connection."""
type BountyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`Bounty\` at the end of the edge."""
  node: Bounty
}

"""
A condition to be used against \`Bounty\` object types. All fields are tested for equality and combined with a logical and.
"""
input BountyCondition {
  """Checks for equality with the objects \`rowId\` field."""
  rowId: UUID

  """Checks for equality with the objects \`organizationId\` field."""
  organizationId: UUID

  """Checks for equality with the objects \`externalUrl\` field."""
  externalUrl: String

  """Checks for equality with the objects \`status\` field."""
  status: BountyStatus

  """Checks for equality with the objects \`claimantId\` field."""
  claimantId: UUID
}

"""Methods to use when ordering \`Bounty\`."""
enum BountyOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  ORGANIZATION_ID_ASC
  ORGANIZATION_ID_DESC
  EXTERNAL_URL_ASC
  EXTERNAL_URL_DESC
  CLAIMANT_ID_ASC
  CLAIMANT_ID_DESC
}

"""A connection to a list of \`GrantApplication\` values."""
type GrantApplicationConnection {
  """A list of \`GrantApplication\` objects."""
  nodes: [GrantApplication]!

  """
  A list of edges which contains the \`GrantApplication\` and cursor to aid in pagination.
  """
  edges: [GrantApplicationEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* \`GrantApplication\` you could get from the connection.
  """
  totalCount: Int!
}

type GrantApplication implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
  rowId: UUID!
  grantProgramId: UUID!
  applicantId: UUID!
  title: String!
  description: String!
  proposedAmount: BigFloat!
  currency: String!
  approvedAmount: BigFloat
  status: GrantApplicationStatus!
  submittedAt: Datetime
  reviewedAt: Datetime
  reviewedById: UUID
  reviewNotes: String
  createdAt: Datetime
  updatedAt: Datetime

  """Reads a single \`User\` that is related to this \`GrantApplication\`."""
  applicant: User

  """
  Reads a single \`GrantProgram\` that is related to this \`GrantApplication\`.
  """
  grantProgram: GrantProgram

  """Reads a single \`User\` that is related to this \`GrantApplication\`."""
  reviewedBy: User

  """Reads and enables pagination through a set of \`GrantMilestone\`."""
  grantMilestones(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: GrantMilestoneCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: GrantMilestoneFilter

    """The method to use when ordering \`GrantMilestone\`."""
    orderBy: [GrantMilestoneOrderBy!] = [PRIMARY_KEY_ASC]
  ): GrantMilestoneConnection!
}

type GrantProgram implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
  rowId: UUID!
  organizationId: UUID!
  name: String!
  slug: String!
  description: String
  guidelines: String
  totalBudget: BigFloat
  remainingBudget: BigFloat
  currency: String!
  minGrantAmount: BigFloat
  maxGrantAmount: BigFloat
  isActive: Boolean!
  applicationsOpenAt: Datetime
  applicationsCloseAt: Datetime
  createdAt: Datetime
  updatedAt: Datetime
  deletedAt: Datetime

  """Reads a single \`Organization\` that is related to this \`GrantProgram\`."""
  organization: Organization

  """Reads and enables pagination through a set of \`GrantApplication\`."""
  grantApplications(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: GrantApplicationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: GrantApplicationFilter

    """The method to use when ordering \`GrantApplication\`."""
    orderBy: [GrantApplicationOrderBy!] = [PRIMARY_KEY_ASC]
  ): GrantApplicationConnection!
}

"""
A condition to be used against \`GrantApplication\` object types. All fields are
tested for equality and combined with a logical and.
"""
input GrantApplicationCondition {
  """Checks for equality with the objects \`rowId\` field."""
  rowId: UUID

  """Checks for equality with the objects \`grantProgramId\` field."""
  grantProgramId: UUID

  """Checks for equality with the objects \`applicantId\` field."""
  applicantId: UUID

  """Checks for equality with the objects \`status\` field."""
  status: GrantApplicationStatus
}

"""Methods to use when ordering \`GrantApplication\`."""
enum GrantApplicationOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  GRANT_PROGRAM_ID_ASC
  GRANT_PROGRAM_ID_DESC
  APPLICANT_ID_ASC
  APPLICANT_ID_DESC
}

"""A connection to a list of \`GrantMilestone\` values."""
type GrantMilestoneConnection {
  """A list of \`GrantMilestone\` objects."""
  nodes: [GrantMilestone]!

  """
  A list of edges which contains the \`GrantMilestone\` and cursor to aid in pagination.
  """
  edges: [GrantMilestoneEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`GrantMilestone\` you could get from the connection."""
  totalCount: Int!
}

type GrantMilestone implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
  rowId: UUID!
  grantApplicationId: UUID!
  title: String!
  description: String
  sequenceOrder: Int!
  amount: BigFloat!
  currency: String!
  status: GrantMilestoneStatus!
  dueDate: Datetime
  submittedAt: Datetime
  approvedAt: Datetime
  paidAt: Datetime
  transactionId: UUID
  createdAt: Datetime
  updatedAt: Datetime

  """
  Reads a single \`GrantApplication\` that is related to this \`GrantMilestone\`.
  """
  grantApplication: GrantApplication

  """Reads a single \`Transaction\` that is related to this \`GrantMilestone\`."""
  transaction: Transaction
}

"""A \`GrantMilestone\` edge in the connection."""
type GrantMilestoneEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`GrantMilestone\` at the end of the edge."""
  node: GrantMilestone
}

"""
A condition to be used against \`GrantMilestone\` object types. All fields are
tested for equality and combined with a logical and.
"""
input GrantMilestoneCondition {
  """Checks for equality with the objects \`rowId\` field."""
  rowId: UUID

  """Checks for equality with the objects \`grantApplicationId\` field."""
  grantApplicationId: UUID

  """Checks for equality with the objects \`status\` field."""
  status: GrantMilestoneStatus
}

"""Methods to use when ordering \`GrantMilestone\`."""
enum GrantMilestoneOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  GRANT_APPLICATION_ID_ASC
  GRANT_APPLICATION_ID_DESC
}

"""A \`GrantApplication\` edge in the connection."""
type GrantApplicationEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`GrantApplication\` at the end of the edge."""
  node: GrantApplication
}

"""A connection to a list of \`UserIdentity\` values."""
type UserIdentityConnection {
  """A list of \`UserIdentity\` objects."""
  nodes: [UserIdentity]!

  """
  A list of edges which contains the \`UserIdentity\` and cursor to aid in pagination.
  """
  edges: [UserIdentityEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`UserIdentity\` you could get from the connection."""
  totalCount: Int!
}

type UserIdentity implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
  rowId: UUID!
  userId: UUID!
  provider: IdentityProvider!
  providerUserId: String!
  providerUsername: String
  providerEmail: String
  accessToken: String
  refreshToken: String
  tokenExpiresAt: Datetime
  createdAt: Datetime
  updatedAt: Datetime

  """Reads a single \`User\` that is related to this \`UserIdentity\`."""
  user: User
}

"""A \`UserIdentity\` edge in the connection."""
type UserIdentityEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`UserIdentity\` at the end of the edge."""
  node: UserIdentity
}

"""
A condition to be used against \`UserIdentity\` object types. All fields are
tested for equality and combined with a logical and.
"""
input UserIdentityCondition {
  """Checks for equality with the objects \`rowId\` field."""
  rowId: UUID

  """Checks for equality with the objects \`userId\` field."""
  userId: UUID

  """Checks for equality with the objects \`provider\` field."""
  provider: IdentityProvider

  """Checks for equality with the objects \`providerUserId\` field."""
  providerUserId: String
}

"""Methods to use when ordering \`UserIdentity\`."""
enum UserIdentityOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  USER_ID_ASC
  USER_ID_DESC
  PROVIDER_USER_ID_ASC
  PROVIDER_USER_ID_DESC
}

"""A connection to a list of \`UserOrganization\` values."""
type UserOrganizationConnection {
  """A list of \`UserOrganization\` objects."""
  nodes: [UserOrganization]!

  """
  A list of edges which contains the \`UserOrganization\` and cursor to aid in pagination.
  """
  edges: [UserOrganizationEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* \`UserOrganization\` you could get from the connection.
  """
  totalCount: Int!
}

"""A \`UserOrganization\` edge in the connection."""
type UserOrganizationEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`UserOrganization\` at the end of the edge."""
  node: UserOrganization
}

"""
A condition to be used against \`UserOrganization\` object types. All fields are
tested for equality and combined with a logical and.
"""
input UserOrganizationCondition {
  """Checks for equality with the objects \`rowId\` field."""
  rowId: UUID

  """Checks for equality with the objects \`userId\` field."""
  userId: UUID

  """Checks for equality with the objects \`organizationId\` field."""
  organizationId: UUID
}

"""Methods to use when ordering \`UserOrganization\`."""
enum UserOrganizationOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  USER_ID_ASC
  USER_ID_DESC
  ORGANIZATION_ID_ASC
  ORGANIZATION_ID_DESC
}

"""A connection to a list of \`Sponsorship\` values."""
type SponsorshipConnection {
  """A list of \`Sponsorship\` objects."""
  nodes: [Sponsorship]!

  """
  A list of edges which contains the \`Sponsorship\` and cursor to aid in pagination.
  """
  edges: [SponsorshipEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`Sponsorship\` you could get from the connection."""
  totalCount: Int!
}

type Sponsorship implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
  rowId: UUID!
  sponsorId: UUID!
  organizationId: UUID!
  tierId: UUID
  amount: BigFloat!
  currency: String!
  frequency: SponsorshipFrequency!
  status: SponsorshipStatus!
  currentPeriodStart: Datetime
  currentPeriodEnd: Datetime
  nextBillingDate: Datetime
  isPublic: Boolean!
  publicMessage: String
  externalSubscriptionId: String
  startedAt: Datetime
  cancelledAt: Datetime
  createdAt: Datetime
  updatedAt: Datetime

  """Reads a single \`Organization\` that is related to this \`Sponsorship\`."""
  organization: Organization

  """Reads a single \`User\` that is related to this \`Sponsorship\`."""
  sponsor: User

  """
  Reads a single \`SponsorshipTier\` that is related to this \`Sponsorship\`.
  """
  tier: SponsorshipTier
}

type SponsorshipTier implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
  rowId: UUID!
  organizationId: UUID!
  name: String!
  description: String
  benefits: String
  monthlyAmount: BigFloat!
  yearlyAmount: BigFloat
  currency: String!
  displayOrder: Int!
  isActive: Boolean!
  isHighlighted: Boolean!
  maxSponsors: Int
  createdAt: Datetime
  updatedAt: Datetime
  deletedAt: Datetime

  """
  Reads a single \`Organization\` that is related to this \`SponsorshipTier\`.
  """
  organization: Organization

  """Reads and enables pagination through a set of \`Sponsorship\`."""
  sponsorshipsByTierId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SponsorshipCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: SponsorshipFilter

    """The method to use when ordering \`Sponsorship\`."""
    orderBy: [SponsorshipOrderBy!] = [PRIMARY_KEY_ASC]
  ): SponsorshipConnection!
}

"""
A condition to be used against \`Sponsorship\` object types. All fields are tested
for equality and combined with a logical and.
"""
input SponsorshipCondition {
  """Checks for equality with the objects \`rowId\` field."""
  rowId: UUID

  """Checks for equality with the objects \`sponsorId\` field."""
  sponsorId: UUID

  """Checks for equality with the objects \`organizationId\` field."""
  organizationId: UUID

  """Checks for equality with the objects \`tierId\` field."""
  tierId: UUID

  """Checks for equality with the objects \`frequency\` field."""
  frequency: SponsorshipFrequency

  """Checks for equality with the objects \`status\` field."""
  status: SponsorshipStatus
}

"""Methods to use when ordering \`Sponsorship\`."""
enum SponsorshipOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  SPONSOR_ID_ASC
  SPONSOR_ID_DESC
  ORGANIZATION_ID_ASC
  ORGANIZATION_ID_DESC
  TIER_ID_ASC
  TIER_ID_DESC
}

"""A \`Sponsorship\` edge in the connection."""
type SponsorshipEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`Sponsorship\` at the end of the edge."""
  node: Sponsorship
}

"""A connection to a list of \`Payout\` values."""
type PayoutConnection {
  """A list of \`Payout\` objects."""
  nodes: [Payout]!

  """
  A list of edges which contains the \`Payout\` and cursor to aid in pagination.
  """
  edges: [PayoutEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`Payout\` you could get from the connection."""
  totalCount: Int!
}

type Payout implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
  rowId: UUID!
  recipientUserId: UUID
  fromOrganizationId: UUID!
  processorConnectionId: UUID
  processor: PaymentProcessor!
  externalPayoutId: String
  amount: BigFloat!
  feeAmount: BigFloat!
  currency: String!
  status: TransactionStatus!
  description: String
  failureReason: String
  initiatedAt: Datetime
  completedAt: Datetime
  createdAt: Datetime
  updatedAt: Datetime

  """Reads a single \`Organization\` that is related to this \`Payout\`."""
  fromOrganization: Organization

  """
  Reads a single \`PaymentProcessorConnection\` that is related to this \`Payout\`.
  """
  processorConnection: PaymentProcessorConnection

  """Reads a single \`User\` that is related to this \`Payout\`."""
  recipientUser: User
}

"""A \`Payout\` edge in the connection."""
type PayoutEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`Payout\` at the end of the edge."""
  node: Payout
}

"""
A condition to be used against \`Payout\` object types. All fields are tested for equality and combined with a logical and.
"""
input PayoutCondition {
  """Checks for equality with the objects \`rowId\` field."""
  rowId: UUID

  """Checks for equality with the objects \`recipientUserId\` field."""
  recipientUserId: UUID

  """Checks for equality with the objects \`fromOrganizationId\` field."""
  fromOrganizationId: UUID

  """Checks for equality with the objects \`status\` field."""
  status: TransactionStatus

  """Checks for equality with the objects \`createdAt\` field."""
  createdAt: Datetime
}

"""Methods to use when ordering \`Payout\`."""
enum PayoutOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  RECIPIENT_USER_ID_ASC
  RECIPIENT_USER_ID_DESC
  FROM_ORGANIZATION_ID_ASC
  FROM_ORGANIZATION_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
}

"""A connection to a list of \`Post\` values."""
type PostConnection {
  """A list of \`Post\` objects."""
  nodes: [Post]!

  """
  A list of edges which contains the \`Post\` and cursor to aid in pagination.
  """
  edges: [PostEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`Post\` you could get from the connection."""
  totalCount: Int!
}

type Post implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
  rowId: UUID!
  organizationId: UUID!
  authorId: UUID!
  title: String!
  content: String!
  excerpt: String
  visibility: PostVisibility!
  minimumTierId: UUID
  isPublished: Boolean!
  publishedAt: Datetime
  createdAt: Datetime
  updatedAt: Datetime
  deletedAt: Datetime

  """Reads a single \`User\` that is related to this \`Post\`."""
  author: User

  """Reads a single \`SponsorshipTier\` that is related to this \`Post\`."""
  minimumTier: SponsorshipTier

  """Reads a single \`Organization\` that is related to this \`Post\`."""
  organization: Organization
}

"""A \`Post\` edge in the connection."""
type PostEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`Post\` at the end of the edge."""
  node: Post
}

"""
A condition to be used against \`Post\` object types. All fields are tested for equality and combined with a logical and.
"""
input PostCondition {
  """Checks for equality with the objects \`rowId\` field."""
  rowId: UUID

  """Checks for equality with the objects \`organizationId\` field."""
  organizationId: UUID

  """Checks for equality with the objects \`authorId\` field."""
  authorId: UUID

  """Checks for equality with the objects \`visibility\` field."""
  visibility: PostVisibility

  """Checks for equality with the objects \`isPublished\` field."""
  isPublished: Boolean

  """Checks for equality with the objects \`publishedAt\` field."""
  publishedAt: Datetime
}

"""Methods to use when ordering \`Post\`."""
enum PostOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  ORGANIZATION_ID_ASC
  ORGANIZATION_ID_DESC
  AUTHOR_ID_ASC
  AUTHOR_ID_DESC
  IS_PUBLISHED_ASC
  IS_PUBLISHED_DESC
  PUBLISHED_AT_ASC
  PUBLISHED_AT_DESC
}

"""A \`AuditLog\` edge in the connection."""
type AuditLogEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`AuditLog\` at the end of the edge."""
  node: AuditLog
}

"""A connection to a list of \`GrantProgram\` values."""
type GrantProgramConnection {
  """A list of \`GrantProgram\` objects."""
  nodes: [GrantProgram]!

  """
  A list of edges which contains the \`GrantProgram\` and cursor to aid in pagination.
  """
  edges: [GrantProgramEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`GrantProgram\` you could get from the connection."""
  totalCount: Int!
}

"""A \`GrantProgram\` edge in the connection."""
type GrantProgramEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`GrantProgram\` at the end of the edge."""
  node: GrantProgram
}

"""
A condition to be used against \`GrantProgram\` object types. All fields are
tested for equality and combined with a logical and.
"""
input GrantProgramCondition {
  """Checks for equality with the objects \`rowId\` field."""
  rowId: UUID

  """Checks for equality with the objects \`organizationId\` field."""
  organizationId: UUID

  """Checks for equality with the objects \`slug\` field."""
  slug: String

  """Checks for equality with the objects \`isActive\` field."""
  isActive: Boolean
}

"""Methods to use when ordering \`GrantProgram\`."""
enum GrantProgramOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  ORGANIZATION_ID_ASC
  ORGANIZATION_ID_DESC
  SLUG_ASC
  SLUG_DESC
  IS_ACTIVE_ASC
  IS_ACTIVE_DESC
}

"""A connection to a list of \`SponsorshipTier\` values."""
type SponsorshipTierConnection {
  """A list of \`SponsorshipTier\` objects."""
  nodes: [SponsorshipTier]!

  """
  A list of edges which contains the \`SponsorshipTier\` and cursor to aid in pagination.
  """
  edges: [SponsorshipTierEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* \`SponsorshipTier\` you could get from the connection.
  """
  totalCount: Int!
}

"""A \`SponsorshipTier\` edge in the connection."""
type SponsorshipTierEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`SponsorshipTier\` at the end of the edge."""
  node: SponsorshipTier
}

"""
A condition to be used against \`SponsorshipTier\` object types. All fields are
tested for equality and combined with a logical and.
"""
input SponsorshipTierCondition {
  """Checks for equality with the objects \`rowId\` field."""
  rowId: UUID

  """Checks for equality with the objects \`organizationId\` field."""
  organizationId: UUID

  """Checks for equality with the objects \`isActive\` field."""
  isActive: Boolean
}

"""Methods to use when ordering \`SponsorshipTier\`."""
enum SponsorshipTierOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  ORGANIZATION_ID_ASC
  ORGANIZATION_ID_DESC
  IS_ACTIVE_ASC
  IS_ACTIVE_DESC
}

"""A connection to a list of \`PaymentProcessorConnection\` values."""
type PaymentProcessorConnectionConnection {
  """A list of \`PaymentProcessorConnection\` objects."""
  nodes: [PaymentProcessorConnection]!

  """
  A list of edges which contains the \`PaymentProcessorConnection\` and cursor to aid in pagination.
  """
  edges: [PaymentProcessorConnectionEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* \`PaymentProcessorConnection\` you could get from the connection.
  """
  totalCount: Int!
}

"""A \`PaymentProcessorConnection\` edge in the connection."""
type PaymentProcessorConnectionEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`PaymentProcessorConnection\` at the end of the edge."""
  node: PaymentProcessorConnection
}

"""
A condition to be used against \`PaymentProcessorConnection\` object types. All
fields are tested for equality and combined with a logical and.
"""
input PaymentProcessorConnectionCondition {
  """Checks for equality with the objects \`rowId\` field."""
  rowId: UUID

  """Checks for equality with the objects \`organizationId\` field."""
  organizationId: UUID

  """Checks for equality with the objects \`processor\` field."""
  processor: PaymentProcessor

  """Checks for equality with the objects \`externalAccountId\` field."""
  externalAccountId: String

  """Checks for equality with the objects \`isActive\` field."""
  isActive: Boolean
}

"""Methods to use when ordering \`PaymentProcessorConnection\`."""
enum PaymentProcessorConnectionOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  ORGANIZATION_ID_ASC
  ORGANIZATION_ID_DESC
  EXTERNAL_ACCOUNT_ID_ASC
  EXTERNAL_ACCOUNT_ID_DESC
  IS_ACTIVE_ASC
  IS_ACTIVE_DESC
}

"""A connection to a list of \`WebhookEndpoint\` values."""
type WebhookEndpointConnection {
  """A list of \`WebhookEndpoint\` objects."""
  nodes: [WebhookEndpoint]!

  """
  A list of edges which contains the \`WebhookEndpoint\` and cursor to aid in pagination.
  """
  edges: [WebhookEndpointEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* \`WebhookEndpoint\` you could get from the connection.
  """
  totalCount: Int!
}

type WebhookEndpoint implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
  rowId: UUID!
  organizationId: UUID!
  url: String!
  secret: String!
  description: String
  events: String!
  isActive: Boolean!
  createdAt: Datetime
  updatedAt: Datetime
  deletedAt: Datetime

  """
  Reads a single \`Organization\` that is related to this \`WebhookEndpoint\`.
  """
  organization: Organization

  """Reads and enables pagination through a set of \`WebhookDelivery\`."""
  webhookDeliveries(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: WebhookDeliveryCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: WebhookDeliveryFilter

    """The method to use when ordering \`WebhookDelivery\`."""
    orderBy: [WebhookDeliveryOrderBy!] = [PRIMARY_KEY_ASC]
  ): WebhookDeliveryConnection!
}

"""A connection to a list of \`WebhookDelivery\` values."""
type WebhookDeliveryConnection {
  """A list of \`WebhookDelivery\` objects."""
  nodes: [WebhookDelivery]!

  """
  A list of edges which contains the \`WebhookDelivery\` and cursor to aid in pagination.
  """
  edges: [WebhookDeliveryEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* \`WebhookDelivery\` you could get from the connection.
  """
  totalCount: Int!
}

type WebhookDelivery implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
  rowId: UUID!
  webhookEndpointId: UUID!
  eventType: String!
  payload: String!
  isSuccessful: Boolean
  httpStatusCode: Int
  responseBody: String
  errorMessage: String
  attemptCount: Int!
  nextRetryAt: Datetime
  deliveredAt: Datetime
  createdAt: Datetime

  """
  Reads a single \`WebhookEndpoint\` that is related to this \`WebhookDelivery\`.
  """
  webhookEndpoint: WebhookEndpoint
}

"""A \`WebhookDelivery\` edge in the connection."""
type WebhookDeliveryEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`WebhookDelivery\` at the end of the edge."""
  node: WebhookDelivery
}

"""
A condition to be used against \`WebhookDelivery\` object types. All fields are
tested for equality and combined with a logical and.
"""
input WebhookDeliveryCondition {
  """Checks for equality with the objects \`rowId\` field."""
  rowId: UUID

  """Checks for equality with the objects \`webhookEndpointId\` field."""
  webhookEndpointId: UUID

  """Checks for equality with the objects \`isSuccessful\` field."""
  isSuccessful: Boolean

  """Checks for equality with the objects \`nextRetryAt\` field."""
  nextRetryAt: Datetime

  """Checks for equality with the objects \`createdAt\` field."""
  createdAt: Datetime
}

"""Methods to use when ordering \`WebhookDelivery\`."""
enum WebhookDeliveryOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  WEBHOOK_ENDPOINT_ID_ASC
  WEBHOOK_ENDPOINT_ID_DESC
  IS_SUCCESSFUL_ASC
  IS_SUCCESSFUL_DESC
  NEXT_RETRY_AT_ASC
  NEXT_RETRY_AT_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
}

"""A \`WebhookEndpoint\` edge in the connection."""
type WebhookEndpointEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`WebhookEndpoint\` at the end of the edge."""
  node: WebhookEndpoint
}

"""
A condition to be used against \`WebhookEndpoint\` object types. All fields are
tested for equality and combined with a logical and.
"""
input WebhookEndpointCondition {
  """Checks for equality with the objects \`rowId\` field."""
  rowId: UUID

  """Checks for equality with the objects \`organizationId\` field."""
  organizationId: UUID

  """Checks for equality with the objects \`isActive\` field."""
  isActive: Boolean
}

"""Methods to use when ordering \`WebhookEndpoint\`."""
enum WebhookEndpointOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  ORGANIZATION_ID_ASC
  ORGANIZATION_ID_DESC
  IS_ACTIVE_ASC
  IS_ACTIVE_DESC
}

"""A connection to a list of \`Goal\` values."""
type GoalConnection {
  """A list of \`Goal\` objects."""
  nodes: [Goal]!

  """
  A list of edges which contains the \`Goal\` and cursor to aid in pagination.
  """
  edges: [GoalEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`Goal\` you could get from the connection."""
  totalCount: Int!
}

type Goal implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
  rowId: UUID!
  organizationId: UUID!
  title: String!
  description: String
  targetAmount: BigFloat!
  currency: String!
  currentAmount: BigFloat!
  displayOrder: Int!
  isActive: Boolean!
  isCompleted: Boolean!
  completedAt: Datetime
  createdAt: Datetime
  updatedAt: Datetime

  """Reads a single \`Organization\` that is related to this \`Goal\`."""
  organization: Organization
}

"""A \`Goal\` edge in the connection."""
type GoalEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`Goal\` at the end of the edge."""
  node: Goal
}

"""
A condition to be used against \`Goal\` object types. All fields are tested for equality and combined with a logical and.
"""
input GoalCondition {
  """Checks for equality with the objects \`rowId\` field."""
  rowId: UUID

  """Checks for equality with the objects \`organizationId\` field."""
  organizationId: UUID

  """Checks for equality with the objects \`isActive\` field."""
  isActive: Boolean
}

"""Methods to use when ordering \`Goal\`."""
enum GoalOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  ORGANIZATION_ID_ASC
  ORGANIZATION_ID_DESC
  IS_ACTIVE_ASC
  IS_ACTIVE_DESC
}

type Workspace implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
  rowId: UUID!
  organizationId: String!
  name: String!
  slug: String!
  createdAt: Datetime
  updatedAt: Datetime
  deletedAt: Datetime
  deletionReason: String
}

"""A connection to a list of \`User\` values."""
type UserConnection {
  """A list of \`User\` objects."""
  nodes: [User]!

  """
  A list of edges which contains the \`User\` and cursor to aid in pagination.
  """
  edges: [UserEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`User\` you could get from the connection."""
  totalCount: Int!
}

"""A \`User\` edge in the connection."""
type UserEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`User\` at the end of the edge."""
  node: User
}

"""
A condition to be used against \`User\` object types. All fields are tested for equality and combined with a logical and.
"""
input UserCondition {
  """Checks for equality with the objects \`rowId\` field."""
  rowId: UUID

  """Checks for equality with the objects \`username\` field."""
  username: String
}

"""Methods to use when ordering \`User\`."""
enum UserOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  USERNAME_ASC
  USERNAME_DESC
}

"""A connection to a list of \`Workspace\` values."""
type WorkspaceConnection {
  """A list of \`Workspace\` objects."""
  nodes: [Workspace]!

  """
  A list of edges which contains the \`Workspace\` and cursor to aid in pagination.
  """
  edges: [WorkspaceEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`Workspace\` you could get from the connection."""
  totalCount: Int!
}

"""A \`Workspace\` edge in the connection."""
type WorkspaceEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`Workspace\` at the end of the edge."""
  node: Workspace
}

"""
A condition to be used against \`Workspace\` object types. All fields are tested
for equality and combined with a logical and.
"""
input WorkspaceCondition {
  """Checks for equality with the objects \`rowId\` field."""
  rowId: UUID

  """Checks for equality with the objects \`organizationId\` field."""
  organizationId: String

  """Checks for equality with the objects \`slug\` field."""
  slug: String
}

"""
A filter to be used against \`Workspace\` object types. All fields are combined with a logical and.
"""
input WorkspaceFilter {
  """Filter by the objects \`rowId\` field."""
  rowId: UUIDFilter

  """Filter by the objects \`organizationId\` field."""
  organizationId: StringFilter

  """Filter by the objects \`slug\` field."""
  slug: StringFilter

  """Checks for all expressions in this list."""
  and: [WorkspaceFilter!]

  """Checks for any expressions in this list."""
  or: [WorkspaceFilter!]

  """Negates the expression."""
  not: WorkspaceFilter
}

"""Methods to use when ordering \`Workspace\`."""
enum WorkspaceOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  ORGANIZATION_ID_ASC
  ORGANIZATION_ID_DESC
  SLUG_ASC
  SLUG_DESC
}

"""A connection to a list of \`Organization\` values."""
type OrganizationConnection {
  """A list of \`Organization\` objects."""
  nodes: [Organization]!

  """
  A list of edges which contains the \`Organization\` and cursor to aid in pagination.
  """
  edges: [OrganizationEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`Organization\` you could get from the connection."""
  totalCount: Int!
}

"""A \`Organization\` edge in the connection."""
type OrganizationEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`Organization\` at the end of the edge."""
  node: Organization
}

"""
A condition to be used against \`Organization\` object types. All fields are
tested for equality and combined with a logical and.
"""
input OrganizationCondition {
  """Checks for equality with the objects \`rowId\` field."""
  rowId: UUID

  """Checks for equality with the objects \`slug\` field."""
  slug: String
}

"""Methods to use when ordering \`Organization\`."""
enum OrganizationOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  SLUG_ASC
  SLUG_DESC
}

"""
The root mutation type which contains root level fields which mutate data.
"""
type Mutation {
  """Creates a single \`UserOrganization\`."""
  createUserOrganization(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateUserOrganizationInput!
  ): CreateUserOrganizationPayload

  """Creates a single \`BountyFunding\`."""
  createBountyFunding(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateBountyFundingInput!
  ): CreateBountyFundingPayload

  """Creates a single \`User\`."""
  createUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateUserInput!
  ): CreateUserPayload

  """Creates a single \`WebhookEndpoint\`."""
  createWebhookEndpoint(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateWebhookEndpointInput!
  ): CreateWebhookEndpointPayload

  """Creates a single \`Workspace\`."""
  createWorkspace(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateWorkspaceInput!
  ): CreateWorkspacePayload

  """Creates a single \`Donation\`."""
  createDonation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateDonationInput!
  ): CreateDonationPayload

  """Creates a single \`Goal\`."""
  createGoal(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateGoalInput!
  ): CreateGoalPayload

  """Creates a single \`UserIdentity\`."""
  createUserIdentity(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateUserIdentityInput!
  ): CreateUserIdentityPayload

  """Creates a single \`WebhookDelivery\`."""
  createWebhookDelivery(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateWebhookDeliveryInput!
  ): CreateWebhookDeliveryPayload

  """Creates a single \`SponsorshipTier\`."""
  createSponsorshipTier(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateSponsorshipTierInput!
  ): CreateSponsorshipTierPayload

  """Creates a single \`PaymentProcessorConnection\`."""
  createPaymentProcessorConnection(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreatePaymentProcessorConnectionInput!
  ): CreatePaymentProcessorConnectionPayload

  """Creates a single \`AuditLog\`."""
  createAuditLog(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateAuditLogInput!
  ): CreateAuditLogPayload

  """Creates a single \`Post\`."""
  createPost(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreatePostInput!
  ): CreatePostPayload

  """Creates a single \`GrantProgram\`."""
  createGrantProgram(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateGrantProgramInput!
  ): CreateGrantProgramPayload

  """Creates a single \`Organization\`."""
  createOrganization(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateOrganizationInput!
  ): CreateOrganizationPayload

  """Creates a single \`GrantApplication\`."""
  createGrantApplication(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateGrantApplicationInput!
  ): CreateGrantApplicationPayload

  """Creates a single \`Payout\`."""
  createPayout(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreatePayoutInput!
  ): CreatePayoutPayload

  """Creates a single \`GrantMilestone\`."""
  createGrantMilestone(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateGrantMilestoneInput!
  ): CreateGrantMilestonePayload

  """Creates a single \`Bounty\`."""
  createBounty(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateBountyInput!
  ): CreateBountyPayload

  """Creates a single \`Transaction\`."""
  createTransaction(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateTransactionInput!
  ): CreateTransactionPayload

  """Creates a single \`Sponsorship\`."""
  createSponsorship(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateSponsorshipInput!
  ): CreateSponsorshipPayload

  """
  Updates a single \`UserOrganization\` using its globally unique id and a patch.
  """
  updateUserOrganizationById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateUserOrganizationByIdInput!
  ): UpdateUserOrganizationPayload

  """Updates a single \`UserOrganization\` using a unique key and a patch."""
  updateUserOrganization(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateUserOrganizationInput!
  ): UpdateUserOrganizationPayload

  """
  Updates a single \`BountyFunding\` using its globally unique id and a patch.
  """
  updateBountyFundingById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateBountyFundingByIdInput!
  ): UpdateBountyFundingPayload

  """Updates a single \`BountyFunding\` using a unique key and a patch."""
  updateBountyFunding(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateBountyFundingInput!
  ): UpdateBountyFundingPayload

  """Updates a single \`User\` using its globally unique id and a patch."""
  updateUserById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateUserByIdInput!
  ): UpdateUserPayload

  """Updates a single \`User\` using a unique key and a patch."""
  updateUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateUserInput!
  ): UpdateUserPayload

  """Updates a single \`User\` using a unique key and a patch."""
  updateUserByUsername(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateUserByUsernameInput!
  ): UpdateUserPayload

  """
  Updates a single \`WebhookEndpoint\` using its globally unique id and a patch.
  """
  updateWebhookEndpointById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateWebhookEndpointByIdInput!
  ): UpdateWebhookEndpointPayload

  """Updates a single \`WebhookEndpoint\` using a unique key and a patch."""
  updateWebhookEndpoint(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateWebhookEndpointInput!
  ): UpdateWebhookEndpointPayload

  """Updates a single \`Workspace\` using its globally unique id and a patch."""
  updateWorkspaceById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateWorkspaceByIdInput!
  ): UpdateWorkspacePayload

  """Updates a single \`Workspace\` using a unique key and a patch."""
  updateWorkspace(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateWorkspaceInput!
  ): UpdateWorkspacePayload

  """Updates a single \`Donation\` using its globally unique id and a patch."""
  updateDonationById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateDonationByIdInput!
  ): UpdateDonationPayload

  """Updates a single \`Donation\` using a unique key and a patch."""
  updateDonation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateDonationInput!
  ): UpdateDonationPayload

  """Updates a single \`Goal\` using its globally unique id and a patch."""
  updateGoalById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateGoalByIdInput!
  ): UpdateGoalPayload

  """Updates a single \`Goal\` using a unique key and a patch."""
  updateGoal(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateGoalInput!
  ): UpdateGoalPayload

  """
  Updates a single \`UserIdentity\` using its globally unique id and a patch.
  """
  updateUserIdentityById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateUserIdentityByIdInput!
  ): UpdateUserIdentityPayload

  """Updates a single \`UserIdentity\` using a unique key and a patch."""
  updateUserIdentity(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateUserIdentityInput!
  ): UpdateUserIdentityPayload

  """
  Updates a single \`WebhookDelivery\` using its globally unique id and a patch.
  """
  updateWebhookDeliveryById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateWebhookDeliveryByIdInput!
  ): UpdateWebhookDeliveryPayload

  """Updates a single \`WebhookDelivery\` using a unique key and a patch."""
  updateWebhookDelivery(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateWebhookDeliveryInput!
  ): UpdateWebhookDeliveryPayload

  """
  Updates a single \`SponsorshipTier\` using its globally unique id and a patch.
  """
  updateSponsorshipTierById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateSponsorshipTierByIdInput!
  ): UpdateSponsorshipTierPayload

  """Updates a single \`SponsorshipTier\` using a unique key and a patch."""
  updateSponsorshipTier(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateSponsorshipTierInput!
  ): UpdateSponsorshipTierPayload

  """
  Updates a single \`PaymentProcessorConnection\` using its globally unique id and a patch.
  """
  updatePaymentProcessorConnectionById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdatePaymentProcessorConnectionByIdInput!
  ): UpdatePaymentProcessorConnectionPayload

  """
  Updates a single \`PaymentProcessorConnection\` using a unique key and a patch.
  """
  updatePaymentProcessorConnection(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdatePaymentProcessorConnectionInput!
  ): UpdatePaymentProcessorConnectionPayload

  """Updates a single \`AuditLog\` using its globally unique id and a patch."""
  updateAuditLogById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateAuditLogByIdInput!
  ): UpdateAuditLogPayload

  """Updates a single \`AuditLog\` using a unique key and a patch."""
  updateAuditLog(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateAuditLogInput!
  ): UpdateAuditLogPayload

  """Updates a single \`Post\` using its globally unique id and a patch."""
  updatePostById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdatePostByIdInput!
  ): UpdatePostPayload

  """Updates a single \`Post\` using a unique key and a patch."""
  updatePost(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdatePostInput!
  ): UpdatePostPayload

  """
  Updates a single \`GrantProgram\` using its globally unique id and a patch.
  """
  updateGrantProgramById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateGrantProgramByIdInput!
  ): UpdateGrantProgramPayload

  """Updates a single \`GrantProgram\` using a unique key and a patch."""
  updateGrantProgram(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateGrantProgramInput!
  ): UpdateGrantProgramPayload

  """
  Updates a single \`Organization\` using its globally unique id and a patch.
  """
  updateOrganizationById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateOrganizationByIdInput!
  ): UpdateOrganizationPayload

  """Updates a single \`Organization\` using a unique key and a patch."""
  updateOrganization(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateOrganizationInput!
  ): UpdateOrganizationPayload

  """Updates a single \`Organization\` using a unique key and a patch."""
  updateOrganizationBySlug(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateOrganizationBySlugInput!
  ): UpdateOrganizationPayload

  """
  Updates a single \`GrantApplication\` using its globally unique id and a patch.
  """
  updateGrantApplicationById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateGrantApplicationByIdInput!
  ): UpdateGrantApplicationPayload

  """Updates a single \`GrantApplication\` using a unique key and a patch."""
  updateGrantApplication(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateGrantApplicationInput!
  ): UpdateGrantApplicationPayload

  """Updates a single \`Payout\` using its globally unique id and a patch."""
  updatePayoutById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdatePayoutByIdInput!
  ): UpdatePayoutPayload

  """Updates a single \`Payout\` using a unique key and a patch."""
  updatePayout(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdatePayoutInput!
  ): UpdatePayoutPayload

  """
  Updates a single \`GrantMilestone\` using its globally unique id and a patch.
  """
  updateGrantMilestoneById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateGrantMilestoneByIdInput!
  ): UpdateGrantMilestonePayload

  """Updates a single \`GrantMilestone\` using a unique key and a patch."""
  updateGrantMilestone(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateGrantMilestoneInput!
  ): UpdateGrantMilestonePayload

  """Updates a single \`Bounty\` using its globally unique id and a patch."""
  updateBountyById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateBountyByIdInput!
  ): UpdateBountyPayload

  """Updates a single \`Bounty\` using a unique key and a patch."""
  updateBounty(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateBountyInput!
  ): UpdateBountyPayload

  """
  Updates a single \`Transaction\` using its globally unique id and a patch.
  """
  updateTransactionById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateTransactionByIdInput!
  ): UpdateTransactionPayload

  """Updates a single \`Transaction\` using a unique key and a patch."""
  updateTransaction(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateTransactionInput!
  ): UpdateTransactionPayload

  """
  Updates a single \`Sponsorship\` using its globally unique id and a patch.
  """
  updateSponsorshipById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateSponsorshipByIdInput!
  ): UpdateSponsorshipPayload

  """Updates a single \`Sponsorship\` using a unique key and a patch."""
  updateSponsorship(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateSponsorshipInput!
  ): UpdateSponsorshipPayload

  """Deletes a single \`UserOrganization\` using its globally unique id."""
  deleteUserOrganizationById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteUserOrganizationByIdInput!
  ): DeleteUserOrganizationPayload

  """Deletes a single \`UserOrganization\` using a unique key."""
  deleteUserOrganization(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteUserOrganizationInput!
  ): DeleteUserOrganizationPayload

  """Deletes a single \`BountyFunding\` using its globally unique id."""
  deleteBountyFundingById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteBountyFundingByIdInput!
  ): DeleteBountyFundingPayload

  """Deletes a single \`BountyFunding\` using a unique key."""
  deleteBountyFunding(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteBountyFundingInput!
  ): DeleteBountyFundingPayload

  """Deletes a single \`User\` using its globally unique id."""
  deleteUserById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteUserByIdInput!
  ): DeleteUserPayload

  """Deletes a single \`User\` using a unique key."""
  deleteUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteUserInput!
  ): DeleteUserPayload

  """Deletes a single \`User\` using a unique key."""
  deleteUserByUsername(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteUserByUsernameInput!
  ): DeleteUserPayload

  """Deletes a single \`WebhookEndpoint\` using its globally unique id."""
  deleteWebhookEndpointById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteWebhookEndpointByIdInput!
  ): DeleteWebhookEndpointPayload

  """Deletes a single \`WebhookEndpoint\` using a unique key."""
  deleteWebhookEndpoint(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteWebhookEndpointInput!
  ): DeleteWebhookEndpointPayload

  """Deletes a single \`Workspace\` using its globally unique id."""
  deleteWorkspaceById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteWorkspaceByIdInput!
  ): DeleteWorkspacePayload

  """Deletes a single \`Workspace\` using a unique key."""
  deleteWorkspace(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteWorkspaceInput!
  ): DeleteWorkspacePayload

  """Deletes a single \`Donation\` using its globally unique id."""
  deleteDonationById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteDonationByIdInput!
  ): DeleteDonationPayload

  """Deletes a single \`Donation\` using a unique key."""
  deleteDonation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteDonationInput!
  ): DeleteDonationPayload

  """Deletes a single \`Goal\` using its globally unique id."""
  deleteGoalById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteGoalByIdInput!
  ): DeleteGoalPayload

  """Deletes a single \`Goal\` using a unique key."""
  deleteGoal(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteGoalInput!
  ): DeleteGoalPayload

  """Deletes a single \`UserIdentity\` using its globally unique id."""
  deleteUserIdentityById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteUserIdentityByIdInput!
  ): DeleteUserIdentityPayload

  """Deletes a single \`UserIdentity\` using a unique key."""
  deleteUserIdentity(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteUserIdentityInput!
  ): DeleteUserIdentityPayload

  """Deletes a single \`WebhookDelivery\` using its globally unique id."""
  deleteWebhookDeliveryById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteWebhookDeliveryByIdInput!
  ): DeleteWebhookDeliveryPayload

  """Deletes a single \`WebhookDelivery\` using a unique key."""
  deleteWebhookDelivery(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteWebhookDeliveryInput!
  ): DeleteWebhookDeliveryPayload

  """Deletes a single \`SponsorshipTier\` using its globally unique id."""
  deleteSponsorshipTierById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteSponsorshipTierByIdInput!
  ): DeleteSponsorshipTierPayload

  """Deletes a single \`SponsorshipTier\` using a unique key."""
  deleteSponsorshipTier(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteSponsorshipTierInput!
  ): DeleteSponsorshipTierPayload

  """
  Deletes a single \`PaymentProcessorConnection\` using its globally unique id.
  """
  deletePaymentProcessorConnectionById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeletePaymentProcessorConnectionByIdInput!
  ): DeletePaymentProcessorConnectionPayload

  """Deletes a single \`PaymentProcessorConnection\` using a unique key."""
  deletePaymentProcessorConnection(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeletePaymentProcessorConnectionInput!
  ): DeletePaymentProcessorConnectionPayload

  """Deletes a single \`AuditLog\` using its globally unique id."""
  deleteAuditLogById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteAuditLogByIdInput!
  ): DeleteAuditLogPayload

  """Deletes a single \`AuditLog\` using a unique key."""
  deleteAuditLog(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteAuditLogInput!
  ): DeleteAuditLogPayload

  """Deletes a single \`Post\` using its globally unique id."""
  deletePostById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeletePostByIdInput!
  ): DeletePostPayload

  """Deletes a single \`Post\` using a unique key."""
  deletePost(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeletePostInput!
  ): DeletePostPayload

  """Deletes a single \`GrantProgram\` using its globally unique id."""
  deleteGrantProgramById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteGrantProgramByIdInput!
  ): DeleteGrantProgramPayload

  """Deletes a single \`GrantProgram\` using a unique key."""
  deleteGrantProgram(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteGrantProgramInput!
  ): DeleteGrantProgramPayload

  """Deletes a single \`Organization\` using its globally unique id."""
  deleteOrganizationById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteOrganizationByIdInput!
  ): DeleteOrganizationPayload

  """Deletes a single \`Organization\` using a unique key."""
  deleteOrganization(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteOrganizationInput!
  ): DeleteOrganizationPayload

  """Deletes a single \`Organization\` using a unique key."""
  deleteOrganizationBySlug(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteOrganizationBySlugInput!
  ): DeleteOrganizationPayload

  """Deletes a single \`GrantApplication\` using its globally unique id."""
  deleteGrantApplicationById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteGrantApplicationByIdInput!
  ): DeleteGrantApplicationPayload

  """Deletes a single \`GrantApplication\` using a unique key."""
  deleteGrantApplication(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteGrantApplicationInput!
  ): DeleteGrantApplicationPayload

  """Deletes a single \`Payout\` using its globally unique id."""
  deletePayoutById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeletePayoutByIdInput!
  ): DeletePayoutPayload

  """Deletes a single \`Payout\` using a unique key."""
  deletePayout(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeletePayoutInput!
  ): DeletePayoutPayload

  """Deletes a single \`GrantMilestone\` using its globally unique id."""
  deleteGrantMilestoneById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteGrantMilestoneByIdInput!
  ): DeleteGrantMilestonePayload

  """Deletes a single \`GrantMilestone\` using a unique key."""
  deleteGrantMilestone(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteGrantMilestoneInput!
  ): DeleteGrantMilestonePayload

  """Deletes a single \`Bounty\` using its globally unique id."""
  deleteBountyById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteBountyByIdInput!
  ): DeleteBountyPayload

  """Deletes a single \`Bounty\` using a unique key."""
  deleteBounty(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteBountyInput!
  ): DeleteBountyPayload

  """Deletes a single \`Transaction\` using its globally unique id."""
  deleteTransactionById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteTransactionByIdInput!
  ): DeleteTransactionPayload

  """Deletes a single \`Transaction\` using a unique key."""
  deleteTransaction(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteTransactionInput!
  ): DeleteTransactionPayload

  """Deletes a single \`Sponsorship\` using its globally unique id."""
  deleteSponsorshipById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteSponsorshipByIdInput!
  ): DeleteSponsorshipPayload

  """Deletes a single \`Sponsorship\` using a unique key."""
  deleteSponsorship(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteSponsorshipInput!
  ): DeleteSponsorshipPayload
}

"""The output of our create \`UserOrganization\` mutation."""
type CreateUserOrganizationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`UserOrganization\` that was created by this mutation."""
  userOrganization: UserOrganization

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`UserOrganization\`. May be used by Relay 1."""
  userOrganizationEdge(
    """The method to use when ordering \`UserOrganization\`."""
    orderBy: [UserOrganizationOrderBy!]! = [PRIMARY_KEY_ASC]
  ): UserOrganizationEdge
}

"""All input for the create \`UserOrganization\` mutation."""
input CreateUserOrganizationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`UserOrganization\` to be created by this mutation."""
  userOrganization: UserOrganizationInput!
}

"""An input for mutations affecting \`UserOrganization\`"""
input UserOrganizationInput {
  rowId: UUID
  userId: UUID!
  organizationId: UUID!
  role: OrganizationRole
  createdAt: Datetime
  updatedAt: Datetime
}

"""The output of our create \`BountyFunding\` mutation."""
type CreateBountyFundingPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`BountyFunding\` that was created by this mutation."""
  bountyFunding: BountyFunding

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`BountyFunding\`. May be used by Relay 1."""
  bountyFundingEdge(
    """The method to use when ordering \`BountyFunding\`."""
    orderBy: [BountyFundingOrderBy!]! = [PRIMARY_KEY_ASC]
  ): BountyFundingEdge
}

"""All input for the create \`BountyFunding\` mutation."""
input CreateBountyFundingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`BountyFunding\` to be created by this mutation."""
  bountyFunding: BountyFundingInput!
}

"""An input for mutations affecting \`BountyFunding\`"""
input BountyFundingInput {
  rowId: UUID
  bountyId: UUID!
  funderId: UUID!
  amount: BigFloat!
  currency: String
  message: String
  transactionId: UUID
  createdAt: Datetime
  updatedAt: Datetime
}

"""The output of our create \`User\` mutation."""
type CreateUserPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`User\` that was created by this mutation."""
  user: User

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`User\`. May be used by Relay 1."""
  userEdge(
    """The method to use when ordering \`User\`."""
    orderBy: [UserOrderBy!]! = [PRIMARY_KEY_ASC]
  ): UserEdge
}

"""All input for the create \`User\` mutation."""
input CreateUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`User\` to be created by this mutation."""
  user: UserInput!
}

"""An input for mutations affecting \`User\`"""
input UserInput {
  rowId: UUID
  createdAt: Datetime
  updatedAt: Datetime
  displayName: String
  username: String
  avatarUrl: String
  bio: String
  websiteUrl: String
  deletedAt: Datetime
}

"""The output of our create \`WebhookEndpoint\` mutation."""
type CreateWebhookEndpointPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`WebhookEndpoint\` that was created by this mutation."""
  webhookEndpoint: WebhookEndpoint

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`WebhookEndpoint\`. May be used by Relay 1."""
  webhookEndpointEdge(
    """The method to use when ordering \`WebhookEndpoint\`."""
    orderBy: [WebhookEndpointOrderBy!]! = [PRIMARY_KEY_ASC]
  ): WebhookEndpointEdge
}

"""All input for the create \`WebhookEndpoint\` mutation."""
input CreateWebhookEndpointInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`WebhookEndpoint\` to be created by this mutation."""
  webhookEndpoint: WebhookEndpointInput!
}

"""An input for mutations affecting \`WebhookEndpoint\`"""
input WebhookEndpointInput {
  rowId: UUID
  organizationId: UUID!
  url: String!
  secret: String!
  description: String
  events: String!
  isActive: Boolean
  createdAt: Datetime
  updatedAt: Datetime
  deletedAt: Datetime
}

"""The output of our create \`Workspace\` mutation."""
type CreateWorkspacePayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Workspace\` that was created by this mutation."""
  workspace: Workspace

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Workspace\`. May be used by Relay 1."""
  workspaceEdge(
    """The method to use when ordering \`Workspace\`."""
    orderBy: [WorkspaceOrderBy!]! = [PRIMARY_KEY_ASC]
  ): WorkspaceEdge
}

"""All input for the create \`Workspace\` mutation."""
input CreateWorkspaceInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`Workspace\` to be created by this mutation."""
  workspace: WorkspaceInput!
}

"""An input for mutations affecting \`Workspace\`"""
input WorkspaceInput {
  rowId: UUID
  organizationId: String!
  name: String!
  slug: String!
  createdAt: Datetime
  updatedAt: Datetime
  deletedAt: Datetime
  deletionReason: String
}

"""The output of our create \`Donation\` mutation."""
type CreateDonationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Donation\` that was created by this mutation."""
  donation: Donation

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Donation\`. May be used by Relay 1."""
  donationEdge(
    """The method to use when ordering \`Donation\`."""
    orderBy: [DonationOrderBy!]! = [PRIMARY_KEY_ASC]
  ): DonationEdge
}

"""All input for the create \`Donation\` mutation."""
input CreateDonationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`Donation\` to be created by this mutation."""
  donation: DonationInput!
}

"""An input for mutations affecting \`Donation\`"""
input DonationInput {
  rowId: UUID
  donorId: UUID
  organizationId: UUID!
  amount: BigFloat!
  currency: String
  isPublic: Boolean
  isAnonymous: Boolean
  publicMessage: String
  transactionId: UUID
  createdAt: Datetime
}

"""The output of our create \`Goal\` mutation."""
type CreateGoalPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Goal\` that was created by this mutation."""
  goal: Goal

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Goal\`. May be used by Relay 1."""
  goalEdge(
    """The method to use when ordering \`Goal\`."""
    orderBy: [GoalOrderBy!]! = [PRIMARY_KEY_ASC]
  ): GoalEdge
}

"""All input for the create \`Goal\` mutation."""
input CreateGoalInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`Goal\` to be created by this mutation."""
  goal: GoalInput!
}

"""An input for mutations affecting \`Goal\`"""
input GoalInput {
  rowId: UUID
  organizationId: UUID!
  title: String!
  description: String
  targetAmount: BigFloat!
  currency: String
  currentAmount: BigFloat
  displayOrder: Int
  isActive: Boolean
  isCompleted: Boolean
  completedAt: Datetime
  createdAt: Datetime
  updatedAt: Datetime
}

"""The output of our create \`UserIdentity\` mutation."""
type CreateUserIdentityPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`UserIdentity\` that was created by this mutation."""
  userIdentity: UserIdentity

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`UserIdentity\`. May be used by Relay 1."""
  userIdentityEdge(
    """The method to use when ordering \`UserIdentity\`."""
    orderBy: [UserIdentityOrderBy!]! = [PRIMARY_KEY_ASC]
  ): UserIdentityEdge
}

"""All input for the create \`UserIdentity\` mutation."""
input CreateUserIdentityInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`UserIdentity\` to be created by this mutation."""
  userIdentity: UserIdentityInput!
}

"""An input for mutations affecting \`UserIdentity\`"""
input UserIdentityInput {
  rowId: UUID
  userId: UUID!
  provider: IdentityProvider!
  providerUserId: String!
  providerUsername: String
  providerEmail: String
  accessToken: String
  refreshToken: String
  tokenExpiresAt: Datetime
  createdAt: Datetime
  updatedAt: Datetime
}

"""The output of our create \`WebhookDelivery\` mutation."""
type CreateWebhookDeliveryPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`WebhookDelivery\` that was created by this mutation."""
  webhookDelivery: WebhookDelivery

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`WebhookDelivery\`. May be used by Relay 1."""
  webhookDeliveryEdge(
    """The method to use when ordering \`WebhookDelivery\`."""
    orderBy: [WebhookDeliveryOrderBy!]! = [PRIMARY_KEY_ASC]
  ): WebhookDeliveryEdge
}

"""All input for the create \`WebhookDelivery\` mutation."""
input CreateWebhookDeliveryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`WebhookDelivery\` to be created by this mutation."""
  webhookDelivery: WebhookDeliveryInput!
}

"""An input for mutations affecting \`WebhookDelivery\`"""
input WebhookDeliveryInput {
  rowId: UUID
  webhookEndpointId: UUID!
  eventType: String!
  payload: String!
  isSuccessful: Boolean
  httpStatusCode: Int
  responseBody: String
  errorMessage: String
  attemptCount: Int
  nextRetryAt: Datetime
  deliveredAt: Datetime
  createdAt: Datetime
}

"""The output of our create \`SponsorshipTier\` mutation."""
type CreateSponsorshipTierPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`SponsorshipTier\` that was created by this mutation."""
  sponsorshipTier: SponsorshipTier

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`SponsorshipTier\`. May be used by Relay 1."""
  sponsorshipTierEdge(
    """The method to use when ordering \`SponsorshipTier\`."""
    orderBy: [SponsorshipTierOrderBy!]! = [PRIMARY_KEY_ASC]
  ): SponsorshipTierEdge
}

"""All input for the create \`SponsorshipTier\` mutation."""
input CreateSponsorshipTierInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`SponsorshipTier\` to be created by this mutation."""
  sponsorshipTier: SponsorshipTierInput!
}

"""An input for mutations affecting \`SponsorshipTier\`"""
input SponsorshipTierInput {
  rowId: UUID
  organizationId: UUID!
  name: String!
  description: String
  benefits: String
  monthlyAmount: BigFloat!
  yearlyAmount: BigFloat
  currency: String
  displayOrder: Int
  isActive: Boolean
  isHighlighted: Boolean
  maxSponsors: Int
  createdAt: Datetime
  updatedAt: Datetime
  deletedAt: Datetime
}

"""The output of our create \`PaymentProcessorConnection\` mutation."""
type CreatePaymentProcessorConnectionPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`PaymentProcessorConnection\` that was created by this mutation."""
  paymentProcessorConnection: PaymentProcessorConnection

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`PaymentProcessorConnection\`. May be used by Relay 1."""
  paymentProcessorConnectionEdge(
    """The method to use when ordering \`PaymentProcessorConnection\`."""
    orderBy: [PaymentProcessorConnectionOrderBy!]! = [PRIMARY_KEY_ASC]
  ): PaymentProcessorConnectionEdge
}

"""All input for the create \`PaymentProcessorConnection\` mutation."""
input CreatePaymentProcessorConnectionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`PaymentProcessorConnection\` to be created by this mutation."""
  paymentProcessorConnection: PaymentProcessorConnectionInput!
}

"""An input for mutations affecting \`PaymentProcessorConnection\`"""
input PaymentProcessorConnectionInput {
  rowId: UUID
  organizationId: UUID!
  processor: PaymentProcessor!
  externalAccountId: String!
  displayName: String
  isActive: Boolean
  isPrimary: Boolean
  isVerified: Boolean
  verifiedAt: Datetime
  metadata: String
  createdAt: Datetime
  updatedAt: Datetime
  deletedAt: Datetime
}

"""The output of our create \`AuditLog\` mutation."""
type CreateAuditLogPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`AuditLog\` that was created by this mutation."""
  auditLog: AuditLog

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`AuditLog\`. May be used by Relay 1."""
  auditLogEdge(
    """The method to use when ordering \`AuditLog\`."""
    orderBy: [AuditLogOrderBy!]! = [PRIMARY_KEY_ASC]
  ): AuditLogEdge
}

"""All input for the create \`AuditLog\` mutation."""
input CreateAuditLogInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`AuditLog\` to be created by this mutation."""
  auditLog: AuditLogInput!
}

"""An input for mutations affecting \`AuditLog\`"""
input AuditLogInput {
  rowId: UUID
  actorUserId: UUID
  actorIpAddress: String
  actorUserAgent: String
  organizationId: UUID
  targetEntityType: String!
  targetEntityId: UUID!
  action: AuditAction!
  previousState: String
  newState: String
  metadata: String
  createdAt: Datetime
}

"""The output of our create \`Post\` mutation."""
type CreatePostPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Post\` that was created by this mutation."""
  post: Post

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Post\`. May be used by Relay 1."""
  postEdge(
    """The method to use when ordering \`Post\`."""
    orderBy: [PostOrderBy!]! = [PRIMARY_KEY_ASC]
  ): PostEdge
}

"""All input for the create \`Post\` mutation."""
input CreatePostInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`Post\` to be created by this mutation."""
  post: PostInput!
}

"""An input for mutations affecting \`Post\`"""
input PostInput {
  rowId: UUID
  organizationId: UUID!
  authorId: UUID!
  title: String!
  content: String!
  excerpt: String
  visibility: PostVisibility
  minimumTierId: UUID
  isPublished: Boolean
  publishedAt: Datetime
  createdAt: Datetime
  updatedAt: Datetime
  deletedAt: Datetime
}

"""The output of our create \`GrantProgram\` mutation."""
type CreateGrantProgramPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`GrantProgram\` that was created by this mutation."""
  grantProgram: GrantProgram

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`GrantProgram\`. May be used by Relay 1."""
  grantProgramEdge(
    """The method to use when ordering \`GrantProgram\`."""
    orderBy: [GrantProgramOrderBy!]! = [PRIMARY_KEY_ASC]
  ): GrantProgramEdge
}

"""All input for the create \`GrantProgram\` mutation."""
input CreateGrantProgramInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`GrantProgram\` to be created by this mutation."""
  grantProgram: GrantProgramInput!
}

"""An input for mutations affecting \`GrantProgram\`"""
input GrantProgramInput {
  rowId: UUID
  organizationId: UUID!
  name: String!
  slug: String!
  description: String
  guidelines: String
  totalBudget: BigFloat
  remainingBudget: BigFloat
  currency: String
  minGrantAmount: BigFloat
  maxGrantAmount: BigFloat
  isActive: Boolean
  applicationsOpenAt: Datetime
  applicationsCloseAt: Datetime
  createdAt: Datetime
  updatedAt: Datetime
  deletedAt: Datetime
}

"""The output of our create \`Organization\` mutation."""
type CreateOrganizationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Organization\` that was created by this mutation."""
  organization: Organization

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Organization\`. May be used by Relay 1."""
  organizationEdge(
    """The method to use when ordering \`Organization\`."""
    orderBy: [OrganizationOrderBy!]! = [PRIMARY_KEY_ASC]
  ): OrganizationEdge
}

"""All input for the create \`Organization\` mutation."""
input CreateOrganizationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`Organization\` to be created by this mutation."""
  organization: OrganizationInput!
}

"""An input for mutations affecting \`Organization\`"""
input OrganizationInput {
  rowId: UUID
  name: String!
  slug: String!
  description: String
  avatarUrl: String
  websiteUrl: String
  organizationType: OrganizationType
  platformFeePercent: BigFloat
  isVerified: Boolean
  verifiedAt: Datetime
  createdAt: Datetime
  updatedAt: Datetime
  deletedAt: Datetime
}

"""The output of our create \`GrantApplication\` mutation."""
type CreateGrantApplicationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`GrantApplication\` that was created by this mutation."""
  grantApplication: GrantApplication

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`GrantApplication\`. May be used by Relay 1."""
  grantApplicationEdge(
    """The method to use when ordering \`GrantApplication\`."""
    orderBy: [GrantApplicationOrderBy!]! = [PRIMARY_KEY_ASC]
  ): GrantApplicationEdge
}

"""All input for the create \`GrantApplication\` mutation."""
input CreateGrantApplicationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`GrantApplication\` to be created by this mutation."""
  grantApplication: GrantApplicationInput!
}

"""An input for mutations affecting \`GrantApplication\`"""
input GrantApplicationInput {
  rowId: UUID
  grantProgramId: UUID!
  applicantId: UUID!
  title: String!
  description: String!
  proposedAmount: BigFloat!
  currency: String
  approvedAmount: BigFloat
  status: GrantApplicationStatus
  submittedAt: Datetime
  reviewedAt: Datetime
  reviewedById: UUID
  reviewNotes: String
  createdAt: Datetime
  updatedAt: Datetime
}

"""The output of our create \`Payout\` mutation."""
type CreatePayoutPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Payout\` that was created by this mutation."""
  payout: Payout

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Payout\`. May be used by Relay 1."""
  payoutEdge(
    """The method to use when ordering \`Payout\`."""
    orderBy: [PayoutOrderBy!]! = [PRIMARY_KEY_ASC]
  ): PayoutEdge
}

"""All input for the create \`Payout\` mutation."""
input CreatePayoutInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`Payout\` to be created by this mutation."""
  payout: PayoutInput!
}

"""An input for mutations affecting \`Payout\`"""
input PayoutInput {
  rowId: UUID
  recipientUserId: UUID
  fromOrganizationId: UUID!
  processorConnectionId: UUID
  processor: PaymentProcessor!
  externalPayoutId: String
  amount: BigFloat!
  feeAmount: BigFloat
  currency: String
  status: TransactionStatus
  description: String
  failureReason: String
  initiatedAt: Datetime
  completedAt: Datetime
  createdAt: Datetime
  updatedAt: Datetime
}

"""The output of our create \`GrantMilestone\` mutation."""
type CreateGrantMilestonePayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`GrantMilestone\` that was created by this mutation."""
  grantMilestone: GrantMilestone

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`GrantMilestone\`. May be used by Relay 1."""
  grantMilestoneEdge(
    """The method to use when ordering \`GrantMilestone\`."""
    orderBy: [GrantMilestoneOrderBy!]! = [PRIMARY_KEY_ASC]
  ): GrantMilestoneEdge
}

"""All input for the create \`GrantMilestone\` mutation."""
input CreateGrantMilestoneInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`GrantMilestone\` to be created by this mutation."""
  grantMilestone: GrantMilestoneInput!
}

"""An input for mutations affecting \`GrantMilestone\`"""
input GrantMilestoneInput {
  rowId: UUID
  grantApplicationId: UUID!
  title: String!
  description: String
  sequenceOrder: Int!
  amount: BigFloat!
  currency: String
  status: GrantMilestoneStatus
  dueDate: Datetime
  submittedAt: Datetime
  approvedAt: Datetime
  paidAt: Datetime
  transactionId: UUID
  createdAt: Datetime
  updatedAt: Datetime
}

"""The output of our create \`Bounty\` mutation."""
type CreateBountyPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Bounty\` that was created by this mutation."""
  bounty: Bounty

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Bounty\`. May be used by Relay 1."""
  bountyEdge(
    """The method to use when ordering \`Bounty\`."""
    orderBy: [BountyOrderBy!]! = [PRIMARY_KEY_ASC]
  ): BountyEdge
}

"""All input for the create \`Bounty\` mutation."""
input CreateBountyInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`Bounty\` to be created by this mutation."""
  bounty: BountyInput!
}

"""An input for mutations affecting \`Bounty\`"""
input BountyInput {
  rowId: UUID
  organizationId: UUID!
  sourceType: BountySourceType!
  externalUrl: String
  arborIssueId: UUID
  title: String!
  description: String
  targetAmount: BigFloat
  currency: String
  status: BountyStatus
  claimantId: UUID
  claimedAt: Datetime
  completedAt: Datetime
  expiresAt: Datetime
  createdAt: Datetime
  updatedAt: Datetime
  deletedAt: Datetime
}

"""The output of our create \`Transaction\` mutation."""
type CreateTransactionPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Transaction\` that was created by this mutation."""
  transaction: Transaction

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Transaction\`. May be used by Relay 1."""
  transactionEdge(
    """The method to use when ordering \`Transaction\`."""
    orderBy: [TransactionOrderBy!]! = [PRIMARY_KEY_ASC]
  ): TransactionEdge
}

"""All input for the create \`Transaction\` mutation."""
input CreateTransactionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`Transaction\` to be created by this mutation."""
  transaction: TransactionInput!
}

"""An input for mutations affecting \`Transaction\`"""
input TransactionInput {
  rowId: UUID
  fromUserId: UUID
  toOrganizationId: UUID
  toUserId: UUID
  processorConnectionId: UUID
  processor: PaymentProcessor
  externalTransactionId: String
  grossAmount: BigFloat!
  platformFeeAmount: BigFloat
  processorFeeAmount: BigFloat
  netAmount: BigFloat!
  currency: String
  transactionType: TransactionType!
  status: TransactionStatus
  description: String
  metadata: String
  failureReason: String
  refundedAmount: BigFloat
  originalTransactionId: UUID
  processedAt: Datetime
  createdAt: Datetime
  updatedAt: Datetime
}

"""The output of our create \`Sponsorship\` mutation."""
type CreateSponsorshipPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Sponsorship\` that was created by this mutation."""
  sponsorship: Sponsorship

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Sponsorship\`. May be used by Relay 1."""
  sponsorshipEdge(
    """The method to use when ordering \`Sponsorship\`."""
    orderBy: [SponsorshipOrderBy!]! = [PRIMARY_KEY_ASC]
  ): SponsorshipEdge
}

"""All input for the create \`Sponsorship\` mutation."""
input CreateSponsorshipInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`Sponsorship\` to be created by this mutation."""
  sponsorship: SponsorshipInput!
}

"""An input for mutations affecting \`Sponsorship\`"""
input SponsorshipInput {
  rowId: UUID
  sponsorId: UUID!
  organizationId: UUID!
  tierId: UUID
  amount: BigFloat!
  currency: String
  frequency: SponsorshipFrequency
  status: SponsorshipStatus
  currentPeriodStart: Datetime
  currentPeriodEnd: Datetime
  nextBillingDate: Datetime
  isPublic: Boolean
  publicMessage: String
  externalSubscriptionId: String
  startedAt: Datetime
  cancelledAt: Datetime
  createdAt: Datetime
  updatedAt: Datetime
}

"""The output of our update \`UserOrganization\` mutation."""
type UpdateUserOrganizationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`UserOrganization\` that was updated by this mutation."""
  userOrganization: UserOrganization

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`UserOrganization\`. May be used by Relay 1."""
  userOrganizationEdge(
    """The method to use when ordering \`UserOrganization\`."""
    orderBy: [UserOrganizationOrderBy!]! = [PRIMARY_KEY_ASC]
  ): UserOrganizationEdge
}

"""All input for the \`updateUserOrganizationById\` mutation."""
input UpdateUserOrganizationByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`UserOrganization\` to be updated.
  """
  id: ID!

  """
  An object where the defined keys will be set on the \`UserOrganization\` being updated.
  """
  patch: UserOrganizationPatch!
}

"""
Represents an update to a \`UserOrganization\`. Fields that are set will be updated.
"""
input UserOrganizationPatch {
  rowId: UUID
  userId: UUID
  organizationId: UUID
  role: OrganizationRole
  createdAt: Datetime
  updatedAt: Datetime
}

"""All input for the \`updateUserOrganization\` mutation."""
input UpdateUserOrganizationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the \`UserOrganization\` being updated.
  """
  patch: UserOrganizationPatch!
}

"""The output of our update \`BountyFunding\` mutation."""
type UpdateBountyFundingPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`BountyFunding\` that was updated by this mutation."""
  bountyFunding: BountyFunding

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`BountyFunding\`. May be used by Relay 1."""
  bountyFundingEdge(
    """The method to use when ordering \`BountyFunding\`."""
    orderBy: [BountyFundingOrderBy!]! = [PRIMARY_KEY_ASC]
  ): BountyFundingEdge
}

"""All input for the \`updateBountyFundingById\` mutation."""
input UpdateBountyFundingByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`BountyFunding\` to be updated.
  """
  id: ID!

  """
  An object where the defined keys will be set on the \`BountyFunding\` being updated.
  """
  patch: BountyFundingPatch!
}

"""
Represents an update to a \`BountyFunding\`. Fields that are set will be updated.
"""
input BountyFundingPatch {
  rowId: UUID
  bountyId: UUID
  funderId: UUID
  amount: BigFloat
  currency: String
  message: String
  transactionId: UUID
  createdAt: Datetime
  updatedAt: Datetime
}

"""All input for the \`updateBountyFunding\` mutation."""
input UpdateBountyFundingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the \`BountyFunding\` being updated.
  """
  patch: BountyFundingPatch!
}

"""The output of our update \`User\` mutation."""
type UpdateUserPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`User\` that was updated by this mutation."""
  user: User

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`User\`. May be used by Relay 1."""
  userEdge(
    """The method to use when ordering \`User\`."""
    orderBy: [UserOrderBy!]! = [PRIMARY_KEY_ASC]
  ): UserEdge
}

"""All input for the \`updateUserById\` mutation."""
input UpdateUserByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`User\` to be updated.
  """
  id: ID!

  """
  An object where the defined keys will be set on the \`User\` being updated.
  """
  patch: UserPatch!
}

"""Represents an update to a \`User\`. Fields that are set will be updated."""
input UserPatch {
  rowId: UUID
  createdAt: Datetime
  updatedAt: Datetime
  displayName: String
  username: String
  avatarUrl: String
  bio: String
  websiteUrl: String
  deletedAt: Datetime
}

"""All input for the \`updateUser\` mutation."""
input UpdateUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the \`User\` being updated.
  """
  patch: UserPatch!
}

"""All input for the \`updateUserByUsername\` mutation."""
input UpdateUserByUsernameInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  username: String!

  """
  An object where the defined keys will be set on the \`User\` being updated.
  """
  patch: UserPatch!
}

"""The output of our update \`WebhookEndpoint\` mutation."""
type UpdateWebhookEndpointPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`WebhookEndpoint\` that was updated by this mutation."""
  webhookEndpoint: WebhookEndpoint

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`WebhookEndpoint\`. May be used by Relay 1."""
  webhookEndpointEdge(
    """The method to use when ordering \`WebhookEndpoint\`."""
    orderBy: [WebhookEndpointOrderBy!]! = [PRIMARY_KEY_ASC]
  ): WebhookEndpointEdge
}

"""All input for the \`updateWebhookEndpointById\` mutation."""
input UpdateWebhookEndpointByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`WebhookEndpoint\` to be updated.
  """
  id: ID!

  """
  An object where the defined keys will be set on the \`WebhookEndpoint\` being updated.
  """
  patch: WebhookEndpointPatch!
}

"""
Represents an update to a \`WebhookEndpoint\`. Fields that are set will be updated.
"""
input WebhookEndpointPatch {
  rowId: UUID
  organizationId: UUID
  url: String
  secret: String
  description: String
  events: String
  isActive: Boolean
  createdAt: Datetime
  updatedAt: Datetime
  deletedAt: Datetime
}

"""All input for the \`updateWebhookEndpoint\` mutation."""
input UpdateWebhookEndpointInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the \`WebhookEndpoint\` being updated.
  """
  patch: WebhookEndpointPatch!
}

"""The output of our update \`Workspace\` mutation."""
type UpdateWorkspacePayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Workspace\` that was updated by this mutation."""
  workspace: Workspace

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Workspace\`. May be used by Relay 1."""
  workspaceEdge(
    """The method to use when ordering \`Workspace\`."""
    orderBy: [WorkspaceOrderBy!]! = [PRIMARY_KEY_ASC]
  ): WorkspaceEdge
}

"""All input for the \`updateWorkspaceById\` mutation."""
input UpdateWorkspaceByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`Workspace\` to be updated.
  """
  id: ID!

  """
  An object where the defined keys will be set on the \`Workspace\` being updated.
  """
  patch: WorkspacePatch!
}

"""
Represents an update to a \`Workspace\`. Fields that are set will be updated.
"""
input WorkspacePatch {
  rowId: UUID
  organizationId: String
  name: String
  slug: String
  createdAt: Datetime
  updatedAt: Datetime
  deletedAt: Datetime
  deletionReason: String
}

"""All input for the \`updateWorkspace\` mutation."""
input UpdateWorkspaceInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the \`Workspace\` being updated.
  """
  patch: WorkspacePatch!
}

"""The output of our update \`Donation\` mutation."""
type UpdateDonationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Donation\` that was updated by this mutation."""
  donation: Donation

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Donation\`. May be used by Relay 1."""
  donationEdge(
    """The method to use when ordering \`Donation\`."""
    orderBy: [DonationOrderBy!]! = [PRIMARY_KEY_ASC]
  ): DonationEdge
}

"""All input for the \`updateDonationById\` mutation."""
input UpdateDonationByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`Donation\` to be updated.
  """
  id: ID!

  """
  An object where the defined keys will be set on the \`Donation\` being updated.
  """
  patch: DonationPatch!
}

"""
Represents an update to a \`Donation\`. Fields that are set will be updated.
"""
input DonationPatch {
  rowId: UUID
  donorId: UUID
  organizationId: UUID
  amount: BigFloat
  currency: String
  isPublic: Boolean
  isAnonymous: Boolean
  publicMessage: String
  transactionId: UUID
  createdAt: Datetime
}

"""All input for the \`updateDonation\` mutation."""
input UpdateDonationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the \`Donation\` being updated.
  """
  patch: DonationPatch!
}

"""The output of our update \`Goal\` mutation."""
type UpdateGoalPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Goal\` that was updated by this mutation."""
  goal: Goal

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Goal\`. May be used by Relay 1."""
  goalEdge(
    """The method to use when ordering \`Goal\`."""
    orderBy: [GoalOrderBy!]! = [PRIMARY_KEY_ASC]
  ): GoalEdge
}

"""All input for the \`updateGoalById\` mutation."""
input UpdateGoalByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`Goal\` to be updated.
  """
  id: ID!

  """
  An object where the defined keys will be set on the \`Goal\` being updated.
  """
  patch: GoalPatch!
}

"""Represents an update to a \`Goal\`. Fields that are set will be updated."""
input GoalPatch {
  rowId: UUID
  organizationId: UUID
  title: String
  description: String
  targetAmount: BigFloat
  currency: String
  currentAmount: BigFloat
  displayOrder: Int
  isActive: Boolean
  isCompleted: Boolean
  completedAt: Datetime
  createdAt: Datetime
  updatedAt: Datetime
}

"""All input for the \`updateGoal\` mutation."""
input UpdateGoalInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the \`Goal\` being updated.
  """
  patch: GoalPatch!
}

"""The output of our update \`UserIdentity\` mutation."""
type UpdateUserIdentityPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`UserIdentity\` that was updated by this mutation."""
  userIdentity: UserIdentity

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`UserIdentity\`. May be used by Relay 1."""
  userIdentityEdge(
    """The method to use when ordering \`UserIdentity\`."""
    orderBy: [UserIdentityOrderBy!]! = [PRIMARY_KEY_ASC]
  ): UserIdentityEdge
}

"""All input for the \`updateUserIdentityById\` mutation."""
input UpdateUserIdentityByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`UserIdentity\` to be updated.
  """
  id: ID!

  """
  An object where the defined keys will be set on the \`UserIdentity\` being updated.
  """
  patch: UserIdentityPatch!
}

"""
Represents an update to a \`UserIdentity\`. Fields that are set will be updated.
"""
input UserIdentityPatch {
  rowId: UUID
  userId: UUID
  provider: IdentityProvider
  providerUserId: String
  providerUsername: String
  providerEmail: String
  accessToken: String
  refreshToken: String
  tokenExpiresAt: Datetime
  createdAt: Datetime
  updatedAt: Datetime
}

"""All input for the \`updateUserIdentity\` mutation."""
input UpdateUserIdentityInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the \`UserIdentity\` being updated.
  """
  patch: UserIdentityPatch!
}

"""The output of our update \`WebhookDelivery\` mutation."""
type UpdateWebhookDeliveryPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`WebhookDelivery\` that was updated by this mutation."""
  webhookDelivery: WebhookDelivery

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`WebhookDelivery\`. May be used by Relay 1."""
  webhookDeliveryEdge(
    """The method to use when ordering \`WebhookDelivery\`."""
    orderBy: [WebhookDeliveryOrderBy!]! = [PRIMARY_KEY_ASC]
  ): WebhookDeliveryEdge
}

"""All input for the \`updateWebhookDeliveryById\` mutation."""
input UpdateWebhookDeliveryByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`WebhookDelivery\` to be updated.
  """
  id: ID!

  """
  An object where the defined keys will be set on the \`WebhookDelivery\` being updated.
  """
  patch: WebhookDeliveryPatch!
}

"""
Represents an update to a \`WebhookDelivery\`. Fields that are set will be updated.
"""
input WebhookDeliveryPatch {
  rowId: UUID
  webhookEndpointId: UUID
  eventType: String
  payload: String
  isSuccessful: Boolean
  httpStatusCode: Int
  responseBody: String
  errorMessage: String
  attemptCount: Int
  nextRetryAt: Datetime
  deliveredAt: Datetime
  createdAt: Datetime
}

"""All input for the \`updateWebhookDelivery\` mutation."""
input UpdateWebhookDeliveryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the \`WebhookDelivery\` being updated.
  """
  patch: WebhookDeliveryPatch!
}

"""The output of our update \`SponsorshipTier\` mutation."""
type UpdateSponsorshipTierPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`SponsorshipTier\` that was updated by this mutation."""
  sponsorshipTier: SponsorshipTier

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`SponsorshipTier\`. May be used by Relay 1."""
  sponsorshipTierEdge(
    """The method to use when ordering \`SponsorshipTier\`."""
    orderBy: [SponsorshipTierOrderBy!]! = [PRIMARY_KEY_ASC]
  ): SponsorshipTierEdge
}

"""All input for the \`updateSponsorshipTierById\` mutation."""
input UpdateSponsorshipTierByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`SponsorshipTier\` to be updated.
  """
  id: ID!

  """
  An object where the defined keys will be set on the \`SponsorshipTier\` being updated.
  """
  patch: SponsorshipTierPatch!
}

"""
Represents an update to a \`SponsorshipTier\`. Fields that are set will be updated.
"""
input SponsorshipTierPatch {
  rowId: UUID
  organizationId: UUID
  name: String
  description: String
  benefits: String
  monthlyAmount: BigFloat
  yearlyAmount: BigFloat
  currency: String
  displayOrder: Int
  isActive: Boolean
  isHighlighted: Boolean
  maxSponsors: Int
  createdAt: Datetime
  updatedAt: Datetime
  deletedAt: Datetime
}

"""All input for the \`updateSponsorshipTier\` mutation."""
input UpdateSponsorshipTierInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the \`SponsorshipTier\` being updated.
  """
  patch: SponsorshipTierPatch!
}

"""The output of our update \`PaymentProcessorConnection\` mutation."""
type UpdatePaymentProcessorConnectionPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`PaymentProcessorConnection\` that was updated by this mutation."""
  paymentProcessorConnection: PaymentProcessorConnection

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`PaymentProcessorConnection\`. May be used by Relay 1."""
  paymentProcessorConnectionEdge(
    """The method to use when ordering \`PaymentProcessorConnection\`."""
    orderBy: [PaymentProcessorConnectionOrderBy!]! = [PRIMARY_KEY_ASC]
  ): PaymentProcessorConnectionEdge
}

"""All input for the \`updatePaymentProcessorConnectionById\` mutation."""
input UpdatePaymentProcessorConnectionByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`PaymentProcessorConnection\` to be updated.
  """
  id: ID!

  """
  An object where the defined keys will be set on the \`PaymentProcessorConnection\` being updated.
  """
  patch: PaymentProcessorConnectionPatch!
}

"""
Represents an update to a \`PaymentProcessorConnection\`. Fields that are set will be updated.
"""
input PaymentProcessorConnectionPatch {
  rowId: UUID
  organizationId: UUID
  processor: PaymentProcessor
  externalAccountId: String
  displayName: String
  isActive: Boolean
  isPrimary: Boolean
  isVerified: Boolean
  verifiedAt: Datetime
  metadata: String
  createdAt: Datetime
  updatedAt: Datetime
  deletedAt: Datetime
}

"""All input for the \`updatePaymentProcessorConnection\` mutation."""
input UpdatePaymentProcessorConnectionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the \`PaymentProcessorConnection\` being updated.
  """
  patch: PaymentProcessorConnectionPatch!
}

"""The output of our update \`AuditLog\` mutation."""
type UpdateAuditLogPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`AuditLog\` that was updated by this mutation."""
  auditLog: AuditLog

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`AuditLog\`. May be used by Relay 1."""
  auditLogEdge(
    """The method to use when ordering \`AuditLog\`."""
    orderBy: [AuditLogOrderBy!]! = [PRIMARY_KEY_ASC]
  ): AuditLogEdge
}

"""All input for the \`updateAuditLogById\` mutation."""
input UpdateAuditLogByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`AuditLog\` to be updated.
  """
  id: ID!

  """
  An object where the defined keys will be set on the \`AuditLog\` being updated.
  """
  patch: AuditLogPatch!
}

"""
Represents an update to a \`AuditLog\`. Fields that are set will be updated.
"""
input AuditLogPatch {
  rowId: UUID
  actorUserId: UUID
  actorIpAddress: String
  actorUserAgent: String
  organizationId: UUID
  targetEntityType: String
  targetEntityId: UUID
  action: AuditAction
  previousState: String
  newState: String
  metadata: String
  createdAt: Datetime
}

"""All input for the \`updateAuditLog\` mutation."""
input UpdateAuditLogInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the \`AuditLog\` being updated.
  """
  patch: AuditLogPatch!
}

"""The output of our update \`Post\` mutation."""
type UpdatePostPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Post\` that was updated by this mutation."""
  post: Post

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Post\`. May be used by Relay 1."""
  postEdge(
    """The method to use when ordering \`Post\`."""
    orderBy: [PostOrderBy!]! = [PRIMARY_KEY_ASC]
  ): PostEdge
}

"""All input for the \`updatePostById\` mutation."""
input UpdatePostByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`Post\` to be updated.
  """
  id: ID!

  """
  An object where the defined keys will be set on the \`Post\` being updated.
  """
  patch: PostPatch!
}

"""Represents an update to a \`Post\`. Fields that are set will be updated."""
input PostPatch {
  rowId: UUID
  organizationId: UUID
  authorId: UUID
  title: String
  content: String
  excerpt: String
  visibility: PostVisibility
  minimumTierId: UUID
  isPublished: Boolean
  publishedAt: Datetime
  createdAt: Datetime
  updatedAt: Datetime
  deletedAt: Datetime
}

"""All input for the \`updatePost\` mutation."""
input UpdatePostInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the \`Post\` being updated.
  """
  patch: PostPatch!
}

"""The output of our update \`GrantProgram\` mutation."""
type UpdateGrantProgramPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`GrantProgram\` that was updated by this mutation."""
  grantProgram: GrantProgram

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`GrantProgram\`. May be used by Relay 1."""
  grantProgramEdge(
    """The method to use when ordering \`GrantProgram\`."""
    orderBy: [GrantProgramOrderBy!]! = [PRIMARY_KEY_ASC]
  ): GrantProgramEdge
}

"""All input for the \`updateGrantProgramById\` mutation."""
input UpdateGrantProgramByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`GrantProgram\` to be updated.
  """
  id: ID!

  """
  An object where the defined keys will be set on the \`GrantProgram\` being updated.
  """
  patch: GrantProgramPatch!
}

"""
Represents an update to a \`GrantProgram\`. Fields that are set will be updated.
"""
input GrantProgramPatch {
  rowId: UUID
  organizationId: UUID
  name: String
  slug: String
  description: String
  guidelines: String
  totalBudget: BigFloat
  remainingBudget: BigFloat
  currency: String
  minGrantAmount: BigFloat
  maxGrantAmount: BigFloat
  isActive: Boolean
  applicationsOpenAt: Datetime
  applicationsCloseAt: Datetime
  createdAt: Datetime
  updatedAt: Datetime
  deletedAt: Datetime
}

"""All input for the \`updateGrantProgram\` mutation."""
input UpdateGrantProgramInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the \`GrantProgram\` being updated.
  """
  patch: GrantProgramPatch!
}

"""The output of our update \`Organization\` mutation."""
type UpdateOrganizationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Organization\` that was updated by this mutation."""
  organization: Organization

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Organization\`. May be used by Relay 1."""
  organizationEdge(
    """The method to use when ordering \`Organization\`."""
    orderBy: [OrganizationOrderBy!]! = [PRIMARY_KEY_ASC]
  ): OrganizationEdge
}

"""All input for the \`updateOrganizationById\` mutation."""
input UpdateOrganizationByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`Organization\` to be updated.
  """
  id: ID!

  """
  An object where the defined keys will be set on the \`Organization\` being updated.
  """
  patch: OrganizationPatch!
}

"""
Represents an update to a \`Organization\`. Fields that are set will be updated.
"""
input OrganizationPatch {
  rowId: UUID
  name: String
  slug: String
  description: String
  avatarUrl: String
  websiteUrl: String
  organizationType: OrganizationType
  platformFeePercent: BigFloat
  isVerified: Boolean
  verifiedAt: Datetime
  createdAt: Datetime
  updatedAt: Datetime
  deletedAt: Datetime
}

"""All input for the \`updateOrganization\` mutation."""
input UpdateOrganizationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the \`Organization\` being updated.
  """
  patch: OrganizationPatch!
}

"""All input for the \`updateOrganizationBySlug\` mutation."""
input UpdateOrganizationBySlugInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  slug: String!

  """
  An object where the defined keys will be set on the \`Organization\` being updated.
  """
  patch: OrganizationPatch!
}

"""The output of our update \`GrantApplication\` mutation."""
type UpdateGrantApplicationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`GrantApplication\` that was updated by this mutation."""
  grantApplication: GrantApplication

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`GrantApplication\`. May be used by Relay 1."""
  grantApplicationEdge(
    """The method to use when ordering \`GrantApplication\`."""
    orderBy: [GrantApplicationOrderBy!]! = [PRIMARY_KEY_ASC]
  ): GrantApplicationEdge
}

"""All input for the \`updateGrantApplicationById\` mutation."""
input UpdateGrantApplicationByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`GrantApplication\` to be updated.
  """
  id: ID!

  """
  An object where the defined keys will be set on the \`GrantApplication\` being updated.
  """
  patch: GrantApplicationPatch!
}

"""
Represents an update to a \`GrantApplication\`. Fields that are set will be updated.
"""
input GrantApplicationPatch {
  rowId: UUID
  grantProgramId: UUID
  applicantId: UUID
  title: String
  description: String
  proposedAmount: BigFloat
  currency: String
  approvedAmount: BigFloat
  status: GrantApplicationStatus
  submittedAt: Datetime
  reviewedAt: Datetime
  reviewedById: UUID
  reviewNotes: String
  createdAt: Datetime
  updatedAt: Datetime
}

"""All input for the \`updateGrantApplication\` mutation."""
input UpdateGrantApplicationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the \`GrantApplication\` being updated.
  """
  patch: GrantApplicationPatch!
}

"""The output of our update \`Payout\` mutation."""
type UpdatePayoutPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Payout\` that was updated by this mutation."""
  payout: Payout

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Payout\`. May be used by Relay 1."""
  payoutEdge(
    """The method to use when ordering \`Payout\`."""
    orderBy: [PayoutOrderBy!]! = [PRIMARY_KEY_ASC]
  ): PayoutEdge
}

"""All input for the \`updatePayoutById\` mutation."""
input UpdatePayoutByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`Payout\` to be updated.
  """
  id: ID!

  """
  An object where the defined keys will be set on the \`Payout\` being updated.
  """
  patch: PayoutPatch!
}

"""
Represents an update to a \`Payout\`. Fields that are set will be updated.
"""
input PayoutPatch {
  rowId: UUID
  recipientUserId: UUID
  fromOrganizationId: UUID
  processorConnectionId: UUID
  processor: PaymentProcessor
  externalPayoutId: String
  amount: BigFloat
  feeAmount: BigFloat
  currency: String
  status: TransactionStatus
  description: String
  failureReason: String
  initiatedAt: Datetime
  completedAt: Datetime
  createdAt: Datetime
  updatedAt: Datetime
}

"""All input for the \`updatePayout\` mutation."""
input UpdatePayoutInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the \`Payout\` being updated.
  """
  patch: PayoutPatch!
}

"""The output of our update \`GrantMilestone\` mutation."""
type UpdateGrantMilestonePayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`GrantMilestone\` that was updated by this mutation."""
  grantMilestone: GrantMilestone

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`GrantMilestone\`. May be used by Relay 1."""
  grantMilestoneEdge(
    """The method to use when ordering \`GrantMilestone\`."""
    orderBy: [GrantMilestoneOrderBy!]! = [PRIMARY_KEY_ASC]
  ): GrantMilestoneEdge
}

"""All input for the \`updateGrantMilestoneById\` mutation."""
input UpdateGrantMilestoneByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`GrantMilestone\` to be updated.
  """
  id: ID!

  """
  An object where the defined keys will be set on the \`GrantMilestone\` being updated.
  """
  patch: GrantMilestonePatch!
}

"""
Represents an update to a \`GrantMilestone\`. Fields that are set will be updated.
"""
input GrantMilestonePatch {
  rowId: UUID
  grantApplicationId: UUID
  title: String
  description: String
  sequenceOrder: Int
  amount: BigFloat
  currency: String
  status: GrantMilestoneStatus
  dueDate: Datetime
  submittedAt: Datetime
  approvedAt: Datetime
  paidAt: Datetime
  transactionId: UUID
  createdAt: Datetime
  updatedAt: Datetime
}

"""All input for the \`updateGrantMilestone\` mutation."""
input UpdateGrantMilestoneInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the \`GrantMilestone\` being updated.
  """
  patch: GrantMilestonePatch!
}

"""The output of our update \`Bounty\` mutation."""
type UpdateBountyPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Bounty\` that was updated by this mutation."""
  bounty: Bounty

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Bounty\`. May be used by Relay 1."""
  bountyEdge(
    """The method to use when ordering \`Bounty\`."""
    orderBy: [BountyOrderBy!]! = [PRIMARY_KEY_ASC]
  ): BountyEdge
}

"""All input for the \`updateBountyById\` mutation."""
input UpdateBountyByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`Bounty\` to be updated.
  """
  id: ID!

  """
  An object where the defined keys will be set on the \`Bounty\` being updated.
  """
  patch: BountyPatch!
}

"""
Represents an update to a \`Bounty\`. Fields that are set will be updated.
"""
input BountyPatch {
  rowId: UUID
  organizationId: UUID
  sourceType: BountySourceType
  externalUrl: String
  arborIssueId: UUID
  title: String
  description: String
  targetAmount: BigFloat
  currency: String
  status: BountyStatus
  claimantId: UUID
  claimedAt: Datetime
  completedAt: Datetime
  expiresAt: Datetime
  createdAt: Datetime
  updatedAt: Datetime
  deletedAt: Datetime
}

"""All input for the \`updateBounty\` mutation."""
input UpdateBountyInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the \`Bounty\` being updated.
  """
  patch: BountyPatch!
}

"""The output of our update \`Transaction\` mutation."""
type UpdateTransactionPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Transaction\` that was updated by this mutation."""
  transaction: Transaction

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Transaction\`. May be used by Relay 1."""
  transactionEdge(
    """The method to use when ordering \`Transaction\`."""
    orderBy: [TransactionOrderBy!]! = [PRIMARY_KEY_ASC]
  ): TransactionEdge
}

"""All input for the \`updateTransactionById\` mutation."""
input UpdateTransactionByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`Transaction\` to be updated.
  """
  id: ID!

  """
  An object where the defined keys will be set on the \`Transaction\` being updated.
  """
  patch: TransactionPatch!
}

"""
Represents an update to a \`Transaction\`. Fields that are set will be updated.
"""
input TransactionPatch {
  rowId: UUID
  fromUserId: UUID
  toOrganizationId: UUID
  toUserId: UUID
  processorConnectionId: UUID
  processor: PaymentProcessor
  externalTransactionId: String
  grossAmount: BigFloat
  platformFeeAmount: BigFloat
  processorFeeAmount: BigFloat
  netAmount: BigFloat
  currency: String
  transactionType: TransactionType
  status: TransactionStatus
  description: String
  metadata: String
  failureReason: String
  refundedAmount: BigFloat
  originalTransactionId: UUID
  processedAt: Datetime
  createdAt: Datetime
  updatedAt: Datetime
}

"""All input for the \`updateTransaction\` mutation."""
input UpdateTransactionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the \`Transaction\` being updated.
  """
  patch: TransactionPatch!
}

"""The output of our update \`Sponsorship\` mutation."""
type UpdateSponsorshipPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Sponsorship\` that was updated by this mutation."""
  sponsorship: Sponsorship

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Sponsorship\`. May be used by Relay 1."""
  sponsorshipEdge(
    """The method to use when ordering \`Sponsorship\`."""
    orderBy: [SponsorshipOrderBy!]! = [PRIMARY_KEY_ASC]
  ): SponsorshipEdge
}

"""All input for the \`updateSponsorshipById\` mutation."""
input UpdateSponsorshipByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`Sponsorship\` to be updated.
  """
  id: ID!

  """
  An object where the defined keys will be set on the \`Sponsorship\` being updated.
  """
  patch: SponsorshipPatch!
}

"""
Represents an update to a \`Sponsorship\`. Fields that are set will be updated.
"""
input SponsorshipPatch {
  rowId: UUID
  sponsorId: UUID
  organizationId: UUID
  tierId: UUID
  amount: BigFloat
  currency: String
  frequency: SponsorshipFrequency
  status: SponsorshipStatus
  currentPeriodStart: Datetime
  currentPeriodEnd: Datetime
  nextBillingDate: Datetime
  isPublic: Boolean
  publicMessage: String
  externalSubscriptionId: String
  startedAt: Datetime
  cancelledAt: Datetime
  createdAt: Datetime
  updatedAt: Datetime
}

"""All input for the \`updateSponsorship\` mutation."""
input UpdateSponsorshipInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the \`Sponsorship\` being updated.
  """
  patch: SponsorshipPatch!
}

"""The output of our delete \`UserOrganization\` mutation."""
type DeleteUserOrganizationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`UserOrganization\` that was deleted by this mutation."""
  userOrganization: UserOrganization
  deletedUserOrganizationId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`UserOrganization\`. May be used by Relay 1."""
  userOrganizationEdge(
    """The method to use when ordering \`UserOrganization\`."""
    orderBy: [UserOrganizationOrderBy!]! = [PRIMARY_KEY_ASC]
  ): UserOrganizationEdge
}

"""All input for the \`deleteUserOrganizationById\` mutation."""
input DeleteUserOrganizationByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`UserOrganization\` to be deleted.
  """
  id: ID!
}

"""All input for the \`deleteUserOrganization\` mutation."""
input DeleteUserOrganizationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete \`BountyFunding\` mutation."""
type DeleteBountyFundingPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`BountyFunding\` that was deleted by this mutation."""
  bountyFunding: BountyFunding
  deletedBountyFundingId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`BountyFunding\`. May be used by Relay 1."""
  bountyFundingEdge(
    """The method to use when ordering \`BountyFunding\`."""
    orderBy: [BountyFundingOrderBy!]! = [PRIMARY_KEY_ASC]
  ): BountyFundingEdge
}

"""All input for the \`deleteBountyFundingById\` mutation."""
input DeleteBountyFundingByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`BountyFunding\` to be deleted.
  """
  id: ID!
}

"""All input for the \`deleteBountyFunding\` mutation."""
input DeleteBountyFundingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete \`User\` mutation."""
type DeleteUserPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`User\` that was deleted by this mutation."""
  user: User
  deletedUserId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`User\`. May be used by Relay 1."""
  userEdge(
    """The method to use when ordering \`User\`."""
    orderBy: [UserOrderBy!]! = [PRIMARY_KEY_ASC]
  ): UserEdge
}

"""All input for the \`deleteUserById\` mutation."""
input DeleteUserByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`User\` to be deleted.
  """
  id: ID!
}

"""All input for the \`deleteUser\` mutation."""
input DeleteUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""All input for the \`deleteUserByUsername\` mutation."""
input DeleteUserByUsernameInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  username: String!
}

"""The output of our delete \`WebhookEndpoint\` mutation."""
type DeleteWebhookEndpointPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`WebhookEndpoint\` that was deleted by this mutation."""
  webhookEndpoint: WebhookEndpoint
  deletedWebhookEndpointId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`WebhookEndpoint\`. May be used by Relay 1."""
  webhookEndpointEdge(
    """The method to use when ordering \`WebhookEndpoint\`."""
    orderBy: [WebhookEndpointOrderBy!]! = [PRIMARY_KEY_ASC]
  ): WebhookEndpointEdge
}

"""All input for the \`deleteWebhookEndpointById\` mutation."""
input DeleteWebhookEndpointByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`WebhookEndpoint\` to be deleted.
  """
  id: ID!
}

"""All input for the \`deleteWebhookEndpoint\` mutation."""
input DeleteWebhookEndpointInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete \`Workspace\` mutation."""
type DeleteWorkspacePayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Workspace\` that was deleted by this mutation."""
  workspace: Workspace
  deletedWorkspaceId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Workspace\`. May be used by Relay 1."""
  workspaceEdge(
    """The method to use when ordering \`Workspace\`."""
    orderBy: [WorkspaceOrderBy!]! = [PRIMARY_KEY_ASC]
  ): WorkspaceEdge
}

"""All input for the \`deleteWorkspaceById\` mutation."""
input DeleteWorkspaceByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`Workspace\` to be deleted.
  """
  id: ID!
}

"""All input for the \`deleteWorkspace\` mutation."""
input DeleteWorkspaceInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete \`Donation\` mutation."""
type DeleteDonationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Donation\` that was deleted by this mutation."""
  donation: Donation
  deletedDonationId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Donation\`. May be used by Relay 1."""
  donationEdge(
    """The method to use when ordering \`Donation\`."""
    orderBy: [DonationOrderBy!]! = [PRIMARY_KEY_ASC]
  ): DonationEdge
}

"""All input for the \`deleteDonationById\` mutation."""
input DeleteDonationByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`Donation\` to be deleted.
  """
  id: ID!
}

"""All input for the \`deleteDonation\` mutation."""
input DeleteDonationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete \`Goal\` mutation."""
type DeleteGoalPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Goal\` that was deleted by this mutation."""
  goal: Goal
  deletedGoalId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Goal\`. May be used by Relay 1."""
  goalEdge(
    """The method to use when ordering \`Goal\`."""
    orderBy: [GoalOrderBy!]! = [PRIMARY_KEY_ASC]
  ): GoalEdge
}

"""All input for the \`deleteGoalById\` mutation."""
input DeleteGoalByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`Goal\` to be deleted.
  """
  id: ID!
}

"""All input for the \`deleteGoal\` mutation."""
input DeleteGoalInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete \`UserIdentity\` mutation."""
type DeleteUserIdentityPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`UserIdentity\` that was deleted by this mutation."""
  userIdentity: UserIdentity
  deletedUserIdentityId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`UserIdentity\`. May be used by Relay 1."""
  userIdentityEdge(
    """The method to use when ordering \`UserIdentity\`."""
    orderBy: [UserIdentityOrderBy!]! = [PRIMARY_KEY_ASC]
  ): UserIdentityEdge
}

"""All input for the \`deleteUserIdentityById\` mutation."""
input DeleteUserIdentityByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`UserIdentity\` to be deleted.
  """
  id: ID!
}

"""All input for the \`deleteUserIdentity\` mutation."""
input DeleteUserIdentityInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete \`WebhookDelivery\` mutation."""
type DeleteWebhookDeliveryPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`WebhookDelivery\` that was deleted by this mutation."""
  webhookDelivery: WebhookDelivery
  deletedWebhookDeliveryId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`WebhookDelivery\`. May be used by Relay 1."""
  webhookDeliveryEdge(
    """The method to use when ordering \`WebhookDelivery\`."""
    orderBy: [WebhookDeliveryOrderBy!]! = [PRIMARY_KEY_ASC]
  ): WebhookDeliveryEdge
}

"""All input for the \`deleteWebhookDeliveryById\` mutation."""
input DeleteWebhookDeliveryByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`WebhookDelivery\` to be deleted.
  """
  id: ID!
}

"""All input for the \`deleteWebhookDelivery\` mutation."""
input DeleteWebhookDeliveryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete \`SponsorshipTier\` mutation."""
type DeleteSponsorshipTierPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`SponsorshipTier\` that was deleted by this mutation."""
  sponsorshipTier: SponsorshipTier
  deletedSponsorshipTierId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`SponsorshipTier\`. May be used by Relay 1."""
  sponsorshipTierEdge(
    """The method to use when ordering \`SponsorshipTier\`."""
    orderBy: [SponsorshipTierOrderBy!]! = [PRIMARY_KEY_ASC]
  ): SponsorshipTierEdge
}

"""All input for the \`deleteSponsorshipTierById\` mutation."""
input DeleteSponsorshipTierByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`SponsorshipTier\` to be deleted.
  """
  id: ID!
}

"""All input for the \`deleteSponsorshipTier\` mutation."""
input DeleteSponsorshipTierInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete \`PaymentProcessorConnection\` mutation."""
type DeletePaymentProcessorConnectionPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`PaymentProcessorConnection\` that was deleted by this mutation."""
  paymentProcessorConnection: PaymentProcessorConnection
  deletedPaymentProcessorConnectionId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`PaymentProcessorConnection\`. May be used by Relay 1."""
  paymentProcessorConnectionEdge(
    """The method to use when ordering \`PaymentProcessorConnection\`."""
    orderBy: [PaymentProcessorConnectionOrderBy!]! = [PRIMARY_KEY_ASC]
  ): PaymentProcessorConnectionEdge
}

"""All input for the \`deletePaymentProcessorConnectionById\` mutation."""
input DeletePaymentProcessorConnectionByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`PaymentProcessorConnection\` to be deleted.
  """
  id: ID!
}

"""All input for the \`deletePaymentProcessorConnection\` mutation."""
input DeletePaymentProcessorConnectionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete \`AuditLog\` mutation."""
type DeleteAuditLogPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`AuditLog\` that was deleted by this mutation."""
  auditLog: AuditLog
  deletedAuditLogId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`AuditLog\`. May be used by Relay 1."""
  auditLogEdge(
    """The method to use when ordering \`AuditLog\`."""
    orderBy: [AuditLogOrderBy!]! = [PRIMARY_KEY_ASC]
  ): AuditLogEdge
}

"""All input for the \`deleteAuditLogById\` mutation."""
input DeleteAuditLogByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`AuditLog\` to be deleted.
  """
  id: ID!
}

"""All input for the \`deleteAuditLog\` mutation."""
input DeleteAuditLogInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete \`Post\` mutation."""
type DeletePostPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Post\` that was deleted by this mutation."""
  post: Post
  deletedPostId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Post\`. May be used by Relay 1."""
  postEdge(
    """The method to use when ordering \`Post\`."""
    orderBy: [PostOrderBy!]! = [PRIMARY_KEY_ASC]
  ): PostEdge
}

"""All input for the \`deletePostById\` mutation."""
input DeletePostByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`Post\` to be deleted.
  """
  id: ID!
}

"""All input for the \`deletePost\` mutation."""
input DeletePostInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete \`GrantProgram\` mutation."""
type DeleteGrantProgramPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`GrantProgram\` that was deleted by this mutation."""
  grantProgram: GrantProgram
  deletedGrantProgramId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`GrantProgram\`. May be used by Relay 1."""
  grantProgramEdge(
    """The method to use when ordering \`GrantProgram\`."""
    orderBy: [GrantProgramOrderBy!]! = [PRIMARY_KEY_ASC]
  ): GrantProgramEdge
}

"""All input for the \`deleteGrantProgramById\` mutation."""
input DeleteGrantProgramByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`GrantProgram\` to be deleted.
  """
  id: ID!
}

"""All input for the \`deleteGrantProgram\` mutation."""
input DeleteGrantProgramInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete \`Organization\` mutation."""
type DeleteOrganizationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Organization\` that was deleted by this mutation."""
  organization: Organization
  deletedOrganizationId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Organization\`. May be used by Relay 1."""
  organizationEdge(
    """The method to use when ordering \`Organization\`."""
    orderBy: [OrganizationOrderBy!]! = [PRIMARY_KEY_ASC]
  ): OrganizationEdge
}

"""All input for the \`deleteOrganizationById\` mutation."""
input DeleteOrganizationByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`Organization\` to be deleted.
  """
  id: ID!
}

"""All input for the \`deleteOrganization\` mutation."""
input DeleteOrganizationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""All input for the \`deleteOrganizationBySlug\` mutation."""
input DeleteOrganizationBySlugInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  slug: String!
}

"""The output of our delete \`GrantApplication\` mutation."""
type DeleteGrantApplicationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`GrantApplication\` that was deleted by this mutation."""
  grantApplication: GrantApplication
  deletedGrantApplicationId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`GrantApplication\`. May be used by Relay 1."""
  grantApplicationEdge(
    """The method to use when ordering \`GrantApplication\`."""
    orderBy: [GrantApplicationOrderBy!]! = [PRIMARY_KEY_ASC]
  ): GrantApplicationEdge
}

"""All input for the \`deleteGrantApplicationById\` mutation."""
input DeleteGrantApplicationByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`GrantApplication\` to be deleted.
  """
  id: ID!
}

"""All input for the \`deleteGrantApplication\` mutation."""
input DeleteGrantApplicationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete \`Payout\` mutation."""
type DeletePayoutPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Payout\` that was deleted by this mutation."""
  payout: Payout
  deletedPayoutId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Payout\`. May be used by Relay 1."""
  payoutEdge(
    """The method to use when ordering \`Payout\`."""
    orderBy: [PayoutOrderBy!]! = [PRIMARY_KEY_ASC]
  ): PayoutEdge
}

"""All input for the \`deletePayoutById\` mutation."""
input DeletePayoutByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`Payout\` to be deleted.
  """
  id: ID!
}

"""All input for the \`deletePayout\` mutation."""
input DeletePayoutInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete \`GrantMilestone\` mutation."""
type DeleteGrantMilestonePayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`GrantMilestone\` that was deleted by this mutation."""
  grantMilestone: GrantMilestone
  deletedGrantMilestoneId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`GrantMilestone\`. May be used by Relay 1."""
  grantMilestoneEdge(
    """The method to use when ordering \`GrantMilestone\`."""
    orderBy: [GrantMilestoneOrderBy!]! = [PRIMARY_KEY_ASC]
  ): GrantMilestoneEdge
}

"""All input for the \`deleteGrantMilestoneById\` mutation."""
input DeleteGrantMilestoneByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`GrantMilestone\` to be deleted.
  """
  id: ID!
}

"""All input for the \`deleteGrantMilestone\` mutation."""
input DeleteGrantMilestoneInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete \`Bounty\` mutation."""
type DeleteBountyPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Bounty\` that was deleted by this mutation."""
  bounty: Bounty
  deletedBountyId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Bounty\`. May be used by Relay 1."""
  bountyEdge(
    """The method to use when ordering \`Bounty\`."""
    orderBy: [BountyOrderBy!]! = [PRIMARY_KEY_ASC]
  ): BountyEdge
}

"""All input for the \`deleteBountyById\` mutation."""
input DeleteBountyByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`Bounty\` to be deleted.
  """
  id: ID!
}

"""All input for the \`deleteBounty\` mutation."""
input DeleteBountyInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete \`Transaction\` mutation."""
type DeleteTransactionPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Transaction\` that was deleted by this mutation."""
  transaction: Transaction
  deletedTransactionId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Transaction\`. May be used by Relay 1."""
  transactionEdge(
    """The method to use when ordering \`Transaction\`."""
    orderBy: [TransactionOrderBy!]! = [PRIMARY_KEY_ASC]
  ): TransactionEdge
}

"""All input for the \`deleteTransactionById\` mutation."""
input DeleteTransactionByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`Transaction\` to be deleted.
  """
  id: ID!
}

"""All input for the \`deleteTransaction\` mutation."""
input DeleteTransactionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete \`Sponsorship\` mutation."""
type DeleteSponsorshipPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Sponsorship\` that was deleted by this mutation."""
  sponsorship: Sponsorship
  deletedSponsorshipId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Sponsorship\`. May be used by Relay 1."""
  sponsorshipEdge(
    """The method to use when ordering \`Sponsorship\`."""
    orderBy: [SponsorshipOrderBy!]! = [PRIMARY_KEY_ASC]
  ): SponsorshipEdge
}

"""All input for the \`deleteSponsorshipById\` mutation."""
input DeleteSponsorshipByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique \`ID\` which will identify a single \`Sponsorship\` to be deleted.
  """
  id: ID!
}

"""All input for the \`deleteSponsorship\` mutation."""
input DeleteSponsorshipInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}`;
export const objects = {
  Query: {
    assertStep() {
      return !0;
    },
    plans: {
      auditLog(_$root, {
        $rowId
      }) {
        return resource_audit_logPgResource.get({
          id: $rowId
        });
      },
      auditLogById(_$parent, args) {
        const $nodeId = args.getRaw("id");
        return nodeFetcher_AuditLog($nodeId);
      },
      auditLogs: {
        plan() {
          return connection(resource_audit_logPgResource.find());
        },
        args: {
          first(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          },
          last(_, $connection, val) {
            $connection.setLast(val.getRaw());
          },
          offset(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          },
          before(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          },
          after(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          },
          condition(_condition, $connection, arg) {
            const $select = $connection.getSubplan();
            arg.apply($select, qbWhereBuilder);
          },
          filter(_, $connection, fieldArg) {
            const $pgSelect = $connection.getSubplan();
            fieldArg.apply($pgSelect, (queryBuilder, value) => {
              assertAllowed12(value, "object");
              if (value == null) return;
              const condition = new PgCondition(queryBuilder);
              return condition;
            });
          },
          orderBy(parent, $connection, value) {
            const $select = $connection.getSubplan();
            value.apply($select);
          }
        }
      },
      bounties: {
        plan() {
          return connection(resource_bountyPgResource.find());
        },
        args: {
          first(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          },
          last(_, $connection, val) {
            $connection.setLast(val.getRaw());
          },
          offset(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          },
          before(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          },
          after(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          },
          condition(_condition, $connection, arg) {
            const $select = $connection.getSubplan();
            arg.apply($select, qbWhereBuilder);
          },
          filter(_, $connection, fieldArg) {
            const $pgSelect = $connection.getSubplan();
            fieldArg.apply($pgSelect, (queryBuilder, value) => {
              assertAllowed19(value, "object");
              if (value == null) return;
              const condition = new PgCondition(queryBuilder);
              return condition;
            });
          },
          orderBy(parent, $connection, value) {
            const $select = $connection.getSubplan();
            value.apply($select);
          }
        }
      },
      bounty(_$root, {
        $rowId
      }) {
        return resource_bountyPgResource.get({
          id: $rowId
        });
      },
      bountyById(_$parent, args) {
        const $nodeId = args.getRaw("id");
        return nodeFetcher_Bounty($nodeId);
      },
      bountyFunding(_$root, {
        $rowId
      }) {
        return resource_bounty_fundingPgResource.get({
          id: $rowId
        });
      },
      bountyFundingById(_$parent, args) {
        const $nodeId = args.getRaw("id");
        return nodeFetcher_BountyFunding($nodeId);
      },
      bountyFundings: {
        plan() {
          return connection(resource_bounty_fundingPgResource.find());
        },
        args: {
          first(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          },
          last(_, $connection, val) {
            $connection.setLast(val.getRaw());
          },
          offset(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          },
          before(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          },
          after(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          },
          condition(_condition, $connection, arg) {
            const $select = $connection.getSubplan();
            arg.apply($select, qbWhereBuilder);
          },
          filter(_, $connection, fieldArg) {
            const $pgSelect = $connection.getSubplan();
            fieldArg.apply($pgSelect, (queryBuilder, value) => {
              assertAllowed2(value, "object");
              if (value == null) return;
              const condition = new PgCondition(queryBuilder);
              return condition;
            });
          },
          orderBy(parent, $connection, value) {
            const $select = $connection.getSubplan();
            value.apply($select);
          }
        }
      },
      donation(_$root, {
        $rowId
      }) {
        return resource_donationPgResource.get({
          id: $rowId
        });
      },
      donationById(_$parent, args) {
        const $nodeId = args.getRaw("id");
        return nodeFetcher_Donation($nodeId);
      },
      donations: {
        plan() {
          return connection(resource_donationPgResource.find());
        },
        args: {
          first(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          },
          last(_, $connection, val) {
            $connection.setLast(val.getRaw());
          },
          offset(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          },
          before(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          },
          after(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          },
          condition(_condition, $connection, arg) {
            const $select = $connection.getSubplan();
            arg.apply($select, qbWhereBuilder);
          },
          filter(_, $connection, fieldArg) {
            const $pgSelect = $connection.getSubplan();
            fieldArg.apply($pgSelect, (queryBuilder, value) => {
              assertAllowed6(value, "object");
              if (value == null) return;
              const condition = new PgCondition(queryBuilder);
              return condition;
            });
          },
          orderBy(parent, $connection, value) {
            const $select = $connection.getSubplan();
            value.apply($select);
          }
        }
      },
      goal(_$root, {
        $rowId
      }) {
        return resource_goalPgResource.get({
          id: $rowId
        });
      },
      goalById(_$parent, args) {
        const $nodeId = args.getRaw("id");
        return nodeFetcher_Goal($nodeId);
      },
      goals: {
        plan() {
          return connection(resource_goalPgResource.find());
        },
        args: {
          first(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          },
          last(_, $connection, val) {
            $connection.setLast(val.getRaw());
          },
          offset(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          },
          before(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          },
          after(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          },
          condition(_condition, $connection, arg) {
            const $select = $connection.getSubplan();
            arg.apply($select, qbWhereBuilder);
          },
          filter(_, $connection, fieldArg) {
            const $pgSelect = $connection.getSubplan();
            fieldArg.apply($pgSelect, (queryBuilder, value) => {
              assertAllowed7(value, "object");
              if (value == null) return;
              const condition = new PgCondition(queryBuilder);
              return condition;
            });
          },
          orderBy(parent, $connection, value) {
            const $select = $connection.getSubplan();
            value.apply($select);
          }
        }
      },
      grantApplication(_$root, {
        $rowId
      }) {
        return resource_grant_applicationPgResource.get({
          id: $rowId
        });
      },
      grantApplicationById(_$parent, args) {
        const $nodeId = args.getRaw("id");
        return nodeFetcher_GrantApplication($nodeId);
      },
      grantApplications: {
        plan() {
          return connection(resource_grant_applicationPgResource.find());
        },
        args: {
          first(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          },
          last(_, $connection, val) {
            $connection.setLast(val.getRaw());
          },
          offset(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          },
          before(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          },
          after(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          },
          condition(_condition, $connection, arg) {
            const $select = $connection.getSubplan();
            arg.apply($select, qbWhereBuilder);
          },
          filter(_, $connection, fieldArg) {
            const $pgSelect = $connection.getSubplan();
            fieldArg.apply($pgSelect, (queryBuilder, value) => {
              assertAllowed16(value, "object");
              if (value == null) return;
              const condition = new PgCondition(queryBuilder);
              return condition;
            });
          },
          orderBy(parent, $connection, value) {
            const $select = $connection.getSubplan();
            value.apply($select);
          }
        }
      },
      grantMilestone(_$root, {
        $rowId
      }) {
        return resource_grant_milestonePgResource.get({
          id: $rowId
        });
      },
      grantMilestoneById(_$parent, args) {
        const $nodeId = args.getRaw("id");
        return nodeFetcher_GrantMilestone($nodeId);
      },
      grantMilestones: {
        plan() {
          return connection(resource_grant_milestonePgResource.find());
        },
        args: {
          first(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          },
          last(_, $connection, val) {
            $connection.setLast(val.getRaw());
          },
          offset(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          },
          before(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          },
          after(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          },
          condition(_condition, $connection, arg) {
            const $select = $connection.getSubplan();
            arg.apply($select, qbWhereBuilder);
          },
          filter(_, $connection, fieldArg) {
            const $pgSelect = $connection.getSubplan();
            fieldArg.apply($pgSelect, (queryBuilder, value) => {
              assertAllowed18(value, "object");
              if (value == null) return;
              const condition = new PgCondition(queryBuilder);
              return condition;
            });
          },
          orderBy(parent, $connection, value) {
            const $select = $connection.getSubplan();
            value.apply($select);
          }
        }
      },
      grantProgram(_$root, {
        $rowId
      }) {
        return resource_grant_programPgResource.get({
          id: $rowId
        });
      },
      grantProgramById(_$parent, args) {
        const $nodeId = args.getRaw("id");
        return nodeFetcher_GrantProgram($nodeId);
      },
      grantPrograms: {
        plan() {
          return connection(resource_grant_programPgResource.find());
        },
        args: {
          first(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          },
          last(_, $connection, val) {
            $connection.setLast(val.getRaw());
          },
          offset(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          },
          before(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          },
          after(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          },
          condition(_condition, $connection, arg) {
            const $select = $connection.getSubplan();
            arg.apply($select, qbWhereBuilder);
          },
          filter(_, $connection, fieldArg) {
            const $pgSelect = $connection.getSubplan();
            fieldArg.apply($pgSelect, (queryBuilder, value) => {
              assertAllowed14(value, "object");
              if (value == null) return;
              const condition = new PgCondition(queryBuilder);
              return condition;
            });
          },
          orderBy(parent, $connection, value) {
            const $select = $connection.getSubplan();
            value.apply($select);
          }
        }
      },
      id($parent) {
        const specifier = nodeIdHandler_Query.plan($parent);
        return lambda(specifier, nodeIdCodecs[nodeIdHandler_Query.codec.name].encode);
      },
      node(_$root, fieldArgs) {
        return fieldArgs.getRaw("id");
      },
      organization(_$root, {
        $rowId
      }) {
        return resource_organizationPgResource.get({
          id: $rowId
        });
      },
      organizationById(_$parent, args) {
        const $nodeId = args.getRaw("id");
        return nodeFetcher_Organization($nodeId);
      },
      organizationBySlug(_$root, {
        $slug
      }) {
        return resource_organizationPgResource.get({
          slug: $slug
        });
      },
      organizations: {
        plan() {
          return connection(resource_organizationPgResource.find());
        },
        args: {
          first(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          },
          last(_, $connection, val) {
            $connection.setLast(val.getRaw());
          },
          offset(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          },
          before(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          },
          after(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          },
          condition(_condition, $connection, arg) {
            const $select = $connection.getSubplan();
            arg.apply($select, qbWhereBuilder);
          },
          filter(_, $connection, fieldArg) {
            const $pgSelect = $connection.getSubplan();
            fieldArg.apply($pgSelect, (queryBuilder, value) => {
              assertAllowed15(value, "object");
              if (value == null) return;
              const condition = new PgCondition(queryBuilder);
              return condition;
            });
          },
          orderBy(parent, $connection, value) {
            const $select = $connection.getSubplan();
            value.apply($select);
          }
        }
      },
      paymentProcessorConnection(_$root, {
        $rowId
      }) {
        return resource_payment_processor_connectionPgResource.get({
          id: $rowId
        });
      },
      paymentProcessorConnectionById(_$parent, args) {
        const $nodeId = args.getRaw("id");
        return nodeFetcher_PaymentProcessorConnection($nodeId);
      },
      paymentProcessorConnections: {
        plan() {
          return connection(resource_payment_processor_connectionPgResource.find());
        },
        args: {
          first(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          },
          last(_, $connection, val) {
            $connection.setLast(val.getRaw());
          },
          offset(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          },
          before(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          },
          after(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          },
          condition(_condition, $connection, arg) {
            const $select = $connection.getSubplan();
            arg.apply($select, qbWhereBuilder);
          },
          filter(_, $connection, fieldArg) {
            const $pgSelect = $connection.getSubplan();
            fieldArg.apply($pgSelect, (queryBuilder, value) => {
              assertAllowed11(value, "object");
              if (value == null) return;
              const condition = new PgCondition(queryBuilder);
              return condition;
            });
          },
          orderBy(parent, $connection, value) {
            const $select = $connection.getSubplan();
            value.apply($select);
          }
        }
      },
      payout(_$root, {
        $rowId
      }) {
        return resource_payoutPgResource.get({
          id: $rowId
        });
      },
      payoutById(_$parent, args) {
        const $nodeId = args.getRaw("id");
        return nodeFetcher_Payout($nodeId);
      },
      payouts: {
        plan() {
          return connection(resource_payoutPgResource.find());
        },
        args: {
          first(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          },
          last(_, $connection, val) {
            $connection.setLast(val.getRaw());
          },
          offset(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          },
          before(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          },
          after(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          },
          condition(_condition, $connection, arg) {
            const $select = $connection.getSubplan();
            arg.apply($select, qbWhereBuilder);
          },
          filter(_, $connection, fieldArg) {
            const $pgSelect = $connection.getSubplan();
            fieldArg.apply($pgSelect, (queryBuilder, value) => {
              assertAllowed17(value, "object");
              if (value == null) return;
              const condition = new PgCondition(queryBuilder);
              return condition;
            });
          },
          orderBy(parent, $connection, value) {
            const $select = $connection.getSubplan();
            value.apply($select);
          }
        }
      },
      post(_$root, {
        $rowId
      }) {
        return resource_postPgResource.get({
          id: $rowId
        });
      },
      postById(_$parent, args) {
        const $nodeId = args.getRaw("id");
        return nodeFetcher_Post($nodeId);
      },
      posts: {
        plan() {
          return connection(resource_postPgResource.find());
        },
        args: {
          first(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          },
          last(_, $connection, val) {
            $connection.setLast(val.getRaw());
          },
          offset(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          },
          before(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          },
          after(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          },
          condition(_condition, $connection, arg) {
            const $select = $connection.getSubplan();
            arg.apply($select, qbWhereBuilder);
          },
          filter(_, $connection, fieldArg) {
            const $pgSelect = $connection.getSubplan();
            fieldArg.apply($pgSelect, (queryBuilder, value) => {
              assertAllowed13(value, "object");
              if (value == null) return;
              const condition = new PgCondition(queryBuilder);
              return condition;
            });
          },
          orderBy(parent, $connection, value) {
            const $select = $connection.getSubplan();
            value.apply($select);
          }
        }
      },
      query() {
        return rootValue();
      },
      sponsorship(_$root, {
        $rowId
      }) {
        return resource_sponsorshipPgResource.get({
          id: $rowId
        });
      },
      sponsorshipById(_$parent, args) {
        const $nodeId = args.getRaw("id");
        return nodeFetcher_Sponsorship($nodeId);
      },
      sponsorships: {
        plan() {
          return connection(resource_sponsorshipPgResource.find());
        },
        args: {
          first(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          },
          last(_, $connection, val) {
            $connection.setLast(val.getRaw());
          },
          offset(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          },
          before(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          },
          after(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          },
          condition(_condition, $connection, arg) {
            const $select = $connection.getSubplan();
            arg.apply($select, qbWhereBuilder);
          },
          filter(_, $connection, fieldArg) {
            const $pgSelect = $connection.getSubplan();
            fieldArg.apply($pgSelect, (queryBuilder, value) => {
              assertAllowed21(value, "object");
              if (value == null) return;
              const condition = new PgCondition(queryBuilder);
              return condition;
            });
          },
          orderBy(parent, $connection, value) {
            const $select = $connection.getSubplan();
            value.apply($select);
          }
        }
      },
      sponsorshipTier(_$root, {
        $rowId
      }) {
        return resource_sponsorship_tierPgResource.get({
          id: $rowId
        });
      },
      sponsorshipTierById(_$parent, args) {
        const $nodeId = args.getRaw("id");
        return nodeFetcher_SponsorshipTier($nodeId);
      },
      sponsorshipTiers: {
        plan() {
          return connection(resource_sponsorship_tierPgResource.find());
        },
        args: {
          first(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          },
          last(_, $connection, val) {
            $connection.setLast(val.getRaw());
          },
          offset(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          },
          before(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          },
          after(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          },
          condition(_condition, $connection, arg) {
            const $select = $connection.getSubplan();
            arg.apply($select, qbWhereBuilder);
          },
          filter(_, $connection, fieldArg) {
            const $pgSelect = $connection.getSubplan();
            fieldArg.apply($pgSelect, (queryBuilder, value) => {
              assertAllowed10(value, "object");
              if (value == null) return;
              const condition = new PgCondition(queryBuilder);
              return condition;
            });
          },
          orderBy(parent, $connection, value) {
            const $select = $connection.getSubplan();
            value.apply($select);
          }
        }
      },
      transaction(_$root, {
        $rowId
      }) {
        return resource_transactionPgResource.get({
          id: $rowId
        });
      },
      transactionById(_$parent, args) {
        const $nodeId = args.getRaw("id");
        return nodeFetcher_Transaction($nodeId);
      },
      transactions: {
        plan() {
          return connection(resource_transactionPgResource.find());
        },
        args: {
          first(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          },
          last(_, $connection, val) {
            $connection.setLast(val.getRaw());
          },
          offset(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          },
          before(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          },
          after(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          },
          condition(_condition, $connection, arg) {
            const $select = $connection.getSubplan();
            arg.apply($select, qbWhereBuilder);
          },
          filter(_, $connection, fieldArg) {
            const $pgSelect = $connection.getSubplan();
            fieldArg.apply($pgSelect, (queryBuilder, value) => {
              assertAllowed20(value, "object");
              if (value == null) return;
              const condition = new PgCondition(queryBuilder);
              return condition;
            });
          },
          orderBy(parent, $connection, value) {
            const $select = $connection.getSubplan();
            value.apply($select);
          }
        }
      },
      user(_$root, {
        $rowId
      }) {
        return resource_userPgResource.get({
          id: $rowId
        });
      },
      userById(_$parent, args) {
        const $nodeId = args.getRaw("id");
        return nodeFetcher_User($nodeId);
      },
      userByUsername(_$root, {
        $username
      }) {
        return resource_userPgResource.get({
          username: $username
        });
      },
      userIdentities: {
        plan() {
          return connection(resource_user_identityPgResource.find());
        },
        args: {
          first(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          },
          last(_, $connection, val) {
            $connection.setLast(val.getRaw());
          },
          offset(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          },
          before(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          },
          after(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          },
          condition(_condition, $connection, arg) {
            const $select = $connection.getSubplan();
            arg.apply($select, qbWhereBuilder);
          },
          filter(_, $connection, fieldArg) {
            const $pgSelect = $connection.getSubplan();
            fieldArg.apply($pgSelect, (queryBuilder, value) => {
              assertAllowed8(value, "object");
              if (value == null) return;
              const condition = new PgCondition(queryBuilder);
              return condition;
            });
          },
          orderBy(parent, $connection, value) {
            const $select = $connection.getSubplan();
            value.apply($select);
          }
        }
      },
      userIdentity(_$root, {
        $rowId
      }) {
        return resource_user_identityPgResource.get({
          id: $rowId
        });
      },
      userIdentityById(_$parent, args) {
        const $nodeId = args.getRaw("id");
        return nodeFetcher_UserIdentity($nodeId);
      },
      userOrganization(_$root, {
        $rowId
      }) {
        return resource_user_organizationPgResource.get({
          id: $rowId
        });
      },
      userOrganizationById(_$parent, args) {
        const $nodeId = args.getRaw("id");
        return nodeFetcher_UserOrganization($nodeId);
      },
      userOrganizations: {
        plan() {
          return connection(resource_user_organizationPgResource.find());
        },
        args: {
          first(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          },
          last(_, $connection, val) {
            $connection.setLast(val.getRaw());
          },
          offset(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          },
          before(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          },
          after(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          },
          condition(_condition, $connection, arg) {
            const $select = $connection.getSubplan();
            arg.apply($select, qbWhereBuilder);
          },
          filter(_, $connection, fieldArg) {
            const $pgSelect = $connection.getSubplan();
            fieldArg.apply($pgSelect, (queryBuilder, value) => {
              assertAllowed(value, "object");
              if (value == null) return;
              const condition = new PgCondition(queryBuilder);
              return condition;
            });
          },
          orderBy(parent, $connection, value) {
            const $select = $connection.getSubplan();
            value.apply($select);
          }
        }
      },
      users: {
        plan() {
          return connection(resource_userPgResource.find());
        },
        args: {
          first(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          },
          last(_, $connection, val) {
            $connection.setLast(val.getRaw());
          },
          offset(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          },
          before(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          },
          after(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          },
          condition(_condition, $connection, arg) {
            const $select = $connection.getSubplan();
            arg.apply($select, qbWhereBuilder);
          },
          filter(_, $connection, fieldArg) {
            const $pgSelect = $connection.getSubplan();
            fieldArg.apply($pgSelect, (queryBuilder, value) => {
              assertAllowed3(value, "object");
              if (value == null) return;
              const condition = new PgCondition(queryBuilder);
              return condition;
            });
          },
          orderBy(parent, $connection, value) {
            const $select = $connection.getSubplan();
            value.apply($select);
          }
        }
      },
      webhookDeliveries: {
        plan() {
          return connection(resource_webhook_deliveryPgResource.find());
        },
        args: {
          first(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          },
          last(_, $connection, val) {
            $connection.setLast(val.getRaw());
          },
          offset(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          },
          before(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          },
          after(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          },
          condition(_condition, $connection, arg) {
            const $select = $connection.getSubplan();
            arg.apply($select, qbWhereBuilder);
          },
          filter(_, $connection, fieldArg) {
            const $pgSelect = $connection.getSubplan();
            fieldArg.apply($pgSelect, (queryBuilder, value) => {
              assertAllowed9(value, "object");
              if (value == null) return;
              const condition = new PgCondition(queryBuilder);
              return condition;
            });
          },
          orderBy(parent, $connection, value) {
            const $select = $connection.getSubplan();
            value.apply($select);
          }
        }
      },
      webhookDelivery(_$root, {
        $rowId
      }) {
        return resource_webhook_deliveryPgResource.get({
          id: $rowId
        });
      },
      webhookDeliveryById(_$parent, args) {
        const $nodeId = args.getRaw("id");
        return nodeFetcher_WebhookDelivery($nodeId);
      },
      webhookEndpoint(_$root, {
        $rowId
      }) {
        return resource_webhook_endpointPgResource.get({
          id: $rowId
        });
      },
      webhookEndpointById(_$parent, args) {
        const $nodeId = args.getRaw("id");
        return nodeFetcher_WebhookEndpoint($nodeId);
      },
      webhookEndpoints: {
        plan() {
          return connection(resource_webhook_endpointPgResource.find());
        },
        args: {
          first(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          },
          last(_, $connection, val) {
            $connection.setLast(val.getRaw());
          },
          offset(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          },
          before(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          },
          after(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          },
          condition(_condition, $connection, arg) {
            const $select = $connection.getSubplan();
            arg.apply($select, qbWhereBuilder);
          },
          filter(_, $connection, fieldArg) {
            const $pgSelect = $connection.getSubplan();
            fieldArg.apply($pgSelect, (queryBuilder, value) => {
              assertAllowed4(value, "object");
              if (value == null) return;
              const condition = new PgCondition(queryBuilder);
              return condition;
            });
          },
          orderBy(parent, $connection, value) {
            const $select = $connection.getSubplan();
            value.apply($select);
          }
        }
      },
      workspace(_$root, {
        $rowId
      }) {
        return resource_workspacePgResource.get({
          id: $rowId
        });
      },
      workspaceById(_$parent, args) {
        const $nodeId = args.getRaw("id");
        return nodeFetcher_Workspace($nodeId);
      },
      workspaces: {
        plan() {
          return connection(resource_workspacePgResource.find());
        },
        args: {
          first(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          },
          last(_, $connection, val) {
            $connection.setLast(val.getRaw());
          },
          offset(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          },
          before(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          },
          after(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          },
          condition(_condition, $connection, arg) {
            const $select = $connection.getSubplan();
            arg.apply($select, qbWhereBuilder);
          },
          filter(_, $connection, fieldArg) {
            const $pgSelect = $connection.getSubplan();
            fieldArg.apply($pgSelect, (queryBuilder, value) => {
              assertAllowed5(value, "object");
              if (value == null) return;
              const condition = new PgCondition(queryBuilder);
              return condition;
            });
          },
          orderBy(parent, $connection, value) {
            const $select = $connection.getSubplan();
            value.apply($select);
          }
        }
      }
    }
  },
  Mutation: {
    assertStep: __ValueStep,
    plans: {
      createAuditLog: {
        plan(_, args) {
          const $insert = pgInsertSingle(resource_audit_logPgResource, Object.create(null));
          args.apply($insert);
          return object({
            result: $insert
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      createBounty: {
        plan(_, args) {
          const $insert = pgInsertSingle(resource_bountyPgResource, Object.create(null));
          args.apply($insert);
          return object({
            result: $insert
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      createBountyFunding: {
        plan(_, args) {
          const $insert = pgInsertSingle(resource_bounty_fundingPgResource, Object.create(null));
          args.apply($insert);
          return object({
            result: $insert
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      createDonation: {
        plan(_, args) {
          const $insert = pgInsertSingle(resource_donationPgResource, Object.create(null));
          args.apply($insert);
          return object({
            result: $insert
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      createGoal: {
        plan(_, args) {
          const $insert = pgInsertSingle(resource_goalPgResource, Object.create(null));
          args.apply($insert);
          return object({
            result: $insert
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      createGrantApplication: {
        plan(_, args) {
          const $insert = pgInsertSingle(resource_grant_applicationPgResource, Object.create(null));
          args.apply($insert);
          return object({
            result: $insert
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      createGrantMilestone: {
        plan(_, args) {
          const $insert = pgInsertSingle(resource_grant_milestonePgResource, Object.create(null));
          args.apply($insert);
          return object({
            result: $insert
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      createGrantProgram: {
        plan(_, args) {
          const $insert = pgInsertSingle(resource_grant_programPgResource, Object.create(null));
          args.apply($insert);
          return object({
            result: $insert
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      createOrganization: {
        plan(_, args) {
          const $insert = pgInsertSingle(resource_organizationPgResource, Object.create(null));
          args.apply($insert);
          return object({
            result: $insert
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      createPaymentProcessorConnection: {
        plan(_, args) {
          const $insert = pgInsertSingle(resource_payment_processor_connectionPgResource, Object.create(null));
          args.apply($insert);
          return object({
            result: $insert
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      createPayout: {
        plan(_, args) {
          const $insert = pgInsertSingle(resource_payoutPgResource, Object.create(null));
          args.apply($insert);
          return object({
            result: $insert
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      createPost: {
        plan(_, args) {
          const $insert = pgInsertSingle(resource_postPgResource, Object.create(null));
          args.apply($insert);
          return object({
            result: $insert
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      createSponsorship: {
        plan(_, args) {
          const $insert = pgInsertSingle(resource_sponsorshipPgResource, Object.create(null));
          args.apply($insert);
          return object({
            result: $insert
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      createSponsorshipTier: {
        plan(_, args) {
          const $insert = pgInsertSingle(resource_sponsorship_tierPgResource, Object.create(null));
          args.apply($insert);
          return object({
            result: $insert
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      createTransaction: {
        plan(_, args) {
          const $insert = pgInsertSingle(resource_transactionPgResource, Object.create(null));
          args.apply($insert);
          return object({
            result: $insert
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      createUser: {
        plan(_, args) {
          const $insert = pgInsertSingle(resource_userPgResource, Object.create(null));
          args.apply($insert);
          return object({
            result: $insert
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      createUserIdentity: {
        plan(_, args) {
          const $insert = pgInsertSingle(resource_user_identityPgResource, Object.create(null));
          args.apply($insert);
          return object({
            result: $insert
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      createUserOrganization: {
        plan(_, args) {
          const $insert = pgInsertSingle(resource_user_organizationPgResource, Object.create(null));
          args.apply($insert);
          return object({
            result: $insert
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      createWebhookDelivery: {
        plan(_, args) {
          const $insert = pgInsertSingle(resource_webhook_deliveryPgResource, Object.create(null));
          args.apply($insert);
          return object({
            result: $insert
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      createWebhookEndpoint: {
        plan(_, args) {
          const $insert = pgInsertSingle(resource_webhook_endpointPgResource, Object.create(null));
          args.apply($insert);
          return object({
            result: $insert
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      createWorkspace: {
        plan(_, args) {
          const $insert = pgInsertSingle(resource_workspacePgResource, Object.create(null));
          args.apply($insert);
          return object({
            result: $insert
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      deleteAuditLog: {
        plan(_$root, args) {
          const $delete = pgDeleteSingle(resource_audit_logPgResource, {
            id: args.getRaw(['input', "rowId"])
          });
          args.apply($delete);
          return object({
            result: $delete
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      deleteAuditLogById: {
        plan(_$root, args) {
          const $delete = pgDeleteSingle(resource_audit_logPgResource, specFromArgs_AuditLog2(args));
          args.apply($delete);
          return object({
            result: $delete
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      deleteBounty: {
        plan(_$root, args) {
          const $delete = pgDeleteSingle(resource_bountyPgResource, {
            id: args.getRaw(['input', "rowId"])
          });
          args.apply($delete);
          return object({
            result: $delete
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      deleteBountyById: {
        plan(_$root, args) {
          const $delete = pgDeleteSingle(resource_bountyPgResource, specFromArgs_Bounty2(args));
          args.apply($delete);
          return object({
            result: $delete
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      deleteBountyFunding: {
        plan(_$root, args) {
          const $delete = pgDeleteSingle(resource_bounty_fundingPgResource, {
            id: args.getRaw(['input', "rowId"])
          });
          args.apply($delete);
          return object({
            result: $delete
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      deleteBountyFundingById: {
        plan(_$root, args) {
          const $delete = pgDeleteSingle(resource_bounty_fundingPgResource, specFromArgs_BountyFunding2(args));
          args.apply($delete);
          return object({
            result: $delete
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      deleteDonation: {
        plan(_$root, args) {
          const $delete = pgDeleteSingle(resource_donationPgResource, {
            id: args.getRaw(['input', "rowId"])
          });
          args.apply($delete);
          return object({
            result: $delete
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      deleteDonationById: {
        plan(_$root, args) {
          const $delete = pgDeleteSingle(resource_donationPgResource, specFromArgs_Donation2(args));
          args.apply($delete);
          return object({
            result: $delete
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      deleteGoal: {
        plan(_$root, args) {
          const $delete = pgDeleteSingle(resource_goalPgResource, {
            id: args.getRaw(['input', "rowId"])
          });
          args.apply($delete);
          return object({
            result: $delete
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      deleteGoalById: {
        plan(_$root, args) {
          const $delete = pgDeleteSingle(resource_goalPgResource, specFromArgs_Goal2(args));
          args.apply($delete);
          return object({
            result: $delete
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      deleteGrantApplication: {
        plan(_$root, args) {
          const $delete = pgDeleteSingle(resource_grant_applicationPgResource, {
            id: args.getRaw(['input', "rowId"])
          });
          args.apply($delete);
          return object({
            result: $delete
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      deleteGrantApplicationById: {
        plan(_$root, args) {
          const $delete = pgDeleteSingle(resource_grant_applicationPgResource, specFromArgs_GrantApplication2(args));
          args.apply($delete);
          return object({
            result: $delete
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      deleteGrantMilestone: {
        plan(_$root, args) {
          const $delete = pgDeleteSingle(resource_grant_milestonePgResource, {
            id: args.getRaw(['input', "rowId"])
          });
          args.apply($delete);
          return object({
            result: $delete
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      deleteGrantMilestoneById: {
        plan(_$root, args) {
          const $delete = pgDeleteSingle(resource_grant_milestonePgResource, specFromArgs_GrantMilestone2(args));
          args.apply($delete);
          return object({
            result: $delete
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      deleteGrantProgram: {
        plan(_$root, args) {
          const $delete = pgDeleteSingle(resource_grant_programPgResource, {
            id: args.getRaw(['input', "rowId"])
          });
          args.apply($delete);
          return object({
            result: $delete
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      deleteGrantProgramById: {
        plan(_$root, args) {
          const $delete = pgDeleteSingle(resource_grant_programPgResource, specFromArgs_GrantProgram2(args));
          args.apply($delete);
          return object({
            result: $delete
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      deleteOrganization: {
        plan(_$root, args) {
          const $delete = pgDeleteSingle(resource_organizationPgResource, {
            id: args.getRaw(['input', "rowId"])
          });
          args.apply($delete);
          return object({
            result: $delete
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      deleteOrganizationById: {
        plan(_$root, args) {
          const $delete = pgDeleteSingle(resource_organizationPgResource, specFromArgs_Organization2(args));
          args.apply($delete);
          return object({
            result: $delete
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      deleteOrganizationBySlug: {
        plan(_$root, args) {
          const $delete = pgDeleteSingle(resource_organizationPgResource, {
            slug: args.getRaw(['input', "slug"])
          });
          args.apply($delete);
          return object({
            result: $delete
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      deletePaymentProcessorConnection: {
        plan(_$root, args) {
          const $delete = pgDeleteSingle(resource_payment_processor_connectionPgResource, {
            id: args.getRaw(['input', "rowId"])
          });
          args.apply($delete);
          return object({
            result: $delete
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      deletePaymentProcessorConnectionById: {
        plan(_$root, args) {
          const $delete = pgDeleteSingle(resource_payment_processor_connectionPgResource, specFromArgs_PaymentProcessorConnection2(args));
          args.apply($delete);
          return object({
            result: $delete
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      deletePayout: {
        plan(_$root, args) {
          const $delete = pgDeleteSingle(resource_payoutPgResource, {
            id: args.getRaw(['input', "rowId"])
          });
          args.apply($delete);
          return object({
            result: $delete
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      deletePayoutById: {
        plan(_$root, args) {
          const $delete = pgDeleteSingle(resource_payoutPgResource, specFromArgs_Payout2(args));
          args.apply($delete);
          return object({
            result: $delete
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      deletePost: {
        plan(_$root, args) {
          const $delete = pgDeleteSingle(resource_postPgResource, {
            id: args.getRaw(['input', "rowId"])
          });
          args.apply($delete);
          return object({
            result: $delete
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      deletePostById: {
        plan(_$root, args) {
          const $delete = pgDeleteSingle(resource_postPgResource, specFromArgs_Post2(args));
          args.apply($delete);
          return object({
            result: $delete
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      deleteSponsorship: {
        plan(_$root, args) {
          const $delete = pgDeleteSingle(resource_sponsorshipPgResource, {
            id: args.getRaw(['input', "rowId"])
          });
          args.apply($delete);
          return object({
            result: $delete
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      deleteSponsorshipById: {
        plan(_$root, args) {
          const $delete = pgDeleteSingle(resource_sponsorshipPgResource, specFromArgs_Sponsorship2(args));
          args.apply($delete);
          return object({
            result: $delete
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      deleteSponsorshipTier: {
        plan(_$root, args) {
          const $delete = pgDeleteSingle(resource_sponsorship_tierPgResource, {
            id: args.getRaw(['input', "rowId"])
          });
          args.apply($delete);
          return object({
            result: $delete
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      deleteSponsorshipTierById: {
        plan(_$root, args) {
          const $delete = pgDeleteSingle(resource_sponsorship_tierPgResource, specFromArgs_SponsorshipTier2(args));
          args.apply($delete);
          return object({
            result: $delete
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      deleteTransaction: {
        plan(_$root, args) {
          const $delete = pgDeleteSingle(resource_transactionPgResource, {
            id: args.getRaw(['input', "rowId"])
          });
          args.apply($delete);
          return object({
            result: $delete
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      deleteTransactionById: {
        plan(_$root, args) {
          const $delete = pgDeleteSingle(resource_transactionPgResource, specFromArgs_Transaction2(args));
          args.apply($delete);
          return object({
            result: $delete
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      deleteUser: {
        plan(_$root, args) {
          const $delete = pgDeleteSingle(resource_userPgResource, {
            id: args.getRaw(['input', "rowId"])
          });
          args.apply($delete);
          return object({
            result: $delete
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      deleteUserById: {
        plan(_$root, args) {
          const $delete = pgDeleteSingle(resource_userPgResource, specFromArgs_User2(args));
          args.apply($delete);
          return object({
            result: $delete
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      deleteUserByUsername: {
        plan(_$root, args) {
          const $delete = pgDeleteSingle(resource_userPgResource, {
            username: args.getRaw(['input', "username"])
          });
          args.apply($delete);
          return object({
            result: $delete
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      deleteUserIdentity: {
        plan(_$root, args) {
          const $delete = pgDeleteSingle(resource_user_identityPgResource, {
            id: args.getRaw(['input', "rowId"])
          });
          args.apply($delete);
          return object({
            result: $delete
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      deleteUserIdentityById: {
        plan(_$root, args) {
          const $delete = pgDeleteSingle(resource_user_identityPgResource, specFromArgs_UserIdentity2(args));
          args.apply($delete);
          return object({
            result: $delete
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      deleteUserOrganization: {
        plan(_$root, args) {
          const $delete = pgDeleteSingle(resource_user_organizationPgResource, {
            id: args.getRaw(['input', "rowId"])
          });
          args.apply($delete);
          return object({
            result: $delete
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      deleteUserOrganizationById: {
        plan(_$root, args) {
          const $delete = pgDeleteSingle(resource_user_organizationPgResource, specFromArgs_UserOrganization2(args));
          args.apply($delete);
          return object({
            result: $delete
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      deleteWebhookDelivery: {
        plan(_$root, args) {
          const $delete = pgDeleteSingle(resource_webhook_deliveryPgResource, {
            id: args.getRaw(['input', "rowId"])
          });
          args.apply($delete);
          return object({
            result: $delete
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      deleteWebhookDeliveryById: {
        plan(_$root, args) {
          const $delete = pgDeleteSingle(resource_webhook_deliveryPgResource, specFromArgs_WebhookDelivery2(args));
          args.apply($delete);
          return object({
            result: $delete
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      deleteWebhookEndpoint: {
        plan(_$root, args) {
          const $delete = pgDeleteSingle(resource_webhook_endpointPgResource, {
            id: args.getRaw(['input', "rowId"])
          });
          args.apply($delete);
          return object({
            result: $delete
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      deleteWebhookEndpointById: {
        plan(_$root, args) {
          const $delete = pgDeleteSingle(resource_webhook_endpointPgResource, specFromArgs_WebhookEndpoint2(args));
          args.apply($delete);
          return object({
            result: $delete
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      deleteWorkspace: {
        plan(_$root, args) {
          const $delete = pgDeleteSingle(resource_workspacePgResource, {
            id: args.getRaw(['input', "rowId"])
          });
          args.apply($delete);
          return object({
            result: $delete
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      deleteWorkspaceById: {
        plan(_$root, args) {
          const $delete = pgDeleteSingle(resource_workspacePgResource, specFromArgs_Workspace2(args));
          args.apply($delete);
          return object({
            result: $delete
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      updateAuditLog: {
        plan(_$root, args) {
          const $update = pgUpdateSingle(resource_audit_logPgResource, {
            id: args.getRaw(['input', "rowId"])
          });
          args.apply($update);
          return object({
            result: $update
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      updateAuditLogById: {
        plan(_$root, args) {
          const $update = pgUpdateSingle(resource_audit_logPgResource, specFromArgs_AuditLog(args));
          args.apply($update);
          return object({
            result: $update
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      updateBounty: {
        plan(_$root, args) {
          const $update = pgUpdateSingle(resource_bountyPgResource, {
            id: args.getRaw(['input', "rowId"])
          });
          args.apply($update);
          return object({
            result: $update
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      updateBountyById: {
        plan(_$root, args) {
          const $update = pgUpdateSingle(resource_bountyPgResource, specFromArgs_Bounty(args));
          args.apply($update);
          return object({
            result: $update
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      updateBountyFunding: {
        plan(_$root, args) {
          const $update = pgUpdateSingle(resource_bounty_fundingPgResource, {
            id: args.getRaw(['input', "rowId"])
          });
          args.apply($update);
          return object({
            result: $update
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      updateBountyFundingById: {
        plan(_$root, args) {
          const $update = pgUpdateSingle(resource_bounty_fundingPgResource, specFromArgs_BountyFunding(args));
          args.apply($update);
          return object({
            result: $update
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      updateDonation: {
        plan(_$root, args) {
          const $update = pgUpdateSingle(resource_donationPgResource, {
            id: args.getRaw(['input', "rowId"])
          });
          args.apply($update);
          return object({
            result: $update
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      updateDonationById: {
        plan(_$root, args) {
          const $update = pgUpdateSingle(resource_donationPgResource, specFromArgs_Donation(args));
          args.apply($update);
          return object({
            result: $update
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      updateGoal: {
        plan(_$root, args) {
          const $update = pgUpdateSingle(resource_goalPgResource, {
            id: args.getRaw(['input', "rowId"])
          });
          args.apply($update);
          return object({
            result: $update
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      updateGoalById: {
        plan(_$root, args) {
          const $update = pgUpdateSingle(resource_goalPgResource, specFromArgs_Goal(args));
          args.apply($update);
          return object({
            result: $update
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      updateGrantApplication: {
        plan(_$root, args) {
          const $update = pgUpdateSingle(resource_grant_applicationPgResource, {
            id: args.getRaw(['input', "rowId"])
          });
          args.apply($update);
          return object({
            result: $update
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      updateGrantApplicationById: {
        plan(_$root, args) {
          const $update = pgUpdateSingle(resource_grant_applicationPgResource, specFromArgs_GrantApplication(args));
          args.apply($update);
          return object({
            result: $update
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      updateGrantMilestone: {
        plan(_$root, args) {
          const $update = pgUpdateSingle(resource_grant_milestonePgResource, {
            id: args.getRaw(['input', "rowId"])
          });
          args.apply($update);
          return object({
            result: $update
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      updateGrantMilestoneById: {
        plan(_$root, args) {
          const $update = pgUpdateSingle(resource_grant_milestonePgResource, specFromArgs_GrantMilestone(args));
          args.apply($update);
          return object({
            result: $update
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      updateGrantProgram: {
        plan(_$root, args) {
          const $update = pgUpdateSingle(resource_grant_programPgResource, {
            id: args.getRaw(['input', "rowId"])
          });
          args.apply($update);
          return object({
            result: $update
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      updateGrantProgramById: {
        plan(_$root, args) {
          const $update = pgUpdateSingle(resource_grant_programPgResource, specFromArgs_GrantProgram(args));
          args.apply($update);
          return object({
            result: $update
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      updateOrganization: {
        plan(_$root, args) {
          const $update = pgUpdateSingle(resource_organizationPgResource, {
            id: args.getRaw(['input', "rowId"])
          });
          args.apply($update);
          return object({
            result: $update
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      updateOrganizationById: {
        plan(_$root, args) {
          const $update = pgUpdateSingle(resource_organizationPgResource, specFromArgs_Organization(args));
          args.apply($update);
          return object({
            result: $update
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      updateOrganizationBySlug: {
        plan(_$root, args) {
          const $update = pgUpdateSingle(resource_organizationPgResource, {
            slug: args.getRaw(['input', "slug"])
          });
          args.apply($update);
          return object({
            result: $update
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      updatePaymentProcessorConnection: {
        plan(_$root, args) {
          const $update = pgUpdateSingle(resource_payment_processor_connectionPgResource, {
            id: args.getRaw(['input', "rowId"])
          });
          args.apply($update);
          return object({
            result: $update
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      updatePaymentProcessorConnectionById: {
        plan(_$root, args) {
          const $update = pgUpdateSingle(resource_payment_processor_connectionPgResource, specFromArgs_PaymentProcessorConnection(args));
          args.apply($update);
          return object({
            result: $update
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      updatePayout: {
        plan(_$root, args) {
          const $update = pgUpdateSingle(resource_payoutPgResource, {
            id: args.getRaw(['input', "rowId"])
          });
          args.apply($update);
          return object({
            result: $update
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      updatePayoutById: {
        plan(_$root, args) {
          const $update = pgUpdateSingle(resource_payoutPgResource, specFromArgs_Payout(args));
          args.apply($update);
          return object({
            result: $update
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      updatePost: {
        plan(_$root, args) {
          const $update = pgUpdateSingle(resource_postPgResource, {
            id: args.getRaw(['input', "rowId"])
          });
          args.apply($update);
          return object({
            result: $update
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      updatePostById: {
        plan(_$root, args) {
          const $update = pgUpdateSingle(resource_postPgResource, specFromArgs_Post(args));
          args.apply($update);
          return object({
            result: $update
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      updateSponsorship: {
        plan(_$root, args) {
          const $update = pgUpdateSingle(resource_sponsorshipPgResource, {
            id: args.getRaw(['input', "rowId"])
          });
          args.apply($update);
          return object({
            result: $update
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      updateSponsorshipById: {
        plan(_$root, args) {
          const $update = pgUpdateSingle(resource_sponsorshipPgResource, specFromArgs_Sponsorship(args));
          args.apply($update);
          return object({
            result: $update
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      updateSponsorshipTier: {
        plan(_$root, args) {
          const $update = pgUpdateSingle(resource_sponsorship_tierPgResource, {
            id: args.getRaw(['input', "rowId"])
          });
          args.apply($update);
          return object({
            result: $update
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      updateSponsorshipTierById: {
        plan(_$root, args) {
          const $update = pgUpdateSingle(resource_sponsorship_tierPgResource, specFromArgs_SponsorshipTier(args));
          args.apply($update);
          return object({
            result: $update
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      updateTransaction: {
        plan(_$root, args) {
          const $update = pgUpdateSingle(resource_transactionPgResource, {
            id: args.getRaw(['input', "rowId"])
          });
          args.apply($update);
          return object({
            result: $update
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      updateTransactionById: {
        plan(_$root, args) {
          const $update = pgUpdateSingle(resource_transactionPgResource, specFromArgs_Transaction(args));
          args.apply($update);
          return object({
            result: $update
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      updateUser: {
        plan(_$root, args) {
          const $update = pgUpdateSingle(resource_userPgResource, {
            id: args.getRaw(['input', "rowId"])
          });
          args.apply($update);
          return object({
            result: $update
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      updateUserById: {
        plan(_$root, args) {
          const $update = pgUpdateSingle(resource_userPgResource, specFromArgs_User(args));
          args.apply($update);
          return object({
            result: $update
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      updateUserByUsername: {
        plan(_$root, args) {
          const $update = pgUpdateSingle(resource_userPgResource, {
            username: args.getRaw(['input', "username"])
          });
          args.apply($update);
          return object({
            result: $update
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      updateUserIdentity: {
        plan(_$root, args) {
          const $update = pgUpdateSingle(resource_user_identityPgResource, {
            id: args.getRaw(['input', "rowId"])
          });
          args.apply($update);
          return object({
            result: $update
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      updateUserIdentityById: {
        plan(_$root, args) {
          const $update = pgUpdateSingle(resource_user_identityPgResource, specFromArgs_UserIdentity(args));
          args.apply($update);
          return object({
            result: $update
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      updateUserOrganization: {
        plan(_$root, args) {
          const $update = pgUpdateSingle(resource_user_organizationPgResource, {
            id: args.getRaw(['input', "rowId"])
          });
          args.apply($update);
          return object({
            result: $update
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      updateUserOrganizationById: {
        plan(_$root, args) {
          const $update = pgUpdateSingle(resource_user_organizationPgResource, specFromArgs_UserOrganization(args));
          args.apply($update);
          return object({
            result: $update
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      updateWebhookDelivery: {
        plan(_$root, args) {
          const $update = pgUpdateSingle(resource_webhook_deliveryPgResource, {
            id: args.getRaw(['input', "rowId"])
          });
          args.apply($update);
          return object({
            result: $update
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      updateWebhookDeliveryById: {
        plan(_$root, args) {
          const $update = pgUpdateSingle(resource_webhook_deliveryPgResource, specFromArgs_WebhookDelivery(args));
          args.apply($update);
          return object({
            result: $update
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      updateWebhookEndpoint: {
        plan(_$root, args) {
          const $update = pgUpdateSingle(resource_webhook_endpointPgResource, {
            id: args.getRaw(['input', "rowId"])
          });
          args.apply($update);
          return object({
            result: $update
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      updateWebhookEndpointById: {
        plan(_$root, args) {
          const $update = pgUpdateSingle(resource_webhook_endpointPgResource, specFromArgs_WebhookEndpoint(args));
          args.apply($update);
          return object({
            result: $update
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      updateWorkspace: {
        plan(_$root, args) {
          const $update = pgUpdateSingle(resource_workspacePgResource, {
            id: args.getRaw(['input', "rowId"])
          });
          args.apply($update);
          return object({
            result: $update
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      },
      updateWorkspaceById: {
        plan(_$root, args) {
          const $update = pgUpdateSingle(resource_workspacePgResource, specFromArgs_Workspace(args));
          args.apply($update);
          return object({
            result: $update
          });
        },
        args: {
          input(_, $object) {
            return $object;
          }
        }
      }
    }
  },
  AuditLog: {
    assertStep: assertPgClassSingleStep,
    plans: {
      actorIpAddress($record) {
        return $record.get("actor_ip_address");
      },
      actorUser($record) {
        return resource_userPgResource.get({
          id: $record.get("actor_user_id")
        });
      },
      actorUserAgent($record) {
        return $record.get("actor_user_agent");
      },
      actorUserId($record) {
        return $record.get("actor_user_id");
      },
      createdAt($record) {
        return $record.get("created_at");
      },
      id($parent) {
        const specifier = nodeIdHandler_AuditLog.plan($parent);
        return lambda(specifier, nodeIdCodecs[nodeIdHandler_AuditLog.codec.name].encode);
      },
      newState($record) {
        return $record.get("new_state");
      },
      organization($record) {
        return resource_organizationPgResource.get({
          id: $record.get("organization_id")
        });
      },
      organizationId($record) {
        return $record.get("organization_id");
      },
      previousState($record) {
        return $record.get("previous_state");
      },
      rowId($record) {
        return $record.get("id");
      },
      targetEntityId($record) {
        return $record.get("target_entity_id");
      },
      targetEntityType($record) {
        return $record.get("target_entity_type");
      }
    },
    planType($specifier) {
      const spec = Object.create(null);
      for (const pkCol of audit_logUniques[0].attributes) spec[pkCol] = get2($specifier, pkCol);
      return resource_audit_logPgResource.get(spec);
    }
  },
  AuditLogConnection: {
    assertStep: ConnectionStep,
    plans: {
      totalCount($connection) {
        return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint, !1);
      }
    }
  },
  Bounty: {
    assertStep: assertPgClassSingleStep,
    plans: {
      arborIssueId($record) {
        return $record.get("arbor_issue_id");
      },
      bountyFundings: {
        plan($record) {
          const $records = resource_bounty_fundingPgResource.find({
            bounty_id: $record.get("id")
          });
          return connection($records);
        },
        args: {
          first(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          },
          last(_, $connection, val) {
            $connection.setLast(val.getRaw());
          },
          offset(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          },
          before(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          },
          after(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          },
          condition(_condition, $connection, arg) {
            const $select = $connection.getSubplan();
            arg.apply($select, qbWhereBuilder);
          },
          filter(_, $connection, fieldArg) {
            const $pgSelect = $connection.getSubplan();
            fieldArg.apply($pgSelect, (queryBuilder, value) => {
              assertAllowed126(value, "object");
              if (value == null) return;
              const condition = new PgCondition(queryBuilder);
              return condition;
            });
          },
          orderBy(parent, $connection, value) {
            const $select = $connection.getSubplan();
            value.apply($select);
          }
        }
      },
      claimant($record) {
        return resource_userPgResource.get({
          id: $record.get("claimant_id")
        });
      },
      claimantId($record) {
        return $record.get("claimant_id");
      },
      claimedAt($record) {
        return $record.get("claimed_at");
      },
      completedAt($record) {
        return $record.get("completed_at");
      },
      createdAt($record) {
        return $record.get("created_at");
      },
      deletedAt($record) {
        return $record.get("deleted_at");
      },
      expiresAt($record) {
        return $record.get("expires_at");
      },
      externalUrl($record) {
        return $record.get("external_url");
      },
      id($parent) {
        const specifier = nodeIdHandler_Bounty.plan($parent);
        return lambda(specifier, nodeIdCodecs[nodeIdHandler_Bounty.codec.name].encode);
      },
      organization($record) {
        return resource_organizationPgResource.get({
          id: $record.get("organization_id")
        });
      },
      organizationId($record) {
        return $record.get("organization_id");
      },
      rowId($record) {
        return $record.get("id");
      },
      sourceType($record) {
        return $record.get("source_type");
      },
      targetAmount($record) {
        return $record.get("target_amount");
      },
      updatedAt($record) {
        return $record.get("updated_at");
      }
    },
    planType($specifier) {
      const spec = Object.create(null);
      for (const pkCol of bountyUniques[0].attributes) spec[pkCol] = get2($specifier, pkCol);
      return resource_bountyPgResource.get(spec);
    }
  },
  BountyConnection: {
    assertStep: ConnectionStep,
    plans: {
      totalCount($connection) {
        return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint, !1);
      }
    }
  },
  BountyFunding: {
    assertStep: assertPgClassSingleStep,
    plans: {
      bounty($record) {
        return resource_bountyPgResource.get({
          id: $record.get("bounty_id")
        });
      },
      bountyId($record) {
        return $record.get("bounty_id");
      },
      createdAt($record) {
        return $record.get("created_at");
      },
      funder($record) {
        return resource_userPgResource.get({
          id: $record.get("funder_id")
        });
      },
      funderId($record) {
        return $record.get("funder_id");
      },
      id($parent) {
        const specifier = nodeIdHandler_BountyFunding.plan($parent);
        return lambda(specifier, nodeIdCodecs[nodeIdHandler_BountyFunding.codec.name].encode);
      },
      rowId($record) {
        return $record.get("id");
      },
      transaction($record) {
        return resource_transactionPgResource.get({
          id: $record.get("transaction_id")
        });
      },
      transactionId($record) {
        return $record.get("transaction_id");
      },
      updatedAt($record) {
        return $record.get("updated_at");
      }
    },
    planType($specifier) {
      const spec = Object.create(null);
      for (const pkCol of bounty_fundingUniques[0].attributes) spec[pkCol] = get2($specifier, pkCol);
      return resource_bounty_fundingPgResource.get(spec);
    }
  },
  BountyFundingConnection: {
    assertStep: ConnectionStep,
    plans: {
      totalCount($connection) {
        return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint, !1);
      }
    }
  },
  CreateAuditLogPayload: {
    assertStep: assertExecutableStep,
    plans: {
      auditLog($object) {
        return $object.get("result");
      },
      auditLogEdge($mutation, fieldArgs) {
        return pgMutationPayloadEdge(resource_audit_logPgResource, audit_logUniques[0].attributes, $mutation, fieldArgs);
      },
      clientMutationId($mutation) {
        return $mutation.getStepForKey("result").getMeta("clientMutationId");
      },
      query() {
        return rootValue();
      }
    }
  },
  CreateBountyFundingPayload: {
    assertStep: assertExecutableStep,
    plans: {
      bountyFunding($object) {
        return $object.get("result");
      },
      bountyFundingEdge($mutation, fieldArgs) {
        return pgMutationPayloadEdge(resource_bounty_fundingPgResource, bounty_fundingUniques[0].attributes, $mutation, fieldArgs);
      },
      clientMutationId($mutation) {
        return $mutation.getStepForKey("result").getMeta("clientMutationId");
      },
      query() {
        return rootValue();
      }
    }
  },
  CreateBountyPayload: {
    assertStep: assertExecutableStep,
    plans: {
      bounty($object) {
        return $object.get("result");
      },
      bountyEdge($mutation, fieldArgs) {
        return pgMutationPayloadEdge(resource_bountyPgResource, bountyUniques[0].attributes, $mutation, fieldArgs);
      },
      clientMutationId($mutation) {
        return $mutation.getStepForKey("result").getMeta("clientMutationId");
      },
      query() {
        return rootValue();
      }
    }
  },
  CreateDonationPayload: {
    assertStep: assertExecutableStep,
    plans: {
      clientMutationId($mutation) {
        return $mutation.getStepForKey("result").getMeta("clientMutationId");
      },
      donation($object) {
        return $object.get("result");
      },
      donationEdge($mutation, fieldArgs) {
        return pgMutationPayloadEdge(resource_donationPgResource, donationUniques[0].attributes, $mutation, fieldArgs);
      },
      query() {
        return rootValue();
      }
    }
  },
  CreateGoalPayload: {
    assertStep: assertExecutableStep,
    plans: {
      clientMutationId($mutation) {
        return $mutation.getStepForKey("result").getMeta("clientMutationId");
      },
      goal($object) {
        return $object.get("result");
      },
      goalEdge($mutation, fieldArgs) {
        return pgMutationPayloadEdge(resource_goalPgResource, goalUniques[0].attributes, $mutation, fieldArgs);
      },
      query() {
        return rootValue();
      }
    }
  },
  CreateGrantApplicationPayload: {
    assertStep: assertExecutableStep,
    plans: {
      clientMutationId($mutation) {
        return $mutation.getStepForKey("result").getMeta("clientMutationId");
      },
      grantApplication($object) {
        return $object.get("result");
      },
      grantApplicationEdge($mutation, fieldArgs) {
        return pgMutationPayloadEdge(resource_grant_applicationPgResource, grant_applicationUniques[0].attributes, $mutation, fieldArgs);
      },
      query() {
        return rootValue();
      }
    }
  },
  CreateGrantMilestonePayload: {
    assertStep: assertExecutableStep,
    plans: {
      clientMutationId($mutation) {
        return $mutation.getStepForKey("result").getMeta("clientMutationId");
      },
      grantMilestone($object) {
        return $object.get("result");
      },
      grantMilestoneEdge($mutation, fieldArgs) {
        return pgMutationPayloadEdge(resource_grant_milestonePgResource, grant_milestoneUniques[0].attributes, $mutation, fieldArgs);
      },
      query() {
        return rootValue();
      }
    }
  },
  CreateGrantProgramPayload: {
    assertStep: assertExecutableStep,
    plans: {
      clientMutationId($mutation) {
        return $mutation.getStepForKey("result").getMeta("clientMutationId");
      },
      grantProgram($object) {
        return $object.get("result");
      },
      grantProgramEdge($mutation, fieldArgs) {
        return pgMutationPayloadEdge(resource_grant_programPgResource, grant_programUniques[0].attributes, $mutation, fieldArgs);
      },
      query() {
        return rootValue();
      }
    }
  },
  CreateOrganizationPayload: {
    assertStep: assertExecutableStep,
    plans: {
      clientMutationId($mutation) {
        return $mutation.getStepForKey("result").getMeta("clientMutationId");
      },
      organization($object) {
        return $object.get("result");
      },
      organizationEdge($mutation, fieldArgs) {
        return pgMutationPayloadEdge(resource_organizationPgResource, organizationUniques[0].attributes, $mutation, fieldArgs);
      },
      query() {
        return rootValue();
      }
    }
  },
  CreatePaymentProcessorConnectionPayload: {
    assertStep: assertExecutableStep,
    plans: {
      clientMutationId($mutation) {
        return $mutation.getStepForKey("result").getMeta("clientMutationId");
      },
      paymentProcessorConnection($object) {
        return $object.get("result");
      },
      paymentProcessorConnectionEdge($mutation, fieldArgs) {
        return pgMutationPayloadEdge(resource_payment_processor_connectionPgResource, payment_processor_connectionUniques[0].attributes, $mutation, fieldArgs);
      },
      query() {
        return rootValue();
      }
    }
  },
  CreatePayoutPayload: {
    assertStep: assertExecutableStep,
    plans: {
      clientMutationId($mutation) {
        return $mutation.getStepForKey("result").getMeta("clientMutationId");
      },
      payout($object) {
        return $object.get("result");
      },
      payoutEdge($mutation, fieldArgs) {
        return pgMutationPayloadEdge(resource_payoutPgResource, payoutUniques[0].attributes, $mutation, fieldArgs);
      },
      query() {
        return rootValue();
      }
    }
  },
  CreatePostPayload: {
    assertStep: assertExecutableStep,
    plans: {
      clientMutationId($mutation) {
        return $mutation.getStepForKey("result").getMeta("clientMutationId");
      },
      post($object) {
        return $object.get("result");
      },
      postEdge($mutation, fieldArgs) {
        return pgMutationPayloadEdge(resource_postPgResource, postUniques[0].attributes, $mutation, fieldArgs);
      },
      query() {
        return rootValue();
      }
    }
  },
  CreateSponsorshipPayload: {
    assertStep: assertExecutableStep,
    plans: {
      clientMutationId($mutation) {
        return $mutation.getStepForKey("result").getMeta("clientMutationId");
      },
      query() {
        return rootValue();
      },
      sponsorship($object) {
        return $object.get("result");
      },
      sponsorshipEdge($mutation, fieldArgs) {
        return pgMutationPayloadEdge(resource_sponsorshipPgResource, sponsorshipUniques[0].attributes, $mutation, fieldArgs);
      }
    }
  },
  CreateSponsorshipTierPayload: {
    assertStep: assertExecutableStep,
    plans: {
      clientMutationId($mutation) {
        return $mutation.getStepForKey("result").getMeta("clientMutationId");
      },
      query() {
        return rootValue();
      },
      sponsorshipTier($object) {
        return $object.get("result");
      },
      sponsorshipTierEdge($mutation, fieldArgs) {
        return pgMutationPayloadEdge(resource_sponsorship_tierPgResource, sponsorship_tierUniques[0].attributes, $mutation, fieldArgs);
      }
    }
  },
  CreateTransactionPayload: {
    assertStep: assertExecutableStep,
    plans: {
      clientMutationId($mutation) {
        return $mutation.getStepForKey("result").getMeta("clientMutationId");
      },
      query() {
        return rootValue();
      },
      transaction($object) {
        return $object.get("result");
      },
      transactionEdge($mutation, fieldArgs) {
        return pgMutationPayloadEdge(resource_transactionPgResource, transactionUniques[0].attributes, $mutation, fieldArgs);
      }
    }
  },
  CreateUserIdentityPayload: {
    assertStep: assertExecutableStep,
    plans: {
      clientMutationId($mutation) {
        return $mutation.getStepForKey("result").getMeta("clientMutationId");
      },
      query() {
        return rootValue();
      },
      userIdentity($object) {
        return $object.get("result");
      },
      userIdentityEdge($mutation, fieldArgs) {
        return pgMutationPayloadEdge(resource_user_identityPgResource, user_identityUniques[0].attributes, $mutation, fieldArgs);
      }
    }
  },
  CreateUserOrganizationPayload: {
    assertStep: assertExecutableStep,
    plans: {
      clientMutationId($mutation) {
        return $mutation.getStepForKey("result").getMeta("clientMutationId");
      },
      query() {
        return rootValue();
      },
      userOrganization($object) {
        return $object.get("result");
      },
      userOrganizationEdge($mutation, fieldArgs) {
        return pgMutationPayloadEdge(resource_user_organizationPgResource, user_organizationUniques[0].attributes, $mutation, fieldArgs);
      }
    }
  },
  CreateUserPayload: {
    assertStep: assertExecutableStep,
    plans: {
      clientMutationId($mutation) {
        return $mutation.getStepForKey("result").getMeta("clientMutationId");
      },
      query() {
        return rootValue();
      },
      user($object) {
        return $object.get("result");
      },
      userEdge($mutation, fieldArgs) {
        return pgMutationPayloadEdge(resource_userPgResource, userUniques[0].attributes, $mutation, fieldArgs);
      }
    }
  },
  CreateWebhookDeliveryPayload: {
    assertStep: assertExecutableStep,
    plans: {
      clientMutationId($mutation) {
        return $mutation.getStepForKey("result").getMeta("clientMutationId");
      },
      query() {
        return rootValue();
      },
      webhookDelivery($object) {
        return $object.get("result");
      },
      webhookDeliveryEdge($mutation, fieldArgs) {
        return pgMutationPayloadEdge(resource_webhook_deliveryPgResource, webhook_deliveryUniques[0].attributes, $mutation, fieldArgs);
      }
    }
  },
  CreateWebhookEndpointPayload: {
    assertStep: assertExecutableStep,
    plans: {
      clientMutationId($mutation) {
        return $mutation.getStepForKey("result").getMeta("clientMutationId");
      },
      query() {
        return rootValue();
      },
      webhookEndpoint($object) {
        return $object.get("result");
      },
      webhookEndpointEdge($mutation, fieldArgs) {
        return pgMutationPayloadEdge(resource_webhook_endpointPgResource, webhook_endpointUniques[0].attributes, $mutation, fieldArgs);
      }
    }
  },
  CreateWorkspacePayload: {
    assertStep: assertExecutableStep,
    plans: {
      clientMutationId($mutation) {
        return $mutation.getStepForKey("result").getMeta("clientMutationId");
      },
      query() {
        return rootValue();
      },
      workspace($object) {
        return $object.get("result");
      },
      workspaceEdge($mutation, fieldArgs) {
        return pgMutationPayloadEdge(resource_workspacePgResource, workspaceUniques[0].attributes, $mutation, fieldArgs);
      }
    }
  },
  DeleteAuditLogPayload: {
    assertStep: ObjectStep,
    plans: {
      auditLog($object) {
        return $object.get("result");
      },
      auditLogEdge($mutation, fieldArgs) {
        return pgMutationPayloadEdge(resource_audit_logPgResource, audit_logUniques[0].attributes, $mutation, fieldArgs);
      },
      clientMutationId($mutation) {
        return $mutation.getStepForKey("result").getMeta("clientMutationId");
      },
      deletedAuditLogId($object) {
        const $record = $object.getStepForKey("result"),
          specifier = nodeIdHandler_AuditLog.plan($record);
        return lambda(specifier, nodeIdCodecs_base64JSON_base64JSON.encode);
      },
      query() {
        return rootValue();
      }
    }
  },
  DeleteBountyFundingPayload: {
    assertStep: ObjectStep,
    plans: {
      bountyFunding($object) {
        return $object.get("result");
      },
      bountyFundingEdge($mutation, fieldArgs) {
        return pgMutationPayloadEdge(resource_bounty_fundingPgResource, bounty_fundingUniques[0].attributes, $mutation, fieldArgs);
      },
      clientMutationId($mutation) {
        return $mutation.getStepForKey("result").getMeta("clientMutationId");
      },
      deletedBountyFundingId($object) {
        const $record = $object.getStepForKey("result"),
          specifier = nodeIdHandler_BountyFunding.plan($record);
        return lambda(specifier, nodeIdCodecs_base64JSON_base64JSON.encode);
      },
      query() {
        return rootValue();
      }
    }
  },
  DeleteBountyPayload: {
    assertStep: ObjectStep,
    plans: {
      bounty($object) {
        return $object.get("result");
      },
      bountyEdge($mutation, fieldArgs) {
        return pgMutationPayloadEdge(resource_bountyPgResource, bountyUniques[0].attributes, $mutation, fieldArgs);
      },
      clientMutationId($mutation) {
        return $mutation.getStepForKey("result").getMeta("clientMutationId");
      },
      deletedBountyId($object) {
        const $record = $object.getStepForKey("result"),
          specifier = nodeIdHandler_Bounty.plan($record);
        return lambda(specifier, nodeIdCodecs_base64JSON_base64JSON.encode);
      },
      query() {
        return rootValue();
      }
    }
  },
  DeleteDonationPayload: {
    assertStep: ObjectStep,
    plans: {
      clientMutationId($mutation) {
        return $mutation.getStepForKey("result").getMeta("clientMutationId");
      },
      deletedDonationId($object) {
        const $record = $object.getStepForKey("result"),
          specifier = nodeIdHandler_Donation.plan($record);
        return lambda(specifier, nodeIdCodecs_base64JSON_base64JSON.encode);
      },
      donation($object) {
        return $object.get("result");
      },
      donationEdge($mutation, fieldArgs) {
        return pgMutationPayloadEdge(resource_donationPgResource, donationUniques[0].attributes, $mutation, fieldArgs);
      },
      query() {
        return rootValue();
      }
    }
  },
  DeleteGoalPayload: {
    assertStep: ObjectStep,
    plans: {
      clientMutationId($mutation) {
        return $mutation.getStepForKey("result").getMeta("clientMutationId");
      },
      deletedGoalId($object) {
        const $record = $object.getStepForKey("result"),
          specifier = nodeIdHandler_Goal.plan($record);
        return lambda(specifier, nodeIdCodecs_base64JSON_base64JSON.encode);
      },
      goal($object) {
        return $object.get("result");
      },
      goalEdge($mutation, fieldArgs) {
        return pgMutationPayloadEdge(resource_goalPgResource, goalUniques[0].attributes, $mutation, fieldArgs);
      },
      query() {
        return rootValue();
      }
    }
  },
  DeleteGrantApplicationPayload: {
    assertStep: ObjectStep,
    plans: {
      clientMutationId($mutation) {
        return $mutation.getStepForKey("result").getMeta("clientMutationId");
      },
      deletedGrantApplicationId($object) {
        const $record = $object.getStepForKey("result"),
          specifier = nodeIdHandler_GrantApplication.plan($record);
        return lambda(specifier, nodeIdCodecs_base64JSON_base64JSON.encode);
      },
      grantApplication($object) {
        return $object.get("result");
      },
      grantApplicationEdge($mutation, fieldArgs) {
        return pgMutationPayloadEdge(resource_grant_applicationPgResource, grant_applicationUniques[0].attributes, $mutation, fieldArgs);
      },
      query() {
        return rootValue();
      }
    }
  },
  DeleteGrantMilestonePayload: {
    assertStep: ObjectStep,
    plans: {
      clientMutationId($mutation) {
        return $mutation.getStepForKey("result").getMeta("clientMutationId");
      },
      deletedGrantMilestoneId($object) {
        const $record = $object.getStepForKey("result"),
          specifier = nodeIdHandler_GrantMilestone.plan($record);
        return lambda(specifier, nodeIdCodecs_base64JSON_base64JSON.encode);
      },
      grantMilestone($object) {
        return $object.get("result");
      },
      grantMilestoneEdge($mutation, fieldArgs) {
        return pgMutationPayloadEdge(resource_grant_milestonePgResource, grant_milestoneUniques[0].attributes, $mutation, fieldArgs);
      },
      query() {
        return rootValue();
      }
    }
  },
  DeleteGrantProgramPayload: {
    assertStep: ObjectStep,
    plans: {
      clientMutationId($mutation) {
        return $mutation.getStepForKey("result").getMeta("clientMutationId");
      },
      deletedGrantProgramId($object) {
        const $record = $object.getStepForKey("result"),
          specifier = nodeIdHandler_GrantProgram.plan($record);
        return lambda(specifier, nodeIdCodecs_base64JSON_base64JSON.encode);
      },
      grantProgram($object) {
        return $object.get("result");
      },
      grantProgramEdge($mutation, fieldArgs) {
        return pgMutationPayloadEdge(resource_grant_programPgResource, grant_programUniques[0].attributes, $mutation, fieldArgs);
      },
      query() {
        return rootValue();
      }
    }
  },
  DeleteOrganizationPayload: {
    assertStep: ObjectStep,
    plans: {
      clientMutationId($mutation) {
        return $mutation.getStepForKey("result").getMeta("clientMutationId");
      },
      deletedOrganizationId($object) {
        const $record = $object.getStepForKey("result"),
          specifier = nodeIdHandler_Organization.plan($record);
        return lambda(specifier, nodeIdCodecs_base64JSON_base64JSON.encode);
      },
      organization($object) {
        return $object.get("result");
      },
      organizationEdge($mutation, fieldArgs) {
        return pgMutationPayloadEdge(resource_organizationPgResource, organizationUniques[0].attributes, $mutation, fieldArgs);
      },
      query() {
        return rootValue();
      }
    }
  },
  DeletePaymentProcessorConnectionPayload: {
    assertStep: ObjectStep,
    plans: {
      clientMutationId($mutation) {
        return $mutation.getStepForKey("result").getMeta("clientMutationId");
      },
      deletedPaymentProcessorConnectionId($object) {
        const $record = $object.getStepForKey("result"),
          specifier = nodeIdHandler_PaymentProcessorConnection.plan($record);
        return lambda(specifier, nodeIdCodecs_base64JSON_base64JSON.encode);
      },
      paymentProcessorConnection($object) {
        return $object.get("result");
      },
      paymentProcessorConnectionEdge($mutation, fieldArgs) {
        return pgMutationPayloadEdge(resource_payment_processor_connectionPgResource, payment_processor_connectionUniques[0].attributes, $mutation, fieldArgs);
      },
      query() {
        return rootValue();
      }
    }
  },
  DeletePayoutPayload: {
    assertStep: ObjectStep,
    plans: {
      clientMutationId($mutation) {
        return $mutation.getStepForKey("result").getMeta("clientMutationId");
      },
      deletedPayoutId($object) {
        const $record = $object.getStepForKey("result"),
          specifier = nodeIdHandler_Payout.plan($record);
        return lambda(specifier, nodeIdCodecs_base64JSON_base64JSON.encode);
      },
      payout($object) {
        return $object.get("result");
      },
      payoutEdge($mutation, fieldArgs) {
        return pgMutationPayloadEdge(resource_payoutPgResource, payoutUniques[0].attributes, $mutation, fieldArgs);
      },
      query() {
        return rootValue();
      }
    }
  },
  DeletePostPayload: {
    assertStep: ObjectStep,
    plans: {
      clientMutationId($mutation) {
        return $mutation.getStepForKey("result").getMeta("clientMutationId");
      },
      deletedPostId($object) {
        const $record = $object.getStepForKey("result"),
          specifier = nodeIdHandler_Post.plan($record);
        return lambda(specifier, nodeIdCodecs_base64JSON_base64JSON.encode);
      },
      post($object) {
        return $object.get("result");
      },
      postEdge($mutation, fieldArgs) {
        return pgMutationPayloadEdge(resource_postPgResource, postUniques[0].attributes, $mutation, fieldArgs);
      },
      query() {
        return rootValue();
      }
    }
  },
  DeleteSponsorshipPayload: {
    assertStep: ObjectStep,
    plans: {
      clientMutationId($mutation) {
        return $mutation.getStepForKey("result").getMeta("clientMutationId");
      },
      deletedSponsorshipId($object) {
        const $record = $object.getStepForKey("result"),
          specifier = nodeIdHandler_Sponsorship.plan($record);
        return lambda(specifier, nodeIdCodecs_base64JSON_base64JSON.encode);
      },
      query() {
        return rootValue();
      },
      sponsorship($object) {
        return $object.get("result");
      },
      sponsorshipEdge($mutation, fieldArgs) {
        return pgMutationPayloadEdge(resource_sponsorshipPgResource, sponsorshipUniques[0].attributes, $mutation, fieldArgs);
      }
    }
  },
  DeleteSponsorshipTierPayload: {
    assertStep: ObjectStep,
    plans: {
      clientMutationId($mutation) {
        return $mutation.getStepForKey("result").getMeta("clientMutationId");
      },
      deletedSponsorshipTierId($object) {
        const $record = $object.getStepForKey("result"),
          specifier = nodeIdHandler_SponsorshipTier.plan($record);
        return lambda(specifier, nodeIdCodecs_base64JSON_base64JSON.encode);
      },
      query() {
        return rootValue();
      },
      sponsorshipTier($object) {
        return $object.get("result");
      },
      sponsorshipTierEdge($mutation, fieldArgs) {
        return pgMutationPayloadEdge(resource_sponsorship_tierPgResource, sponsorship_tierUniques[0].attributes, $mutation, fieldArgs);
      }
    }
  },
  DeleteTransactionPayload: {
    assertStep: ObjectStep,
    plans: {
      clientMutationId($mutation) {
        return $mutation.getStepForKey("result").getMeta("clientMutationId");
      },
      deletedTransactionId($object) {
        const $record = $object.getStepForKey("result"),
          specifier = nodeIdHandler_Transaction.plan($record);
        return lambda(specifier, nodeIdCodecs_base64JSON_base64JSON.encode);
      },
      query() {
        return rootValue();
      },
      transaction($object) {
        return $object.get("result");
      },
      transactionEdge($mutation, fieldArgs) {
        return pgMutationPayloadEdge(resource_transactionPgResource, transactionUniques[0].attributes, $mutation, fieldArgs);
      }
    }
  },
  DeleteUserIdentityPayload: {
    assertStep: ObjectStep,
    plans: {
      clientMutationId($mutation) {
        return $mutation.getStepForKey("result").getMeta("clientMutationId");
      },
      deletedUserIdentityId($object) {
        const $record = $object.getStepForKey("result"),
          specifier = nodeIdHandler_UserIdentity.plan($record);
        return lambda(specifier, nodeIdCodecs_base64JSON_base64JSON.encode);
      },
      query() {
        return rootValue();
      },
      userIdentity($object) {
        return $object.get("result");
      },
      userIdentityEdge($mutation, fieldArgs) {
        return pgMutationPayloadEdge(resource_user_identityPgResource, user_identityUniques[0].attributes, $mutation, fieldArgs);
      }
    }
  },
  DeleteUserOrganizationPayload: {
    assertStep: ObjectStep,
    plans: {
      clientMutationId($mutation) {
        return $mutation.getStepForKey("result").getMeta("clientMutationId");
      },
      deletedUserOrganizationId($object) {
        const $record = $object.getStepForKey("result"),
          specifier = nodeIdHandler_UserOrganization.plan($record);
        return lambda(specifier, nodeIdCodecs_base64JSON_base64JSON.encode);
      },
      query() {
        return rootValue();
      },
      userOrganization($object) {
        return $object.get("result");
      },
      userOrganizationEdge($mutation, fieldArgs) {
        return pgMutationPayloadEdge(resource_user_organizationPgResource, user_organizationUniques[0].attributes, $mutation, fieldArgs);
      }
    }
  },
  DeleteUserPayload: {
    assertStep: ObjectStep,
    plans: {
      clientMutationId($mutation) {
        return $mutation.getStepForKey("result").getMeta("clientMutationId");
      },
      deletedUserId($object) {
        const $record = $object.getStepForKey("result"),
          specifier = nodeIdHandler_User.plan($record);
        return lambda(specifier, nodeIdCodecs_base64JSON_base64JSON.encode);
      },
      query() {
        return rootValue();
      },
      user($object) {
        return $object.get("result");
      },
      userEdge($mutation, fieldArgs) {
        return pgMutationPayloadEdge(resource_userPgResource, userUniques[0].attributes, $mutation, fieldArgs);
      }
    }
  },
  DeleteWebhookDeliveryPayload: {
    assertStep: ObjectStep,
    plans: {
      clientMutationId($mutation) {
        return $mutation.getStepForKey("result").getMeta("clientMutationId");
      },
      deletedWebhookDeliveryId($object) {
        const $record = $object.getStepForKey("result"),
          specifier = nodeIdHandler_WebhookDelivery.plan($record);
        return lambda(specifier, nodeIdCodecs_base64JSON_base64JSON.encode);
      },
      query() {
        return rootValue();
      },
      webhookDelivery($object) {
        return $object.get("result");
      },
      webhookDeliveryEdge($mutation, fieldArgs) {
        return pgMutationPayloadEdge(resource_webhook_deliveryPgResource, webhook_deliveryUniques[0].attributes, $mutation, fieldArgs);
      }
    }
  },
  DeleteWebhookEndpointPayload: {
    assertStep: ObjectStep,
    plans: {
      clientMutationId($mutation) {
        return $mutation.getStepForKey("result").getMeta("clientMutationId");
      },
      deletedWebhookEndpointId($object) {
        const $record = $object.getStepForKey("result"),
          specifier = nodeIdHandler_WebhookEndpoint.plan($record);
        return lambda(specifier, nodeIdCodecs_base64JSON_base64JSON.encode);
      },
      query() {
        return rootValue();
      },
      webhookEndpoint($object) {
        return $object.get("result");
      },
      webhookEndpointEdge($mutation, fieldArgs) {
        return pgMutationPayloadEdge(resource_webhook_endpointPgResource, webhook_endpointUniques[0].attributes, $mutation, fieldArgs);
      }
    }
  },
  DeleteWorkspacePayload: {
    assertStep: ObjectStep,
    plans: {
      clientMutationId($mutation) {
        return $mutation.getStepForKey("result").getMeta("clientMutationId");
      },
      deletedWorkspaceId($object) {
        const $record = $object.getStepForKey("result"),
          specifier = nodeIdHandler_Workspace.plan($record);
        return lambda(specifier, nodeIdCodecs_base64JSON_base64JSON.encode);
      },
      query() {
        return rootValue();
      },
      workspace($object) {
        return $object.get("result");
      },
      workspaceEdge($mutation, fieldArgs) {
        return pgMutationPayloadEdge(resource_workspacePgResource, workspaceUniques[0].attributes, $mutation, fieldArgs);
      }
    }
  },
  Donation: {
    assertStep: assertPgClassSingleStep,
    plans: {
      createdAt($record) {
        return $record.get("created_at");
      },
      donor($record) {
        return resource_userPgResource.get({
          id: $record.get("donor_id")
        });
      },
      donorId($record) {
        return $record.get("donor_id");
      },
      id($parent) {
        const specifier = nodeIdHandler_Donation.plan($parent);
        return lambda(specifier, nodeIdCodecs[nodeIdHandler_Donation.codec.name].encode);
      },
      isAnonymous($record) {
        return $record.get("is_anonymous");
      },
      isPublic($record) {
        return $record.get("is_public");
      },
      organization($record) {
        return resource_organizationPgResource.get({
          id: $record.get("organization_id")
        });
      },
      organizationId($record) {
        return $record.get("organization_id");
      },
      publicMessage($record) {
        return $record.get("public_message");
      },
      rowId($record) {
        return $record.get("id");
      },
      transaction($record) {
        return resource_transactionPgResource.get({
          id: $record.get("transaction_id")
        });
      },
      transactionId($record) {
        return $record.get("transaction_id");
      }
    },
    planType($specifier) {
      const spec = Object.create(null);
      for (const pkCol of donationUniques[0].attributes) spec[pkCol] = get2($specifier, pkCol);
      return resource_donationPgResource.get(spec);
    }
  },
  DonationConnection: {
    assertStep: ConnectionStep,
    plans: {
      totalCount($connection) {
        return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint, !1);
      }
    }
  },
  Goal: {
    assertStep: assertPgClassSingleStep,
    plans: {
      completedAt($record) {
        return $record.get("completed_at");
      },
      createdAt($record) {
        return $record.get("created_at");
      },
      currentAmount($record) {
        return $record.get("current_amount");
      },
      displayOrder($record) {
        return $record.get("display_order");
      },
      id($parent) {
        const specifier = nodeIdHandler_Goal.plan($parent);
        return lambda(specifier, nodeIdCodecs[nodeIdHandler_Goal.codec.name].encode);
      },
      isActive($record) {
        return $record.get("is_active");
      },
      isCompleted($record) {
        return $record.get("is_completed");
      },
      organization($record) {
        return resource_organizationPgResource.get({
          id: $record.get("organization_id")
        });
      },
      organizationId($record) {
        return $record.get("organization_id");
      },
      rowId($record) {
        return $record.get("id");
      },
      targetAmount($record) {
        return $record.get("target_amount");
      },
      updatedAt($record) {
        return $record.get("updated_at");
      }
    },
    planType($specifier) {
      const spec = Object.create(null);
      for (const pkCol of goalUniques[0].attributes) spec[pkCol] = get2($specifier, pkCol);
      return resource_goalPgResource.get(spec);
    }
  },
  GoalConnection: {
    assertStep: ConnectionStep,
    plans: {
      totalCount($connection) {
        return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint, !1);
      }
    }
  },
  GrantApplication: {
    assertStep: assertPgClassSingleStep,
    plans: {
      applicant($record) {
        return resource_userPgResource.get({
          id: $record.get("applicant_id")
        });
      },
      applicantId($record) {
        return $record.get("applicant_id");
      },
      approvedAmount($record) {
        return $record.get("approved_amount");
      },
      createdAt($record) {
        return $record.get("created_at");
      },
      grantMilestones: {
        plan($record) {
          const $records = resource_grant_milestonePgResource.find({
            grant_application_id: $record.get("id")
          });
          return connection($records);
        },
        args: {
          first(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          },
          last(_, $connection, val) {
            $connection.setLast(val.getRaw());
          },
          offset(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          },
          before(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          },
          after(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          },
          condition(_condition, $connection, arg) {
            const $select = $connection.getSubplan();
            arg.apply($select, qbWhereBuilder);
          },
          filter(_, $connection, fieldArg) {
            const $pgSelect = $connection.getSubplan();
            fieldArg.apply($pgSelect, (queryBuilder, value) => {
              assertAllowed130(value, "object");
              if (value == null) return;
              const condition = new PgCondition(queryBuilder);
              return condition;
            });
          },
          orderBy(parent, $connection, value) {
            const $select = $connection.getSubplan();
            value.apply($select);
          }
        }
      },
      grantProgram($record) {
        return resource_grant_programPgResource.get({
          id: $record.get("grant_program_id")
        });
      },
      grantProgramId($record) {
        return $record.get("grant_program_id");
      },
      id($parent) {
        const specifier = nodeIdHandler_GrantApplication.plan($parent);
        return lambda(specifier, nodeIdCodecs[nodeIdHandler_GrantApplication.codec.name].encode);
      },
      proposedAmount($record) {
        return $record.get("proposed_amount");
      },
      reviewedAt($record) {
        return $record.get("reviewed_at");
      },
      reviewedBy($record) {
        return resource_userPgResource.get({
          id: $record.get("reviewed_by_id")
        });
      },
      reviewedById($record) {
        return $record.get("reviewed_by_id");
      },
      reviewNotes($record) {
        return $record.get("review_notes");
      },
      rowId($record) {
        return $record.get("id");
      },
      submittedAt($record) {
        return $record.get("submitted_at");
      },
      updatedAt($record) {
        return $record.get("updated_at");
      }
    },
    planType($specifier) {
      const spec = Object.create(null);
      for (const pkCol of grant_applicationUniques[0].attributes) spec[pkCol] = get2($specifier, pkCol);
      return resource_grant_applicationPgResource.get(spec);
    }
  },
  GrantApplicationConnection: {
    assertStep: ConnectionStep,
    plans: {
      totalCount($connection) {
        return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint, !1);
      }
    }
  },
  GrantMilestone: {
    assertStep: assertPgClassSingleStep,
    plans: {
      approvedAt($record) {
        return $record.get("approved_at");
      },
      createdAt($record) {
        return $record.get("created_at");
      },
      dueDate($record) {
        return $record.get("due_date");
      },
      grantApplication($record) {
        return resource_grant_applicationPgResource.get({
          id: $record.get("grant_application_id")
        });
      },
      grantApplicationId($record) {
        return $record.get("grant_application_id");
      },
      id($parent) {
        const specifier = nodeIdHandler_GrantMilestone.plan($parent);
        return lambda(specifier, nodeIdCodecs[nodeIdHandler_GrantMilestone.codec.name].encode);
      },
      paidAt($record) {
        return $record.get("paid_at");
      },
      rowId($record) {
        return $record.get("id");
      },
      sequenceOrder($record) {
        return $record.get("sequence_order");
      },
      submittedAt($record) {
        return $record.get("submitted_at");
      },
      transaction($record) {
        return resource_transactionPgResource.get({
          id: $record.get("transaction_id")
        });
      },
      transactionId($record) {
        return $record.get("transaction_id");
      },
      updatedAt($record) {
        return $record.get("updated_at");
      }
    },
    planType($specifier) {
      const spec = Object.create(null);
      for (const pkCol of grant_milestoneUniques[0].attributes) spec[pkCol] = get2($specifier, pkCol);
      return resource_grant_milestonePgResource.get(spec);
    }
  },
  GrantMilestoneConnection: {
    assertStep: ConnectionStep,
    plans: {
      totalCount($connection) {
        return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint, !1);
      }
    }
  },
  GrantProgram: {
    assertStep: assertPgClassSingleStep,
    plans: {
      applicationsCloseAt($record) {
        return $record.get("applications_close_at");
      },
      applicationsOpenAt($record) {
        return $record.get("applications_open_at");
      },
      createdAt($record) {
        return $record.get("created_at");
      },
      deletedAt($record) {
        return $record.get("deleted_at");
      },
      grantApplications: {
        plan($record) {
          const $records = resource_grant_applicationPgResource.find({
            grant_program_id: $record.get("id")
          });
          return connection($records);
        },
        args: {
          first(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          },
          last(_, $connection, val) {
            $connection.setLast(val.getRaw());
          },
          offset(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          },
          before(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          },
          after(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          },
          condition(_condition, $connection, arg) {
            const $select = $connection.getSubplan();
            arg.apply($select, qbWhereBuilder);
          },
          filter(_, $connection, fieldArg) {
            const $pgSelect = $connection.getSubplan();
            fieldArg.apply($pgSelect, (queryBuilder, value) => {
              assertAllowed131(value, "object");
              if (value == null) return;
              const condition = new PgCondition(queryBuilder);
              return condition;
            });
          },
          orderBy(parent, $connection, value) {
            const $select = $connection.getSubplan();
            value.apply($select);
          }
        }
      },
      id($parent) {
        const specifier = nodeIdHandler_GrantProgram.plan($parent);
        return lambda(specifier, nodeIdCodecs[nodeIdHandler_GrantProgram.codec.name].encode);
      },
      isActive($record) {
        return $record.get("is_active");
      },
      maxGrantAmount($record) {
        return $record.get("max_grant_amount");
      },
      minGrantAmount($record) {
        return $record.get("min_grant_amount");
      },
      organization($record) {
        return resource_organizationPgResource.get({
          id: $record.get("organization_id")
        });
      },
      organizationId($record) {
        return $record.get("organization_id");
      },
      remainingBudget($record) {
        return $record.get("remaining_budget");
      },
      rowId($record) {
        return $record.get("id");
      },
      totalBudget($record) {
        return $record.get("total_budget");
      },
      updatedAt($record) {
        return $record.get("updated_at");
      }
    },
    planType($specifier) {
      const spec = Object.create(null);
      for (const pkCol of grant_programUniques[0].attributes) spec[pkCol] = get2($specifier, pkCol);
      return resource_grant_programPgResource.get(spec);
    }
  },
  GrantProgramConnection: {
    assertStep: ConnectionStep,
    plans: {
      totalCount($connection) {
        return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint, !1);
      }
    }
  },
  Organization: {
    assertStep: assertPgClassSingleStep,
    plans: {
      auditLogs: {
        plan($record) {
          const $records = resource_audit_logPgResource.find({
            organization_id: $record.get("id")
          });
          return connection($records);
        },
        args: {
          first(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          },
          last(_, $connection, val) {
            $connection.setLast(val.getRaw());
          },
          offset(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          },
          before(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          },
          after(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          },
          condition(_condition, $connection, arg) {
            const $select = $connection.getSubplan();
            arg.apply($select, qbWhereBuilder);
          },
          filter(_, $connection, fieldArg) {
            const $pgSelect = $connection.getSubplan();
            fieldArg.apply($pgSelect, (queryBuilder, value) => {
              assertAllowed22(value, "object");
              if (value == null) return;
              const condition = new PgCondition(queryBuilder);
              return condition;
            });
          },
          orderBy(parent, $connection, value) {
            const $select = $connection.getSubplan();
            value.apply($select);
          }
        }
      },
      avatarUrl($record) {
        return $record.get("avatar_url");
      },
      bounties: {
        plan($record) {
          const $records = resource_bountyPgResource.find({
            organization_id: $record.get("id")
          });
          return connection($records);
        },
        args: {
          first(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          },
          last(_, $connection, val) {
            $connection.setLast(val.getRaw());
          },
          offset(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          },
          before(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          },
          after(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          },
          condition(_condition, $connection, arg) {
            const $select = $connection.getSubplan();
            arg.apply($select, qbWhereBuilder);
          },
          filter(_, $connection, fieldArg) {
            const $pgSelect = $connection.getSubplan();
            fieldArg.apply($pgSelect, (queryBuilder, value) => {
              assertAllowed23(value, "object");
              if (value == null) return;
              const condition = new PgCondition(queryBuilder);
              return condition;
            });
          },
          orderBy(parent, $connection, value) {
            const $select = $connection.getSubplan();
            value.apply($select);
          }
        }
      },
      createdAt($record) {
        return $record.get("created_at");
      },
      deletedAt($record) {
        return $record.get("deleted_at");
      },
      donations: {
        plan($record) {
          const $records = resource_donationPgResource.find({
            organization_id: $record.get("id")
          });
          return connection($records);
        },
        args: {
          first(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          },
          last(_, $connection, val) {
            $connection.setLast(val.getRaw());
          },
          offset(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          },
          before(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          },
          after(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          },
          condition(_condition, $connection, arg) {
            const $select = $connection.getSubplan();
            arg.apply($select, qbWhereBuilder);
          },
          filter(_, $connection, fieldArg) {
            const $pgSelect = $connection.getSubplan();
            fieldArg.apply($pgSelect, (queryBuilder, value) => {
              assertAllowed24(value, "object");
              if (value == null) return;
              const condition = new PgCondition(queryBuilder);
              return condition;
            });
          },
          orderBy(parent, $connection, value) {
            const $select = $connection.getSubplan();
            value.apply($select);
          }
        }
      },
      goals: {
        plan($record) {
          const $records = resource_goalPgResource.find({
            organization_id: $record.get("id")
          });
          return connection($records);
        },
        args: {
          first(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          },
          last(_, $connection, val) {
            $connection.setLast(val.getRaw());
          },
          offset(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          },
          before(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          },
          after(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          },
          condition(_condition, $connection, arg) {
            const $select = $connection.getSubplan();
            arg.apply($select, qbWhereBuilder);
          },
          filter(_, $connection, fieldArg) {
            const $pgSelect = $connection.getSubplan();
            fieldArg.apply($pgSelect, (queryBuilder, value) => {
              assertAllowed33(value, "object");
              if (value == null) return;
              const condition = new PgCondition(queryBuilder);
              return condition;
            });
          },
          orderBy(parent, $connection, value) {
            const $select = $connection.getSubplan();
            value.apply($select);
          }
        }
      },
      grantPrograms: {
        plan($record) {
          const $records = resource_grant_programPgResource.find({
            organization_id: $record.get("id")
          });
          return connection($records);
        },
        args: {
          first(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          },
          last(_, $connection, val) {
            $connection.setLast(val.getRaw());
          },
          offset(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          },
          before(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          },
          after(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          },
          condition(_condition, $connection, arg) {
            const $select = $connection.getSubplan();
            arg.apply($select, qbWhereBuilder);
          },
          filter(_, $connection, fieldArg) {
            const $pgSelect = $connection.getSubplan();
            fieldArg.apply($pgSelect, (queryBuilder, value) => {
              assertAllowed25(value, "object");
              if (value == null) return;
              const condition = new PgCondition(queryBuilder);
              return condition;
            });
          },
          orderBy(parent, $connection, value) {
            const $select = $connection.getSubplan();
            value.apply($select);
          }
        }
      },
      id($parent) {
        const specifier = nodeIdHandler_Organization.plan($parent);
        return lambda(specifier, nodeIdCodecs[nodeIdHandler_Organization.codec.name].encode);
      },
      isVerified($record) {
        return $record.get("is_verified");
      },
      organizationType($record) {
        return $record.get("organization_type");
      },
      paymentProcessorConnections: {
        plan($record) {
          const $records = resource_payment_processor_connectionPgResource.find({
            organization_id: $record.get("id")
          });
          return connection($records);
        },
        args: {
          first(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          },
          last(_, $connection, val) {
            $connection.setLast(val.getRaw());
          },
          offset(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          },
          before(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          },
          after(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          },
          condition(_condition, $connection, arg) {
            const $select = $connection.getSubplan();
            arg.apply($select, qbWhereBuilder);
          },
          filter(_, $connection, fieldArg) {
            const $pgSelect = $connection.getSubplan();
            fieldArg.apply($pgSelect, (queryBuilder, value) => {
              assertAllowed29(value, "object");
              if (value == null) return;
              const condition = new PgCondition(queryBuilder);
              return condition;
            });
          },
          orderBy(parent, $connection, value) {
            const $select = $connection.getSubplan();
            value.apply($select);
          }
        }
      },
      payoutsByFromOrganizationId: {
        plan($record) {
          const $records = resource_payoutPgResource.find({
            from_organization_id: $record.get("id")
          });
          return connection($records);
        },
        args: {
          first(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          },
          last(_, $connection, val) {
            $connection.setLast(val.getRaw());
          },
          offset(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          },
          before(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          },
          after(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          },
          condition(_condition, $connection, arg) {
            const $select = $connection.getSubplan();
            arg.apply($select, qbWhereBuilder);
          },
          filter(_, $connection, fieldArg) {
            const $pgSelect = $connection.getSubplan();
            fieldArg.apply($pgSelect, (queryBuilder, value) => {
              assertAllowed31(value, "object");
              if (value == null) return;
              const condition = new PgCondition(queryBuilder);
              return condition;
            });
          },
          orderBy(parent, $connection, value) {
            const $select = $connection.getSubplan();
            value.apply($select);
          }
        }
      },
      platformFeePercent($record) {
        return $record.get("platform_fee_percent");
      },
      posts: {
        plan($record) {
          const $records = resource_postPgResource.find({
            organization_id: $record.get("id")
          });
          return connection($records);
        },
        args: {
          first(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          },
          last(_, $connection, val) {
            $connection.setLast(val.getRaw());
          },
          offset(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          },
          before(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          },
          after(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          },
          condition(_condition, $connection, arg) {
            const $select = $connection.getSubplan();
            arg.apply($select, qbWhereBuilder);
          },
          filter(_, $connection, fieldArg) {
            const $pgSelect = $connection.getSubplan();
            fieldArg.apply($pgSelect, (queryBuilder, value) => {
              assertAllowed34(value, "object");
              if (value == null) return;
              const condition = new PgCondition(queryBuilder);
              return condition;
            });
          },
          orderBy(parent, $connection, value) {
            const $select = $connection.getSubplan();
            value.apply($select);
          }
        }
      },
      rowId($record) {
        return $record.get("id");
      },
      sponsorships: {
        plan($record) {
          const $records = resource_sponsorshipPgResource.find({
            organization_id: $record.get("id")
          });
          return connection($records);
        },
        args: {
          first(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          },
          last(_, $connection, val) {
            $connection.setLast(val.getRaw());
          },
          offset(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          },
          before(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          },
          after(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          },
          condition(_condition, $connection, arg) {
            const $select = $connection.getSubplan();
            arg.apply($select, qbWhereBuilder);
          },
          filter(_, $connection, fieldArg) {
            const $pgSelect = $connection.getSubplan();
            fieldArg.apply($pgSelect, (queryBuilder, value) => {
              assertAllowed28(value, "object");
              if (value == null) return;
              const condition = new PgCondition(queryBuilder);
              return condition;
            });
          },
          orderBy(parent, $connection, value) {
            const $select = $connection.getSubplan();
            value.apply($select);
          }
        }
      },
      sponsorshipTiers: {
        plan($record) {
          const $records = resource_sponsorship_tierPgResource.find({
            organization_id: $record.get("id")
          });
          return connection($records);
        },
        args: {
          first(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          },
          last(_, $connection, val) {
            $connection.setLast(val.getRaw());
          },
          offset(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          },
          before(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          },
          after(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          },
          condition(_condition, $connection, arg) {
            const $select = $connection.getSubplan();
            arg.apply($select, qbWhereBuilder);
          },
          filter(_, $connection, fieldArg) {
            const $pgSelect = $connection.getSubplan();
            fieldArg.apply($pgSelect, (queryBuilder, value) => {
              assertAllowed27(value, "object");
              if (value == null) return;
              const condition = new PgCondition(queryBuilder);
              return condition;
            });
          },
          orderBy(parent, $connection, value) {
            const $select = $connection.getSubplan();
            value.apply($select);
          }
        }
      },
      transactionsByToOrganizationId: {
        plan($record) {
          const $records = resource_transactionPgResource.find({
            to_organization_id: $record.get("id")
          });
          return connection($records);
        },
        args: {
          first(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          },
          last(_, $connection, val) {
            $connection.setLast(val.getRaw());
          },
          offset(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          },
          before(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          },
          after(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          },
          condition(_condition, $connection, arg) {
            const $select = $connection.getSubplan();
            arg.apply($select, qbWhereBuilder);
          },
          filter(_, $connection, fieldArg) {
            const $pgSelect = $connection.getSubplan();
            fieldArg.apply($pgSelect, (queryBuilder, value) => {
              assertAllowed30(value, "object");
              if (value == null) return;
              const condition = new PgCondition(queryBuilder);
              return condition;
            });
          },
          orderBy(parent, $connection, value) {
            const $select = $connection.getSubplan();
            value.apply($select);
          }
        }
      },
      updatedAt($record) {
        return $record.get("updated_at");
      },
      userOrganizations: {
        plan($record) {
          const $records = resource_user_organizationPgResource.find({
            organization_id: $record.get("id")
          });
          return connection($records);
        },
        args: {
          first(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          },
          last(_, $connection, val) {
            $connection.setLast(val.getRaw());
          },
          offset(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          },
          before(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          },
          after(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          },
          condition(_condition, $connection, arg) {
            const $select = $connection.getSubplan();
            arg.apply($select, qbWhereBuilder);
          },
          filter(_, $connection, fieldArg) {
            const $pgSelect = $connection.getSubplan();
            fieldArg.apply($pgSelect, (queryBuilder, value) => {
              assertAllowed26(value, "object");
              if (value == null) return;
              const condition = new PgCondition(queryBuilder);
              return condition;
            });
          },
          orderBy(parent, $connection, value) {
            const $select = $connection.getSubplan();
            value.apply($select);
          }
        }
      },
      verifiedAt($record) {
        return $record.get("verified_at");
      },
      webhookEndpoints: {
        plan($record) {
          const $records = resource_webhook_endpointPgResource.find({
            organization_id: $record.get("id")
          });
          return connection($records);
        },
        args: {
          first(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          },
          last(_, $connection, val) {
            $connection.setLast(val.getRaw());
          },
          offset(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          },
          before(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          },
          after(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          },
          condition(_condition, $connection, arg) {
            const $select = $connection.getSubplan();
            arg.apply($select, qbWhereBuilder);
          },
          filter(_, $connection, fieldArg) {
            const $pgSelect = $connection.getSubplan();
            fieldArg.apply($pgSelect, (queryBuilder, value) => {
              assertAllowed32(value, "object");
              if (value == null) return;
              const condition = new PgCondition(queryBuilder);
              return condition;
            });
          },
          orderBy(parent, $connection, value) {
            const $select = $connection.getSubplan();
            value.apply($select);
          }
        }
      },
      websiteUrl($record) {
        return $record.get("website_url");
      }
    },
    planType($specifier) {
      const spec = Object.create(null);
      for (const pkCol of organizationUniques[0].attributes) spec[pkCol] = get2($specifier, pkCol);
      return resource_organizationPgResource.get(spec);
    }
  },
  OrganizationConnection: {
    assertStep: ConnectionStep,
    plans: {
      totalCount($connection) {
        return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint, !1);
      }
    }
  },
  PaymentProcessorConnection: {
    assertStep: assertPgClassSingleStep,
    plans: {
      createdAt($record) {
        return $record.get("created_at");
      },
      deletedAt($record) {
        return $record.get("deleted_at");
      },
      displayName($record) {
        return $record.get("display_name");
      },
      externalAccountId($record) {
        return $record.get("external_account_id");
      },
      id($parent) {
        const specifier = nodeIdHandler_PaymentProcessorConnection.plan($parent);
        return lambda(specifier, nodeIdCodecs[nodeIdHandler_PaymentProcessorConnection.codec.name].encode);
      },
      isActive($record) {
        return $record.get("is_active");
      },
      isPrimary($record) {
        return $record.get("is_primary");
      },
      isVerified($record) {
        return $record.get("is_verified");
      },
      organization($record) {
        return resource_organizationPgResource.get({
          id: $record.get("organization_id")
        });
      },
      organizationId($record) {
        return $record.get("organization_id");
      },
      rowId($record) {
        return $record.get("id");
      },
      transactionsByProcessorConnectionId: {
        plan($record) {
          const $records = resource_transactionPgResource.find({
            processor_connection_id: $record.get("id")
          });
          return connection($records);
        },
        args: {
          first(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          },
          last(_, $connection, val) {
            $connection.setLast(val.getRaw());
          },
          offset(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          },
          before(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          },
          after(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          },
          condition(_condition, $connection, arg) {
            const $select = $connection.getSubplan();
            arg.apply($select, qbWhereBuilder);
          },
          filter(_, $connection, fieldArg) {
            const $pgSelect = $connection.getSubplan();
            fieldArg.apply($pgSelect, (queryBuilder, value) => {
              assertAllowed129(value, "object");
              if (value == null) return;
              const condition = new PgCondition(queryBuilder);
              return condition;
            });
          },
          orderBy(parent, $connection, value) {
            const $select = $connection.getSubplan();
            value.apply($select);
          }
        }
      },
      updatedAt($record) {
        return $record.get("updated_at");
      },
      verifiedAt($record) {
        return $record.get("verified_at");
      }
    },
    planType($specifier) {
      const spec = Object.create(null);
      for (const pkCol of payment_processor_connectionUniques[0].attributes) spec[pkCol] = get2($specifier, pkCol);
      return resource_payment_processor_connectionPgResource.get(spec);
    }
  },
  PaymentProcessorConnectionConnection: {
    assertStep: ConnectionStep,
    plans: {
      totalCount($connection) {
        return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint, !1);
      }
    }
  },
  Payout: {
    assertStep: assertPgClassSingleStep,
    plans: {
      completedAt($record) {
        return $record.get("completed_at");
      },
      createdAt($record) {
        return $record.get("created_at");
      },
      externalPayoutId($record) {
        return $record.get("external_payout_id");
      },
      failureReason($record) {
        return $record.get("failure_reason");
      },
      feeAmount($record) {
        return $record.get("fee_amount");
      },
      fromOrganization($record) {
        return resource_organizationPgResource.get({
          id: $record.get("from_organization_id")
        });
      },
      fromOrganizationId($record) {
        return $record.get("from_organization_id");
      },
      id($parent) {
        const specifier = nodeIdHandler_Payout.plan($parent);
        return lambda(specifier, nodeIdCodecs[nodeIdHandler_Payout.codec.name].encode);
      },
      initiatedAt($record) {
        return $record.get("initiated_at");
      },
      processorConnection($record) {
        return resource_payment_processor_connectionPgResource.get({
          id: $record.get("processor_connection_id")
        });
      },
      processorConnectionId($record) {
        return $record.get("processor_connection_id");
      },
      recipientUser($record) {
        return resource_userPgResource.get({
          id: $record.get("recipient_user_id")
        });
      },
      recipientUserId($record) {
        return $record.get("recipient_user_id");
      },
      rowId($record) {
        return $record.get("id");
      },
      updatedAt($record) {
        return $record.get("updated_at");
      }
    },
    planType($specifier) {
      const spec = Object.create(null);
      for (const pkCol of payoutUniques[0].attributes) spec[pkCol] = get2($specifier, pkCol);
      return resource_payoutPgResource.get(spec);
    }
  },
  PayoutConnection: {
    assertStep: ConnectionStep,
    plans: {
      totalCount($connection) {
        return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint, !1);
      }
    }
  },
  Post: {
    assertStep: assertPgClassSingleStep,
    plans: {
      author($record) {
        return resource_userPgResource.get({
          id: $record.get("author_id")
        });
      },
      authorId($record) {
        return $record.get("author_id");
      },
      createdAt($record) {
        return $record.get("created_at");
      },
      deletedAt($record) {
        return $record.get("deleted_at");
      },
      id($parent) {
        const specifier = nodeIdHandler_Post.plan($parent);
        return lambda(specifier, nodeIdCodecs[nodeIdHandler_Post.codec.name].encode);
      },
      isPublished($record) {
        return $record.get("is_published");
      },
      minimumTier($record) {
        return resource_sponsorship_tierPgResource.get({
          id: $record.get("minimum_tier_id")
        });
      },
      minimumTierId($record) {
        return $record.get("minimum_tier_id");
      },
      organization($record) {
        return resource_organizationPgResource.get({
          id: $record.get("organization_id")
        });
      },
      organizationId($record) {
        return $record.get("organization_id");
      },
      publishedAt($record) {
        return $record.get("published_at");
      },
      rowId($record) {
        return $record.get("id");
      },
      updatedAt($record) {
        return $record.get("updated_at");
      }
    },
    planType($specifier) {
      const spec = Object.create(null);
      for (const pkCol of postUniques[0].attributes) spec[pkCol] = get2($specifier, pkCol);
      return resource_postPgResource.get(spec);
    }
  },
  PostConnection: {
    assertStep: ConnectionStep,
    plans: {
      totalCount($connection) {
        return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint, !1);
      }
    }
  },
  Sponsorship: {
    assertStep: assertPgClassSingleStep,
    plans: {
      cancelledAt($record) {
        return $record.get("cancelled_at");
      },
      createdAt($record) {
        return $record.get("created_at");
      },
      currentPeriodEnd($record) {
        return $record.get("current_period_end");
      },
      currentPeriodStart($record) {
        return $record.get("current_period_start");
      },
      externalSubscriptionId($record) {
        return $record.get("external_subscription_id");
      },
      id($parent) {
        const specifier = nodeIdHandler_Sponsorship.plan($parent);
        return lambda(specifier, nodeIdCodecs[nodeIdHandler_Sponsorship.codec.name].encode);
      },
      isPublic($record) {
        return $record.get("is_public");
      },
      nextBillingDate($record) {
        return $record.get("next_billing_date");
      },
      organization($record) {
        return resource_organizationPgResource.get({
          id: $record.get("organization_id")
        });
      },
      organizationId($record) {
        return $record.get("organization_id");
      },
      publicMessage($record) {
        return $record.get("public_message");
      },
      rowId($record) {
        return $record.get("id");
      },
      sponsor($record) {
        return resource_userPgResource.get({
          id: $record.get("sponsor_id")
        });
      },
      sponsorId($record) {
        return $record.get("sponsor_id");
      },
      startedAt($record) {
        return $record.get("started_at");
      },
      tier($record) {
        return resource_sponsorship_tierPgResource.get({
          id: $record.get("tier_id")
        });
      },
      tierId($record) {
        return $record.get("tier_id");
      },
      updatedAt($record) {
        return $record.get("updated_at");
      }
    },
    planType($specifier) {
      const spec = Object.create(null);
      for (const pkCol of sponsorshipUniques[0].attributes) spec[pkCol] = get2($specifier, pkCol);
      return resource_sponsorshipPgResource.get(spec);
    }
  },
  SponsorshipConnection: {
    assertStep: ConnectionStep,
    plans: {
      totalCount($connection) {
        return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint, !1);
      }
    }
  },
  SponsorshipTier: {
    assertStep: assertPgClassSingleStep,
    plans: {
      createdAt($record) {
        return $record.get("created_at");
      },
      deletedAt($record) {
        return $record.get("deleted_at");
      },
      displayOrder($record) {
        return $record.get("display_order");
      },
      id($parent) {
        const specifier = nodeIdHandler_SponsorshipTier.plan($parent);
        return lambda(specifier, nodeIdCodecs[nodeIdHandler_SponsorshipTier.codec.name].encode);
      },
      isActive($record) {
        return $record.get("is_active");
      },
      isHighlighted($record) {
        return $record.get("is_highlighted");
      },
      maxSponsors($record) {
        return $record.get("max_sponsors");
      },
      monthlyAmount($record) {
        return $record.get("monthly_amount");
      },
      organization($record) {
        return resource_organizationPgResource.get({
          id: $record.get("organization_id")
        });
      },
      organizationId($record) {
        return $record.get("organization_id");
      },
      rowId($record) {
        return $record.get("id");
      },
      sponsorshipsByTierId: {
        plan($record) {
          const $records = resource_sponsorshipPgResource.find({
            tier_id: $record.get("id")
          });
          return connection($records);
        },
        args: {
          first(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          },
          last(_, $connection, val) {
            $connection.setLast(val.getRaw());
          },
          offset(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          },
          before(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          },
          after(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          },
          condition(_condition, $connection, arg) {
            const $select = $connection.getSubplan();
            arg.apply($select, qbWhereBuilder);
          },
          filter(_, $connection, fieldArg) {
            const $pgSelect = $connection.getSubplan();
            fieldArg.apply($pgSelect, (queryBuilder, value) => {
              assertAllowed132(value, "object");
              if (value == null) return;
              const condition = new PgCondition(queryBuilder);
              return condition;
            });
          },
          orderBy(parent, $connection, value) {
            const $select = $connection.getSubplan();
            value.apply($select);
          }
        }
      },
      updatedAt($record) {
        return $record.get("updated_at");
      },
      yearlyAmount($record) {
        return $record.get("yearly_amount");
      }
    },
    planType($specifier) {
      const spec = Object.create(null);
      for (const pkCol of sponsorship_tierUniques[0].attributes) spec[pkCol] = get2($specifier, pkCol);
      return resource_sponsorship_tierPgResource.get(spec);
    }
  },
  SponsorshipTierConnection: {
    assertStep: ConnectionStep,
    plans: {
      totalCount($connection) {
        return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint, !1);
      }
    }
  },
  Transaction: {
    assertStep: assertPgClassSingleStep,
    plans: {
      bountyFundings: {
        plan($record) {
          const $records = resource_bounty_fundingPgResource.find({
            transaction_id: $record.get("id")
          });
          return connection($records);
        },
        args: {
          first(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          },
          last(_, $connection, val) {
            $connection.setLast(val.getRaw());
          },
          offset(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          },
          before(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          },
          after(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          },
          condition(_condition, $connection, arg) {
            const $select = $connection.getSubplan();
            arg.apply($select, qbWhereBuilder);
          },
          filter(_, $connection, fieldArg) {
            const $pgSelect = $connection.getSubplan();
            fieldArg.apply($pgSelect, (queryBuilder, value) => {
              assertAllowed127(value, "object");
              if (value == null) return;
              const condition = new PgCondition(queryBuilder);
              return condition;
            });
          },
          orderBy(parent, $connection, value) {
            const $select = $connection.getSubplan();
            value.apply($select);
          }
        }
      },
      createdAt($record) {
        return $record.get("created_at");
      },
      donations: {
        plan($record) {
          const $records = resource_donationPgResource.find({
            transaction_id: $record.get("id")
          });
          return connection($records);
        },
        args: {
          first(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          },
          last(_, $connection, val) {
            $connection.setLast(val.getRaw());
          },
          offset(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          },
          before(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          },
          after(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          },
          condition(_condition, $connection, arg) {
            const $select = $connection.getSubplan();
            arg.apply($select, qbWhereBuilder);
          },
          filter(_, $connection, fieldArg) {
            const $pgSelect = $connection.getSubplan();
            fieldArg.apply($pgSelect, (queryBuilder, value) => {
              assertAllowed128(value, "object");
              if (value == null) return;
              const condition = new PgCondition(queryBuilder);
              return condition;
            });
          },
          orderBy(parent, $connection, value) {
            const $select = $connection.getSubplan();
            value.apply($select);
          }
        }
      },
      externalTransactionId($record) {
        return $record.get("external_transaction_id");
      },
      failureReason($record) {
        return $record.get("failure_reason");
      },
      fromUser($record) {
        return resource_userPgResource.get({
          id: $record.get("from_user_id")
        });
      },
      fromUserId($record) {
        return $record.get("from_user_id");
      },
      grossAmount($record) {
        return $record.get("gross_amount");
      },
      id($parent) {
        const specifier = nodeIdHandler_Transaction.plan($parent);
        return lambda(specifier, nodeIdCodecs[nodeIdHandler_Transaction.codec.name].encode);
      },
      netAmount($record) {
        return $record.get("net_amount");
      },
      originalTransactionId($record) {
        return $record.get("original_transaction_id");
      },
      platformFeeAmount($record) {
        return $record.get("platform_fee_amount");
      },
      processedAt($record) {
        return $record.get("processed_at");
      },
      processorConnection($record) {
        return resource_payment_processor_connectionPgResource.get({
          id: $record.get("processor_connection_id")
        });
      },
      processorConnectionId($record) {
        return $record.get("processor_connection_id");
      },
      processorFeeAmount($record) {
        return $record.get("processor_fee_amount");
      },
      refundedAmount($record) {
        return $record.get("refunded_amount");
      },
      rowId($record) {
        return $record.get("id");
      },
      toOrganization($record) {
        return resource_organizationPgResource.get({
          id: $record.get("to_organization_id")
        });
      },
      toOrganizationId($record) {
        return $record.get("to_organization_id");
      },
      toUser($record) {
        return resource_userPgResource.get({
          id: $record.get("to_user_id")
        });
      },
      toUserId($record) {
        return $record.get("to_user_id");
      },
      transactionType($record) {
        return $record.get("transaction_type");
      },
      updatedAt($record) {
        return $record.get("updated_at");
      }
    },
    planType($specifier) {
      const spec = Object.create(null);
      for (const pkCol of transactionUniques[0].attributes) spec[pkCol] = get2($specifier, pkCol);
      return resource_transactionPgResource.get(spec);
    }
  },
  TransactionConnection: {
    assertStep: ConnectionStep,
    plans: {
      totalCount($connection) {
        return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint, !1);
      }
    }
  },
  UpdateAuditLogPayload: {
    assertStep: ObjectStep,
    plans: {
      auditLog($object) {
        return $object.get("result");
      },
      auditLogEdge($mutation, fieldArgs) {
        return pgMutationPayloadEdge(resource_audit_logPgResource, audit_logUniques[0].attributes, $mutation, fieldArgs);
      },
      clientMutationId($mutation) {
        return $mutation.getStepForKey("result").getMeta("clientMutationId");
      },
      query() {
        return rootValue();
      }
    }
  },
  UpdateBountyFundingPayload: {
    assertStep: ObjectStep,
    plans: {
      bountyFunding($object) {
        return $object.get("result");
      },
      bountyFundingEdge($mutation, fieldArgs) {
        return pgMutationPayloadEdge(resource_bounty_fundingPgResource, bounty_fundingUniques[0].attributes, $mutation, fieldArgs);
      },
      clientMutationId($mutation) {
        return $mutation.getStepForKey("result").getMeta("clientMutationId");
      },
      query() {
        return rootValue();
      }
    }
  },
  UpdateBountyPayload: {
    assertStep: ObjectStep,
    plans: {
      bounty($object) {
        return $object.get("result");
      },
      bountyEdge($mutation, fieldArgs) {
        return pgMutationPayloadEdge(resource_bountyPgResource, bountyUniques[0].attributes, $mutation, fieldArgs);
      },
      clientMutationId($mutation) {
        return $mutation.getStepForKey("result").getMeta("clientMutationId");
      },
      query() {
        return rootValue();
      }
    }
  },
  UpdateDonationPayload: {
    assertStep: ObjectStep,
    plans: {
      clientMutationId($mutation) {
        return $mutation.getStepForKey("result").getMeta("clientMutationId");
      },
      donation($object) {
        return $object.get("result");
      },
      donationEdge($mutation, fieldArgs) {
        return pgMutationPayloadEdge(resource_donationPgResource, donationUniques[0].attributes, $mutation, fieldArgs);
      },
      query() {
        return rootValue();
      }
    }
  },
  UpdateGoalPayload: {
    assertStep: ObjectStep,
    plans: {
      clientMutationId($mutation) {
        return $mutation.getStepForKey("result").getMeta("clientMutationId");
      },
      goal($object) {
        return $object.get("result");
      },
      goalEdge($mutation, fieldArgs) {
        return pgMutationPayloadEdge(resource_goalPgResource, goalUniques[0].attributes, $mutation, fieldArgs);
      },
      query() {
        return rootValue();
      }
    }
  },
  UpdateGrantApplicationPayload: {
    assertStep: ObjectStep,
    plans: {
      clientMutationId($mutation) {
        return $mutation.getStepForKey("result").getMeta("clientMutationId");
      },
      grantApplication($object) {
        return $object.get("result");
      },
      grantApplicationEdge($mutation, fieldArgs) {
        return pgMutationPayloadEdge(resource_grant_applicationPgResource, grant_applicationUniques[0].attributes, $mutation, fieldArgs);
      },
      query() {
        return rootValue();
      }
    }
  },
  UpdateGrantMilestonePayload: {
    assertStep: ObjectStep,
    plans: {
      clientMutationId($mutation) {
        return $mutation.getStepForKey("result").getMeta("clientMutationId");
      },
      grantMilestone($object) {
        return $object.get("result");
      },
      grantMilestoneEdge($mutation, fieldArgs) {
        return pgMutationPayloadEdge(resource_grant_milestonePgResource, grant_milestoneUniques[0].attributes, $mutation, fieldArgs);
      },
      query() {
        return rootValue();
      }
    }
  },
  UpdateGrantProgramPayload: {
    assertStep: ObjectStep,
    plans: {
      clientMutationId($mutation) {
        return $mutation.getStepForKey("result").getMeta("clientMutationId");
      },
      grantProgram($object) {
        return $object.get("result");
      },
      grantProgramEdge($mutation, fieldArgs) {
        return pgMutationPayloadEdge(resource_grant_programPgResource, grant_programUniques[0].attributes, $mutation, fieldArgs);
      },
      query() {
        return rootValue();
      }
    }
  },
  UpdateOrganizationPayload: {
    assertStep: ObjectStep,
    plans: {
      clientMutationId($mutation) {
        return $mutation.getStepForKey("result").getMeta("clientMutationId");
      },
      organization($object) {
        return $object.get("result");
      },
      organizationEdge($mutation, fieldArgs) {
        return pgMutationPayloadEdge(resource_organizationPgResource, organizationUniques[0].attributes, $mutation, fieldArgs);
      },
      query() {
        return rootValue();
      }
    }
  },
  UpdatePaymentProcessorConnectionPayload: {
    assertStep: ObjectStep,
    plans: {
      clientMutationId($mutation) {
        return $mutation.getStepForKey("result").getMeta("clientMutationId");
      },
      paymentProcessorConnection($object) {
        return $object.get("result");
      },
      paymentProcessorConnectionEdge($mutation, fieldArgs) {
        return pgMutationPayloadEdge(resource_payment_processor_connectionPgResource, payment_processor_connectionUniques[0].attributes, $mutation, fieldArgs);
      },
      query() {
        return rootValue();
      }
    }
  },
  UpdatePayoutPayload: {
    assertStep: ObjectStep,
    plans: {
      clientMutationId($mutation) {
        return $mutation.getStepForKey("result").getMeta("clientMutationId");
      },
      payout($object) {
        return $object.get("result");
      },
      payoutEdge($mutation, fieldArgs) {
        return pgMutationPayloadEdge(resource_payoutPgResource, payoutUniques[0].attributes, $mutation, fieldArgs);
      },
      query() {
        return rootValue();
      }
    }
  },
  UpdatePostPayload: {
    assertStep: ObjectStep,
    plans: {
      clientMutationId($mutation) {
        return $mutation.getStepForKey("result").getMeta("clientMutationId");
      },
      post($object) {
        return $object.get("result");
      },
      postEdge($mutation, fieldArgs) {
        return pgMutationPayloadEdge(resource_postPgResource, postUniques[0].attributes, $mutation, fieldArgs);
      },
      query() {
        return rootValue();
      }
    }
  },
  UpdateSponsorshipPayload: {
    assertStep: ObjectStep,
    plans: {
      clientMutationId($mutation) {
        return $mutation.getStepForKey("result").getMeta("clientMutationId");
      },
      query() {
        return rootValue();
      },
      sponsorship($object) {
        return $object.get("result");
      },
      sponsorshipEdge($mutation, fieldArgs) {
        return pgMutationPayloadEdge(resource_sponsorshipPgResource, sponsorshipUniques[0].attributes, $mutation, fieldArgs);
      }
    }
  },
  UpdateSponsorshipTierPayload: {
    assertStep: ObjectStep,
    plans: {
      clientMutationId($mutation) {
        return $mutation.getStepForKey("result").getMeta("clientMutationId");
      },
      query() {
        return rootValue();
      },
      sponsorshipTier($object) {
        return $object.get("result");
      },
      sponsorshipTierEdge($mutation, fieldArgs) {
        return pgMutationPayloadEdge(resource_sponsorship_tierPgResource, sponsorship_tierUniques[0].attributes, $mutation, fieldArgs);
      }
    }
  },
  UpdateTransactionPayload: {
    assertStep: ObjectStep,
    plans: {
      clientMutationId($mutation) {
        return $mutation.getStepForKey("result").getMeta("clientMutationId");
      },
      query() {
        return rootValue();
      },
      transaction($object) {
        return $object.get("result");
      },
      transactionEdge($mutation, fieldArgs) {
        return pgMutationPayloadEdge(resource_transactionPgResource, transactionUniques[0].attributes, $mutation, fieldArgs);
      }
    }
  },
  UpdateUserIdentityPayload: {
    assertStep: ObjectStep,
    plans: {
      clientMutationId($mutation) {
        return $mutation.getStepForKey("result").getMeta("clientMutationId");
      },
      query() {
        return rootValue();
      },
      userIdentity($object) {
        return $object.get("result");
      },
      userIdentityEdge($mutation, fieldArgs) {
        return pgMutationPayloadEdge(resource_user_identityPgResource, user_identityUniques[0].attributes, $mutation, fieldArgs);
      }
    }
  },
  UpdateUserOrganizationPayload: {
    assertStep: ObjectStep,
    plans: {
      clientMutationId($mutation) {
        return $mutation.getStepForKey("result").getMeta("clientMutationId");
      },
      query() {
        return rootValue();
      },
      userOrganization($object) {
        return $object.get("result");
      },
      userOrganizationEdge($mutation, fieldArgs) {
        return pgMutationPayloadEdge(resource_user_organizationPgResource, user_organizationUniques[0].attributes, $mutation, fieldArgs);
      }
    }
  },
  UpdateUserPayload: {
    assertStep: ObjectStep,
    plans: {
      clientMutationId($mutation) {
        return $mutation.getStepForKey("result").getMeta("clientMutationId");
      },
      query() {
        return rootValue();
      },
      user($object) {
        return $object.get("result");
      },
      userEdge($mutation, fieldArgs) {
        return pgMutationPayloadEdge(resource_userPgResource, userUniques[0].attributes, $mutation, fieldArgs);
      }
    }
  },
  UpdateWebhookDeliveryPayload: {
    assertStep: ObjectStep,
    plans: {
      clientMutationId($mutation) {
        return $mutation.getStepForKey("result").getMeta("clientMutationId");
      },
      query() {
        return rootValue();
      },
      webhookDelivery($object) {
        return $object.get("result");
      },
      webhookDeliveryEdge($mutation, fieldArgs) {
        return pgMutationPayloadEdge(resource_webhook_deliveryPgResource, webhook_deliveryUniques[0].attributes, $mutation, fieldArgs);
      }
    }
  },
  UpdateWebhookEndpointPayload: {
    assertStep: ObjectStep,
    plans: {
      clientMutationId($mutation) {
        return $mutation.getStepForKey("result").getMeta("clientMutationId");
      },
      query() {
        return rootValue();
      },
      webhookEndpoint($object) {
        return $object.get("result");
      },
      webhookEndpointEdge($mutation, fieldArgs) {
        return pgMutationPayloadEdge(resource_webhook_endpointPgResource, webhook_endpointUniques[0].attributes, $mutation, fieldArgs);
      }
    }
  },
  UpdateWorkspacePayload: {
    assertStep: ObjectStep,
    plans: {
      clientMutationId($mutation) {
        return $mutation.getStepForKey("result").getMeta("clientMutationId");
      },
      query() {
        return rootValue();
      },
      workspace($object) {
        return $object.get("result");
      },
      workspaceEdge($mutation, fieldArgs) {
        return pgMutationPayloadEdge(resource_workspacePgResource, workspaceUniques[0].attributes, $mutation, fieldArgs);
      }
    }
  },
  User: {
    assertStep: assertPgClassSingleStep,
    plans: {
      auditLogsByActorUserId: {
        plan($record) {
          const $records = resource_audit_logPgResource.find({
            actor_user_id: $record.get("id")
          });
          return connection($records);
        },
        args: {
          first(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          },
          last(_, $connection, val) {
            $connection.setLast(val.getRaw());
          },
          offset(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          },
          before(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          },
          after(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          },
          condition(_condition, $connection, arg) {
            const $select = $connection.getSubplan();
            arg.apply($select, qbWhereBuilder);
          },
          filter(_, $connection, fieldArg) {
            const $pgSelect = $connection.getSubplan();
            fieldArg.apply($pgSelect, (queryBuilder, value) => {
              assertAllowed35(value, "object");
              if (value == null) return;
              const condition = new PgCondition(queryBuilder);
              return condition;
            });
          },
          orderBy(parent, $connection, value) {
            const $select = $connection.getSubplan();
            value.apply($select);
          }
        }
      },
      authoredPosts: {
        plan($record) {
          const $records = resource_postPgResource.find({
            author_id: $record.get("id")
          });
          return connection($records);
        },
        args: {
          first(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          },
          last(_, $connection, val) {
            $connection.setLast(val.getRaw());
          },
          offset(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          },
          before(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          },
          after(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          },
          condition(_condition, $connection, arg) {
            const $select = $connection.getSubplan();
            arg.apply($select, qbWhereBuilder);
          },
          filter(_, $connection, fieldArg) {
            const $pgSelect = $connection.getSubplan();
            fieldArg.apply($pgSelect, (queryBuilder, value) => {
              assertAllowed46(value, "object");
              if (value == null) return;
              const condition = new PgCondition(queryBuilder);
              return condition;
            });
          },
          orderBy(parent, $connection, value) {
            const $select = $connection.getSubplan();
            value.apply($select);
          }
        }
      },
      avatarUrl($record) {
        return $record.get("avatar_url");
      },
      bountiesByClaimantId: {
        plan($record) {
          const $records = resource_bountyPgResource.find({
            claimant_id: $record.get("id")
          });
          return connection($records);
        },
        args: {
          first(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          },
          last(_, $connection, val) {
            $connection.setLast(val.getRaw());
          },
          offset(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          },
          before(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          },
          after(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          },
          condition(_condition, $connection, arg) {
            const $select = $connection.getSubplan();
            arg.apply($select, qbWhereBuilder);
          },
          filter(_, $connection, fieldArg) {
            const $pgSelect = $connection.getSubplan();
            fieldArg.apply($pgSelect, (queryBuilder, value) => {
              assertAllowed36(value, "object");
              if (value == null) return;
              const condition = new PgCondition(queryBuilder);
              return condition;
            });
          },
          orderBy(parent, $connection, value) {
            const $select = $connection.getSubplan();
            value.apply($select);
          }
        }
      },
      bountyFundingsByFunderId: {
        plan($record) {
          const $records = resource_bounty_fundingPgResource.find({
            funder_id: $record.get("id")
          });
          return connection($records);
        },
        args: {
          first(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          },
          last(_, $connection, val) {
            $connection.setLast(val.getRaw());
          },
          offset(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          },
          before(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          },
          after(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          },
          condition(_condition, $connection, arg) {
            const $select = $connection.getSubplan();
            arg.apply($select, qbWhereBuilder);
          },
          filter(_, $connection, fieldArg) {
            const $pgSelect = $connection.getSubplan();
            fieldArg.apply($pgSelect, (queryBuilder, value) => {
              assertAllowed37(value, "object");
              if (value == null) return;
              const condition = new PgCondition(queryBuilder);
              return condition;
            });
          },
          orderBy(parent, $connection, value) {
            const $select = $connection.getSubplan();
            value.apply($select);
          }
        }
      },
      createdAt($record) {
        return $record.get("created_at");
      },
      deletedAt($record) {
        return $record.get("deleted_at");
      },
      displayName($record) {
        return $record.get("display_name");
      },
      donationsByDonorId: {
        plan($record) {
          const $records = resource_donationPgResource.find({
            donor_id: $record.get("id")
          });
          return connection($records);
        },
        args: {
          first(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          },
          last(_, $connection, val) {
            $connection.setLast(val.getRaw());
          },
          offset(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          },
          before(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          },
          after(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          },
          condition(_condition, $connection, arg) {
            const $select = $connection.getSubplan();
            arg.apply($select, qbWhereBuilder);
          },
          filter(_, $connection, fieldArg) {
            const $pgSelect = $connection.getSubplan();
            fieldArg.apply($pgSelect, (queryBuilder, value) => {
              assertAllowed38(value, "object");
              if (value == null) return;
              const condition = new PgCondition(queryBuilder);
              return condition;
            });
          },
          orderBy(parent, $connection, value) {
            const $select = $connection.getSubplan();
            value.apply($select);
          }
        }
      },
      grantApplicationsByApplicantId: {
        plan($record) {
          const $records = resource_grant_applicationPgResource.find({
            applicant_id: $record.get("id")
          });
          return connection($records);
        },
        args: {
          first(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          },
          last(_, $connection, val) {
            $connection.setLast(val.getRaw());
          },
          offset(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          },
          before(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          },
          after(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          },
          condition(_condition, $connection, arg) {
            const $select = $connection.getSubplan();
            arg.apply($select, qbWhereBuilder);
          },
          filter(_, $connection, fieldArg) {
            const $pgSelect = $connection.getSubplan();
            fieldArg.apply($pgSelect, (queryBuilder, value) => {
              assertAllowed39(value, "object");
              if (value == null) return;
              const condition = new PgCondition(queryBuilder);
              return condition;
            });
          },
          orderBy(parent, $connection, value) {
            const $select = $connection.getSubplan();
            value.apply($select);
          }
        }
      },
      id($parent) {
        const specifier = nodeIdHandler_User.plan($parent);
        return lambda(specifier, nodeIdCodecs[nodeIdHandler_User.codec.name].encode);
      },
      payoutsByRecipientUserId: {
        plan($record) {
          const $records = resource_payoutPgResource.find({
            recipient_user_id: $record.get("id")
          });
          return connection($records);
        },
        args: {
          first(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          },
          last(_, $connection, val) {
            $connection.setLast(val.getRaw());
          },
          offset(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          },
          before(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          },
          after(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          },
          condition(_condition, $connection, arg) {
            const $select = $connection.getSubplan();
            arg.apply($select, qbWhereBuilder);
          },
          filter(_, $connection, fieldArg) {
            const $pgSelect = $connection.getSubplan();
            fieldArg.apply($pgSelect, (queryBuilder, value) => {
              assertAllowed45(value, "object");
              if (value == null) return;
              const condition = new PgCondition(queryBuilder);
              return condition;
            });
          },
          orderBy(parent, $connection, value) {
            const $select = $connection.getSubplan();
            value.apply($select);
          }
        }
      },
      rowId($record) {
        return $record.get("id");
      },
      sponsorshipsBySponsorId: {
        plan($record) {
          const $records = resource_sponsorshipPgResource.find({
            sponsor_id: $record.get("id")
          });
          return connection($records);
        },
        args: {
          first(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          },
          last(_, $connection, val) {
            $connection.setLast(val.getRaw());
          },
          offset(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          },
          before(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          },
          after(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          },
          condition(_condition, $connection, arg) {
            const $select = $connection.getSubplan();
            arg.apply($select, qbWhereBuilder);
          },
          filter(_, $connection, fieldArg) {
            const $pgSelect = $connection.getSubplan();
            fieldArg.apply($pgSelect, (queryBuilder, value) => {
              assertAllowed42(value, "object");
              if (value == null) return;
              const condition = new PgCondition(queryBuilder);
              return condition;
            });
          },
          orderBy(parent, $connection, value) {
            const $select = $connection.getSubplan();
            value.apply($select);
          }
        }
      },
      transactionsByFromUserId: {
        plan($record) {
          const $records = resource_transactionPgResource.find({
            from_user_id: $record.get("id")
          });
          return connection($records);
        },
        args: {
          first(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          },
          last(_, $connection, val) {
            $connection.setLast(val.getRaw());
          },
          offset(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          },
          before(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          },
          after(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          },
          condition(_condition, $connection, arg) {
            const $select = $connection.getSubplan();
            arg.apply($select, qbWhereBuilder);
          },
          filter(_, $connection, fieldArg) {
            const $pgSelect = $connection.getSubplan();
            fieldArg.apply($pgSelect, (queryBuilder, value) => {
              assertAllowed43(value, "object");
              if (value == null) return;
              const condition = new PgCondition(queryBuilder);
              return condition;
            });
          },
          orderBy(parent, $connection, value) {
            const $select = $connection.getSubplan();
            value.apply($select);
          }
        }
      },
      transactionsByToUserId: {
        plan($record) {
          const $records = resource_transactionPgResource.find({
            to_user_id: $record.get("id")
          });
          return connection($records);
        },
        args: {
          first(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          },
          last(_, $connection, val) {
            $connection.setLast(val.getRaw());
          },
          offset(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          },
          before(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          },
          after(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          },
          condition(_condition, $connection, arg) {
            const $select = $connection.getSubplan();
            arg.apply($select, qbWhereBuilder);
          },
          filter(_, $connection, fieldArg) {
            const $pgSelect = $connection.getSubplan();
            fieldArg.apply($pgSelect, (queryBuilder, value) => {
              assertAllowed44(value, "object");
              if (value == null) return;
              const condition = new PgCondition(queryBuilder);
              return condition;
            });
          },
          orderBy(parent, $connection, value) {
            const $select = $connection.getSubplan();
            value.apply($select);
          }
        }
      },
      updatedAt($record) {
        return $record.get("updated_at");
      },
      userIdentities: {
        plan($record) {
          const $records = resource_user_identityPgResource.find({
            user_id: $record.get("id")
          });
          return connection($records);
        },
        args: {
          first(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          },
          last(_, $connection, val) {
            $connection.setLast(val.getRaw());
          },
          offset(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          },
          before(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          },
          after(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          },
          condition(_condition, $connection, arg) {
            const $select = $connection.getSubplan();
            arg.apply($select, qbWhereBuilder);
          },
          filter(_, $connection, fieldArg) {
            const $pgSelect = $connection.getSubplan();
            fieldArg.apply($pgSelect, (queryBuilder, value) => {
              assertAllowed40(value, "object");
              if (value == null) return;
              const condition = new PgCondition(queryBuilder);
              return condition;
            });
          },
          orderBy(parent, $connection, value) {
            const $select = $connection.getSubplan();
            value.apply($select);
          }
        }
      },
      userOrganizations: {
        plan($record) {
          const $records = resource_user_organizationPgResource.find({
            user_id: $record.get("id")
          });
          return connection($records);
        },
        args: {
          first(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          },
          last(_, $connection, val) {
            $connection.setLast(val.getRaw());
          },
          offset(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          },
          before(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          },
          after(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          },
          condition(_condition, $connection, arg) {
            const $select = $connection.getSubplan();
            arg.apply($select, qbWhereBuilder);
          },
          filter(_, $connection, fieldArg) {
            const $pgSelect = $connection.getSubplan();
            fieldArg.apply($pgSelect, (queryBuilder, value) => {
              assertAllowed41(value, "object");
              if (value == null) return;
              const condition = new PgCondition(queryBuilder);
              return condition;
            });
          },
          orderBy(parent, $connection, value) {
            const $select = $connection.getSubplan();
            value.apply($select);
          }
        }
      },
      websiteUrl($record) {
        return $record.get("website_url");
      }
    },
    planType($specifier) {
      const spec = Object.create(null);
      for (const pkCol of userUniques[0].attributes) spec[pkCol] = get2($specifier, pkCol);
      return resource_userPgResource.get(spec);
    }
  },
  UserConnection: {
    assertStep: ConnectionStep,
    plans: {
      totalCount($connection) {
        return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint, !1);
      }
    }
  },
  UserIdentity: {
    assertStep: assertPgClassSingleStep,
    plans: {
      accessToken($record) {
        return $record.get("access_token");
      },
      createdAt($record) {
        return $record.get("created_at");
      },
      id($parent) {
        const specifier = nodeIdHandler_UserIdentity.plan($parent);
        return lambda(specifier, nodeIdCodecs[nodeIdHandler_UserIdentity.codec.name].encode);
      },
      providerEmail($record) {
        return $record.get("provider_email");
      },
      providerUserId($record) {
        return $record.get("provider_user_id");
      },
      providerUsername($record) {
        return $record.get("provider_username");
      },
      refreshToken($record) {
        return $record.get("refresh_token");
      },
      rowId($record) {
        return $record.get("id");
      },
      tokenExpiresAt($record) {
        return $record.get("token_expires_at");
      },
      updatedAt($record) {
        return $record.get("updated_at");
      },
      user($record) {
        return resource_userPgResource.get({
          id: $record.get("user_id")
        });
      },
      userId($record) {
        return $record.get("user_id");
      }
    },
    planType($specifier) {
      const spec = Object.create(null);
      for (const pkCol of user_identityUniques[0].attributes) spec[pkCol] = get2($specifier, pkCol);
      return resource_user_identityPgResource.get(spec);
    }
  },
  UserIdentityConnection: {
    assertStep: ConnectionStep,
    plans: {
      totalCount($connection) {
        return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint, !1);
      }
    }
  },
  UserOrganization: {
    assertStep: assertPgClassSingleStep,
    plans: {
      createdAt($record) {
        return $record.get("created_at");
      },
      id($parent) {
        const specifier = nodeIdHandler_UserOrganization.plan($parent);
        return lambda(specifier, nodeIdCodecs[nodeIdHandler_UserOrganization.codec.name].encode);
      },
      organization($record) {
        return resource_organizationPgResource.get({
          id: $record.get("organization_id")
        });
      },
      organizationId($record) {
        return $record.get("organization_id");
      },
      rowId($record) {
        return $record.get("id");
      },
      updatedAt($record) {
        return $record.get("updated_at");
      },
      user($record) {
        return resource_userPgResource.get({
          id: $record.get("user_id")
        });
      },
      userId($record) {
        return $record.get("user_id");
      }
    },
    planType($specifier) {
      const spec = Object.create(null);
      for (const pkCol of user_organizationUniques[0].attributes) spec[pkCol] = get2($specifier, pkCol);
      return resource_user_organizationPgResource.get(spec);
    }
  },
  UserOrganizationConnection: {
    assertStep: ConnectionStep,
    plans: {
      totalCount($connection) {
        return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint, !1);
      }
    }
  },
  WebhookDelivery: {
    assertStep: assertPgClassSingleStep,
    plans: {
      attemptCount($record) {
        return $record.get("attempt_count");
      },
      createdAt($record) {
        return $record.get("created_at");
      },
      deliveredAt($record) {
        return $record.get("delivered_at");
      },
      errorMessage($record) {
        return $record.get("error_message");
      },
      eventType($record) {
        return $record.get("event_type");
      },
      httpStatusCode($record) {
        return $record.get("http_status_code");
      },
      id($parent) {
        const specifier = nodeIdHandler_WebhookDelivery.plan($parent);
        return lambda(specifier, nodeIdCodecs[nodeIdHandler_WebhookDelivery.codec.name].encode);
      },
      isSuccessful($record) {
        return $record.get("is_successful");
      },
      nextRetryAt($record) {
        return $record.get("next_retry_at");
      },
      responseBody($record) {
        return $record.get("response_body");
      },
      rowId($record) {
        return $record.get("id");
      },
      webhookEndpoint($record) {
        return resource_webhook_endpointPgResource.get({
          id: $record.get("webhook_endpoint_id")
        });
      },
      webhookEndpointId($record) {
        return $record.get("webhook_endpoint_id");
      }
    },
    planType($specifier) {
      const spec = Object.create(null);
      for (const pkCol of webhook_deliveryUniques[0].attributes) spec[pkCol] = get2($specifier, pkCol);
      return resource_webhook_deliveryPgResource.get(spec);
    }
  },
  WebhookDeliveryConnection: {
    assertStep: ConnectionStep,
    plans: {
      totalCount($connection) {
        return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint, !1);
      }
    }
  },
  WebhookEndpoint: {
    assertStep: assertPgClassSingleStep,
    plans: {
      createdAt($record) {
        return $record.get("created_at");
      },
      deletedAt($record) {
        return $record.get("deleted_at");
      },
      id($parent) {
        const specifier = nodeIdHandler_WebhookEndpoint.plan($parent);
        return lambda(specifier, nodeIdCodecs[nodeIdHandler_WebhookEndpoint.codec.name].encode);
      },
      isActive($record) {
        return $record.get("is_active");
      },
      organization($record) {
        return resource_organizationPgResource.get({
          id: $record.get("organization_id")
        });
      },
      organizationId($record) {
        return $record.get("organization_id");
      },
      rowId($record) {
        return $record.get("id");
      },
      updatedAt($record) {
        return $record.get("updated_at");
      },
      webhookDeliveries: {
        plan($record) {
          const $records = resource_webhook_deliveryPgResource.find({
            webhook_endpoint_id: $record.get("id")
          });
          return connection($records);
        },
        args: {
          first(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          },
          last(_, $connection, val) {
            $connection.setLast(val.getRaw());
          },
          offset(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          },
          before(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          },
          after(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          },
          condition(_condition, $connection, arg) {
            const $select = $connection.getSubplan();
            arg.apply($select, qbWhereBuilder);
          },
          filter(_, $connection, fieldArg) {
            const $pgSelect = $connection.getSubplan();
            fieldArg.apply($pgSelect, (queryBuilder, value) => {
              assertAllowed133(value, "object");
              if (value == null) return;
              const condition = new PgCondition(queryBuilder);
              return condition;
            });
          },
          orderBy(parent, $connection, value) {
            const $select = $connection.getSubplan();
            value.apply($select);
          }
        }
      }
    },
    planType($specifier) {
      const spec = Object.create(null);
      for (const pkCol of webhook_endpointUniques[0].attributes) spec[pkCol] = get2($specifier, pkCol);
      return resource_webhook_endpointPgResource.get(spec);
    }
  },
  WebhookEndpointConnection: {
    assertStep: ConnectionStep,
    plans: {
      totalCount($connection) {
        return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint, !1);
      }
    }
  },
  Workspace: {
    assertStep: assertPgClassSingleStep,
    plans: {
      createdAt($record) {
        return $record.get("created_at");
      },
      deletedAt($record) {
        return $record.get("deleted_at");
      },
      deletionReason($record) {
        return $record.get("deletion_reason");
      },
      id($parent) {
        const specifier = nodeIdHandler_Workspace.plan($parent);
        return lambda(specifier, nodeIdCodecs[nodeIdHandler_Workspace.codec.name].encode);
      },
      organizationId($record) {
        return $record.get("organization_id");
      },
      rowId($record) {
        return $record.get("id");
      },
      updatedAt($record) {
        return $record.get("updated_at");
      }
    },
    planType($specifier) {
      const spec = Object.create(null);
      for (const pkCol of workspaceUniques[0].attributes) spec[pkCol] = get2($specifier, pkCol);
      return resource_workspacePgResource.get(spec);
    }
  },
  WorkspaceConnection: {
    assertStep: ConnectionStep,
    plans: {
      totalCount($connection) {
        return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint, !1);
      }
    }
  }
};
export const interfaces = {
  Node: {
    planType($nodeId) {
      const $specifier = decodeNodeId($nodeId);
      return {
        $__typename: lambda($specifier, findTypeNameMatch, !0),
        planForType(type) {
          const spec = nodeIdHandlerByTypeName[type.name];
          if (spec) return spec.get(spec.getSpec(access($specifier, [spec.codec.name])));else throw Error(`Failed to find handler for ${type.name}`);
        }
      };
    }
  }
};
export const inputObjects = {
  AuditActionFilter: {
    plans: {
      distinctFrom($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier14 ? resolveSqlIdentifier14(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec19 ? resolveInputCodec19(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve42(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "distinctFrom"
          });
        $where.where(fragment);
      },
      equalTo($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier14 ? resolveSqlIdentifier14(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec19 ? resolveInputCodec19(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve40(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "equalTo"
          });
        $where.where(fragment);
      },
      greaterThan($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier14 ? resolveSqlIdentifier14(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec19 ? resolveInputCodec19(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve48(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "greaterThan"
          });
        $where.where(fragment);
      },
      greaterThanOrEqualTo($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier14 ? resolveSqlIdentifier14(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec19 ? resolveInputCodec19(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve49(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "greaterThanOrEqualTo"
          });
        $where.where(fragment);
      },
      in($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier14 ? resolveSqlIdentifier14(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec20 ? resolveInputCodec20(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve44(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "in"
          });
        $where.where(fragment);
      },
      isNull($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec18 ? resolveInputCodec18(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = resolveSqlValue13 ? resolveSqlValue13($where, value, inputCodec) : sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve39(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "isNull"
          });
        $where.where(fragment);
      },
      lessThan($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier14 ? resolveSqlIdentifier14(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec19 ? resolveInputCodec19(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve46(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "lessThan"
          });
        $where.where(fragment);
      },
      lessThanOrEqualTo($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier14 ? resolveSqlIdentifier14(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec19 ? resolveInputCodec19(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve47(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "lessThanOrEqualTo"
          });
        $where.where(fragment);
      },
      notDistinctFrom($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier14 ? resolveSqlIdentifier14(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec19 ? resolveInputCodec19(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve43(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notDistinctFrom"
          });
        $where.where(fragment);
      },
      notEqualTo($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier14 ? resolveSqlIdentifier14(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec19 ? resolveInputCodec19(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve41(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notEqualTo"
          });
        $where.where(fragment);
      },
      notIn($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier14 ? resolveSqlIdentifier14(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec20 ? resolveInputCodec20(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve45(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notIn"
          });
        $where.where(fragment);
      }
    }
  },
  AuditLogCondition: {
    plans: {
      action($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "action",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, auditActionCodec)}`;
          }
        });
      },
      actorUserId($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "actor_user_id",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
          }
        });
      },
      createdAt($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "created_at",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.timestamptz)}`;
          }
        });
      },
      organizationId($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "organization_id",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
          }
        });
      },
      rowId($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "id",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
          }
        });
      },
      targetEntityId($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "target_entity_id",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
          }
        });
      },
      targetEntityType($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "target_entity_type",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.text)}`;
          }
        });
      }
    }
  },
  AuditLogFilter: {
    plans: {
      action(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec6;
        return condition;
      },
      actorUser($where, value) {
        assertAllowed47(value, "object");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: userIdentifier,
          alias: resource_userPgResource.name
        });
        registryConfig.pgRelations.auditLog.userByMyActorUserId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.auditLog.userByMyActorUserId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      actorUserExists($where, value) {
        assertAllowed47(value, "scalar");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: userIdentifier,
          alias: resource_userPgResource.name,
          equals: value
        });
        registryConfig.pgRelations.auditLog.userByMyActorUserId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.auditLog.userByMyActorUserId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      },
      actorUserId(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec2;
        return condition;
      },
      and($where, value) {
        assertAllowed48(value, "list");
        if (value == null) return;
        return $where.andPlan();
      },
      createdAt(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec7;
        return condition;
      },
      not($where, value) {
        assertAllowed48(value, "object");
        if (value == null) return;
        return $where.notPlan().andPlan();
      },
      or($where, value) {
        assertAllowed48(value, "list");
        if (value == null) return;
        const $or = $where.orPlan();
        return () => $or.andPlan();
      },
      organization($where, value) {
        assertAllowed47(value, "object");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: organizationIdentifier,
          alias: resource_organizationPgResource.name
        });
        registryConfig.pgRelations.auditLog.organizationByMyOrganizationId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.auditLog.organizationByMyOrganizationId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      organizationExists($where, value) {
        assertAllowed47(value, "scalar");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: organizationIdentifier,
          alias: resource_organizationPgResource.name,
          equals: value
        });
        registryConfig.pgRelations.auditLog.organizationByMyOrganizationId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.auditLog.organizationByMyOrganizationId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      },
      organizationId(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec3;
        return condition;
      },
      rowId(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec;
        return condition;
      },
      targetEntityId(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec5;
        return condition;
      },
      targetEntityType(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec4;
        return condition;
      }
    }
  },
  AuditLogInput: {
    baked: createObjectAndApplyChildren,
    plans: {
      action(obj, val, {
        field,
        schema
      }) {
        obj.set("action", bakedInputRuntime(schema, field.type, val));
      },
      actorIpAddress(obj, val, {
        field,
        schema
      }) {
        obj.set("actor_ip_address", bakedInputRuntime(schema, field.type, val));
      },
      actorUserAgent(obj, val, {
        field,
        schema
      }) {
        obj.set("actor_user_agent", bakedInputRuntime(schema, field.type, val));
      },
      actorUserId(obj, val, {
        field,
        schema
      }) {
        obj.set("actor_user_id", bakedInputRuntime(schema, field.type, val));
      },
      createdAt(obj, val, {
        field,
        schema
      }) {
        obj.set("created_at", bakedInputRuntime(schema, field.type, val));
      },
      metadata(obj, val, {
        field,
        schema
      }) {
        obj.set("metadata", bakedInputRuntime(schema, field.type, val));
      },
      newState(obj, val, {
        field,
        schema
      }) {
        obj.set("new_state", bakedInputRuntime(schema, field.type, val));
      },
      organizationId(obj, val, {
        field,
        schema
      }) {
        obj.set("organization_id", bakedInputRuntime(schema, field.type, val));
      },
      previousState(obj, val, {
        field,
        schema
      }) {
        obj.set("previous_state", bakedInputRuntime(schema, field.type, val));
      },
      rowId(obj, val, {
        field,
        schema
      }) {
        obj.set("id", bakedInputRuntime(schema, field.type, val));
      },
      targetEntityId(obj, val, {
        field,
        schema
      }) {
        obj.set("target_entity_id", bakedInputRuntime(schema, field.type, val));
      },
      targetEntityType(obj, val, {
        field,
        schema
      }) {
        obj.set("target_entity_type", bakedInputRuntime(schema, field.type, val));
      }
    }
  },
  AuditLogPatch: {
    baked: createObjectAndApplyChildren,
    plans: {
      action(obj, val, {
        field,
        schema
      }) {
        obj.set("action", bakedInputRuntime(schema, field.type, val));
      },
      actorIpAddress(obj, val, {
        field,
        schema
      }) {
        obj.set("actor_ip_address", bakedInputRuntime(schema, field.type, val));
      },
      actorUserAgent(obj, val, {
        field,
        schema
      }) {
        obj.set("actor_user_agent", bakedInputRuntime(schema, field.type, val));
      },
      actorUserId(obj, val, {
        field,
        schema
      }) {
        obj.set("actor_user_id", bakedInputRuntime(schema, field.type, val));
      },
      createdAt(obj, val, {
        field,
        schema
      }) {
        obj.set("created_at", bakedInputRuntime(schema, field.type, val));
      },
      metadata(obj, val, {
        field,
        schema
      }) {
        obj.set("metadata", bakedInputRuntime(schema, field.type, val));
      },
      newState(obj, val, {
        field,
        schema
      }) {
        obj.set("new_state", bakedInputRuntime(schema, field.type, val));
      },
      organizationId(obj, val, {
        field,
        schema
      }) {
        obj.set("organization_id", bakedInputRuntime(schema, field.type, val));
      },
      previousState(obj, val, {
        field,
        schema
      }) {
        obj.set("previous_state", bakedInputRuntime(schema, field.type, val));
      },
      rowId(obj, val, {
        field,
        schema
      }) {
        obj.set("id", bakedInputRuntime(schema, field.type, val));
      },
      targetEntityId(obj, val, {
        field,
        schema
      }) {
        obj.set("target_entity_id", bakedInputRuntime(schema, field.type, val));
      },
      targetEntityType(obj, val, {
        field,
        schema
      }) {
        obj.set("target_entity_type", bakedInputRuntime(schema, field.type, val));
      }
    }
  },
  BooleanFilter: {
    plans: {
      distinctFrom($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier19 ? resolveSqlIdentifier19(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec34 ? resolveInputCodec34(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve97(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "distinctFrom"
          });
        $where.where(fragment);
      },
      equalTo($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier19 ? resolveSqlIdentifier19(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec34 ? resolveInputCodec34(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve95(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "equalTo"
          });
        $where.where(fragment);
      },
      greaterThan($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier19 ? resolveSqlIdentifier19(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec34 ? resolveInputCodec34(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve103(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "greaterThan"
          });
        $where.where(fragment);
      },
      greaterThanOrEqualTo($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier19 ? resolveSqlIdentifier19(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec34 ? resolveInputCodec34(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve104(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "greaterThanOrEqualTo"
          });
        $where.where(fragment);
      },
      in($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier19 ? resolveSqlIdentifier19(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec35 ? resolveInputCodec35(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve99(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "in"
          });
        $where.where(fragment);
      },
      isNull($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec33 ? resolveInputCodec33(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = resolveSqlValue18 ? resolveSqlValue18($where, value, inputCodec) : sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve94(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "isNull"
          });
        $where.where(fragment);
      },
      lessThan($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier19 ? resolveSqlIdentifier19(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec34 ? resolveInputCodec34(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve101(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "lessThan"
          });
        $where.where(fragment);
      },
      lessThanOrEqualTo($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier19 ? resolveSqlIdentifier19(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec34 ? resolveInputCodec34(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve102(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "lessThanOrEqualTo"
          });
        $where.where(fragment);
      },
      notDistinctFrom($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier19 ? resolveSqlIdentifier19(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec34 ? resolveInputCodec34(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve98(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notDistinctFrom"
          });
        $where.where(fragment);
      },
      notEqualTo($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier19 ? resolveSqlIdentifier19(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec34 ? resolveInputCodec34(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve96(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notEqualTo"
          });
        $where.where(fragment);
      },
      notIn($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier19 ? resolveSqlIdentifier19(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec35 ? resolveInputCodec35(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve100(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notIn"
          });
        $where.where(fragment);
      }
    }
  },
  BountyCondition: {
    plans: {
      claimantId($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "claimant_id",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
          }
        });
      },
      externalUrl($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "external_url",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.text)}`;
          }
        });
      },
      organizationId($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "organization_id",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
          }
        });
      },
      rowId($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "id",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
          }
        });
      },
      status($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "status",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, bountyStatusCodec)}`;
          }
        });
      }
    }
  },
  BountyFilter: {
    plans: {
      and($where, value) {
        assertAllowed55(value, "list");
        if (value == null) return;
        return $where.andPlan();
      },
      bountyFundings($where, value) {
        assertAllowed53(value, "object");
        const $rel = $where.andPlan();
        $rel.extensions.pgFilterRelation = {
          tableExpression: bountyFundingIdentifier,
          alias: resource_bounty_fundingPgResource.name,
          localAttributes: registryConfig.pgRelations.bounty.bountyFundingsByTheirBountyId.localAttributes,
          remoteAttributes: registryConfig.pgRelations.bounty.bountyFundingsByTheirBountyId.remoteAttributes
        };
        return $rel;
      },
      bountyFundingsExist($where, value) {
        assertAllowed53(value, "scalar");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: bountyFundingIdentifier,
          alias: resource_bounty_fundingPgResource.name,
          equals: value
        });
        registryConfig.pgRelations.bounty.bountyFundingsByTheirBountyId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.bounty.bountyFundingsByTheirBountyId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      },
      claimant($where, value) {
        assertAllowed54(value, "object");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: userIdentifier,
          alias: resource_userPgResource.name
        });
        registryConfig.pgRelations.bounty.userByMyClaimantId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.bounty.userByMyClaimantId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      claimantExists($where, value) {
        assertAllowed54(value, "scalar");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: userIdentifier,
          alias: resource_userPgResource.name,
          equals: value
        });
        registryConfig.pgRelations.bounty.userByMyClaimantId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.bounty.userByMyClaimantId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      },
      claimantId(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec14;
        return condition;
      },
      externalUrl(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec12;
        return condition;
      },
      not($where, value) {
        assertAllowed55(value, "object");
        if (value == null) return;
        return $where.notPlan().andPlan();
      },
      or($where, value) {
        assertAllowed55(value, "list");
        if (value == null) return;
        const $or = $where.orPlan();
        return () => $or.andPlan();
      },
      organization($where, value) {
        assertAllowed54(value, "object");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: organizationIdentifier,
          alias: resource_organizationPgResource.name
        });
        registryConfig.pgRelations.bounty.organizationByMyOrganizationId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.bounty.organizationByMyOrganizationId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      organizationId(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec11;
        return condition;
      },
      rowId(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec10;
        return condition;
      },
      status(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec13;
        return condition;
      }
    }
  },
  BountyFundingCondition: {
    plans: {
      bountyId($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "bounty_id",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
          }
        });
      },
      funderId($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "funder_id",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
          }
        });
      },
      rowId($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "id",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
          }
        });
      },
      transactionId($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "transaction_id",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
          }
        });
      }
    }
  },
  BountyFundingFilter: {
    plans: {
      and($where, value) {
        assertAllowed58(value, "list");
        if (value == null) return;
        return $where.andPlan();
      },
      bounty($where, value) {
        assertAllowed57(value, "object");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: bountyIdentifier,
          alias: resource_bountyPgResource.name
        });
        registryConfig.pgRelations.bountyFunding.bountyByMyBountyId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.bountyFunding.bountyByMyBountyId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      bountyId(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec16;
        return condition;
      },
      funder($where, value) {
        assertAllowed57(value, "object");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: userIdentifier,
          alias: resource_userPgResource.name
        });
        registryConfig.pgRelations.bountyFunding.userByMyFunderId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.bountyFunding.userByMyFunderId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      funderId(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec17;
        return condition;
      },
      not($where, value) {
        assertAllowed58(value, "object");
        if (value == null) return;
        return $where.notPlan().andPlan();
      },
      or($where, value) {
        assertAllowed58(value, "list");
        if (value == null) return;
        const $or = $where.orPlan();
        return () => $or.andPlan();
      },
      rowId(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec15;
        return condition;
      },
      transaction($where, value) {
        assertAllowed57(value, "object");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: transactionIdentifier,
          alias: resource_transactionPgResource.name
        });
        registryConfig.pgRelations.bountyFunding.transactionByMyTransactionId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.bountyFunding.transactionByMyTransactionId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      transactionExists($where, value) {
        assertAllowed57(value, "scalar");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: transactionIdentifier,
          alias: resource_transactionPgResource.name,
          equals: value
        });
        registryConfig.pgRelations.bountyFunding.transactionByMyTransactionId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.bountyFunding.transactionByMyTransactionId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      },
      transactionId(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec18;
        return condition;
      }
    }
  },
  BountyFundingInput: {
    baked: createObjectAndApplyChildren,
    plans: {
      amount(obj, val, {
        field,
        schema
      }) {
        obj.set("amount", bakedInputRuntime(schema, field.type, val));
      },
      bountyId(obj, val, {
        field,
        schema
      }) {
        obj.set("bounty_id", bakedInputRuntime(schema, field.type, val));
      },
      createdAt(obj, val, {
        field,
        schema
      }) {
        obj.set("created_at", bakedInputRuntime(schema, field.type, val));
      },
      currency(obj, val, {
        field,
        schema
      }) {
        obj.set("currency", bakedInputRuntime(schema, field.type, val));
      },
      funderId(obj, val, {
        field,
        schema
      }) {
        obj.set("funder_id", bakedInputRuntime(schema, field.type, val));
      },
      message(obj, val, {
        field,
        schema
      }) {
        obj.set("message", bakedInputRuntime(schema, field.type, val));
      },
      rowId(obj, val, {
        field,
        schema
      }) {
        obj.set("id", bakedInputRuntime(schema, field.type, val));
      },
      transactionId(obj, val, {
        field,
        schema
      }) {
        obj.set("transaction_id", bakedInputRuntime(schema, field.type, val));
      },
      updatedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("updated_at", bakedInputRuntime(schema, field.type, val));
      }
    }
  },
  BountyFundingPatch: {
    baked: createObjectAndApplyChildren,
    plans: {
      amount(obj, val, {
        field,
        schema
      }) {
        obj.set("amount", bakedInputRuntime(schema, field.type, val));
      },
      bountyId(obj, val, {
        field,
        schema
      }) {
        obj.set("bounty_id", bakedInputRuntime(schema, field.type, val));
      },
      createdAt(obj, val, {
        field,
        schema
      }) {
        obj.set("created_at", bakedInputRuntime(schema, field.type, val));
      },
      currency(obj, val, {
        field,
        schema
      }) {
        obj.set("currency", bakedInputRuntime(schema, field.type, val));
      },
      funderId(obj, val, {
        field,
        schema
      }) {
        obj.set("funder_id", bakedInputRuntime(schema, field.type, val));
      },
      message(obj, val, {
        field,
        schema
      }) {
        obj.set("message", bakedInputRuntime(schema, field.type, val));
      },
      rowId(obj, val, {
        field,
        schema
      }) {
        obj.set("id", bakedInputRuntime(schema, field.type, val));
      },
      transactionId(obj, val, {
        field,
        schema
      }) {
        obj.set("transaction_id", bakedInputRuntime(schema, field.type, val));
      },
      updatedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("updated_at", bakedInputRuntime(schema, field.type, val));
      }
    }
  },
  BountyInput: {
    baked: createObjectAndApplyChildren,
    plans: {
      arborIssueId(obj, val, {
        field,
        schema
      }) {
        obj.set("arbor_issue_id", bakedInputRuntime(schema, field.type, val));
      },
      claimantId(obj, val, {
        field,
        schema
      }) {
        obj.set("claimant_id", bakedInputRuntime(schema, field.type, val));
      },
      claimedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("claimed_at", bakedInputRuntime(schema, field.type, val));
      },
      completedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("completed_at", bakedInputRuntime(schema, field.type, val));
      },
      createdAt(obj, val, {
        field,
        schema
      }) {
        obj.set("created_at", bakedInputRuntime(schema, field.type, val));
      },
      currency(obj, val, {
        field,
        schema
      }) {
        obj.set("currency", bakedInputRuntime(schema, field.type, val));
      },
      deletedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("deleted_at", bakedInputRuntime(schema, field.type, val));
      },
      description(obj, val, {
        field,
        schema
      }) {
        obj.set("description", bakedInputRuntime(schema, field.type, val));
      },
      expiresAt(obj, val, {
        field,
        schema
      }) {
        obj.set("expires_at", bakedInputRuntime(schema, field.type, val));
      },
      externalUrl(obj, val, {
        field,
        schema
      }) {
        obj.set("external_url", bakedInputRuntime(schema, field.type, val));
      },
      organizationId(obj, val, {
        field,
        schema
      }) {
        obj.set("organization_id", bakedInputRuntime(schema, field.type, val));
      },
      rowId(obj, val, {
        field,
        schema
      }) {
        obj.set("id", bakedInputRuntime(schema, field.type, val));
      },
      sourceType(obj, val, {
        field,
        schema
      }) {
        obj.set("source_type", bakedInputRuntime(schema, field.type, val));
      },
      status(obj, val, {
        field,
        schema
      }) {
        obj.set("status", bakedInputRuntime(schema, field.type, val));
      },
      targetAmount(obj, val, {
        field,
        schema
      }) {
        obj.set("target_amount", bakedInputRuntime(schema, field.type, val));
      },
      title(obj, val, {
        field,
        schema
      }) {
        obj.set("title", bakedInputRuntime(schema, field.type, val));
      },
      updatedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("updated_at", bakedInputRuntime(schema, field.type, val));
      }
    }
  },
  BountyPatch: {
    baked: createObjectAndApplyChildren,
    plans: {
      arborIssueId(obj, val, {
        field,
        schema
      }) {
        obj.set("arbor_issue_id", bakedInputRuntime(schema, field.type, val));
      },
      claimantId(obj, val, {
        field,
        schema
      }) {
        obj.set("claimant_id", bakedInputRuntime(schema, field.type, val));
      },
      claimedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("claimed_at", bakedInputRuntime(schema, field.type, val));
      },
      completedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("completed_at", bakedInputRuntime(schema, field.type, val));
      },
      createdAt(obj, val, {
        field,
        schema
      }) {
        obj.set("created_at", bakedInputRuntime(schema, field.type, val));
      },
      currency(obj, val, {
        field,
        schema
      }) {
        obj.set("currency", bakedInputRuntime(schema, field.type, val));
      },
      deletedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("deleted_at", bakedInputRuntime(schema, field.type, val));
      },
      description(obj, val, {
        field,
        schema
      }) {
        obj.set("description", bakedInputRuntime(schema, field.type, val));
      },
      expiresAt(obj, val, {
        field,
        schema
      }) {
        obj.set("expires_at", bakedInputRuntime(schema, field.type, val));
      },
      externalUrl(obj, val, {
        field,
        schema
      }) {
        obj.set("external_url", bakedInputRuntime(schema, field.type, val));
      },
      organizationId(obj, val, {
        field,
        schema
      }) {
        obj.set("organization_id", bakedInputRuntime(schema, field.type, val));
      },
      rowId(obj, val, {
        field,
        schema
      }) {
        obj.set("id", bakedInputRuntime(schema, field.type, val));
      },
      sourceType(obj, val, {
        field,
        schema
      }) {
        obj.set("source_type", bakedInputRuntime(schema, field.type, val));
      },
      status(obj, val, {
        field,
        schema
      }) {
        obj.set("status", bakedInputRuntime(schema, field.type, val));
      },
      targetAmount(obj, val, {
        field,
        schema
      }) {
        obj.set("target_amount", bakedInputRuntime(schema, field.type, val));
      },
      title(obj, val, {
        field,
        schema
      }) {
        obj.set("title", bakedInputRuntime(schema, field.type, val));
      },
      updatedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("updated_at", bakedInputRuntime(schema, field.type, val));
      }
    }
  },
  BountyStatusFilter: {
    plans: {
      distinctFrom($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier16 ? resolveSqlIdentifier16(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec25 ? resolveInputCodec25(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve64(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "distinctFrom"
          });
        $where.where(fragment);
      },
      equalTo($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier16 ? resolveSqlIdentifier16(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec25 ? resolveInputCodec25(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve62(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "equalTo"
          });
        $where.where(fragment);
      },
      greaterThan($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier16 ? resolveSqlIdentifier16(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec25 ? resolveInputCodec25(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve70(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "greaterThan"
          });
        $where.where(fragment);
      },
      greaterThanOrEqualTo($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier16 ? resolveSqlIdentifier16(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec25 ? resolveInputCodec25(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve71(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "greaterThanOrEqualTo"
          });
        $where.where(fragment);
      },
      in($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier16 ? resolveSqlIdentifier16(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec26 ? resolveInputCodec26(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve66(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "in"
          });
        $where.where(fragment);
      },
      isNull($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec24 ? resolveInputCodec24(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = resolveSqlValue15 ? resolveSqlValue15($where, value, inputCodec) : sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve61(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "isNull"
          });
        $where.where(fragment);
      },
      lessThan($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier16 ? resolveSqlIdentifier16(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec25 ? resolveInputCodec25(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve68(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "lessThan"
          });
        $where.where(fragment);
      },
      lessThanOrEqualTo($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier16 ? resolveSqlIdentifier16(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec25 ? resolveInputCodec25(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve69(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "lessThanOrEqualTo"
          });
        $where.where(fragment);
      },
      notDistinctFrom($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier16 ? resolveSqlIdentifier16(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec25 ? resolveInputCodec25(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve65(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notDistinctFrom"
          });
        $where.where(fragment);
      },
      notEqualTo($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier16 ? resolveSqlIdentifier16(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec25 ? resolveInputCodec25(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve63(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notEqualTo"
          });
        $where.where(fragment);
      },
      notIn($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier16 ? resolveSqlIdentifier16(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec26 ? resolveInputCodec26(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve67(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notIn"
          });
        $where.where(fragment);
      }
    }
  },
  BountyToManyBountyFundingFilter: {
    plans: {
      every($where, value) {
        assertAllowed56(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery.notPlan().andPlan();
      },
      none($where, value) {
        assertAllowed56(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      some($where, value) {
        assertAllowed56(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      }
    }
  },
  CreateAuditLogInput: {
    plans: {
      auditLog(qb, arg) {
        if (arg != null) return qb.setBuilder();
      },
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      }
    }
  },
  CreateBountyFundingInput: {
    plans: {
      bountyFunding(qb, arg) {
        if (arg != null) return qb.setBuilder();
      },
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      }
    }
  },
  CreateBountyInput: {
    plans: {
      bounty(qb, arg) {
        if (arg != null) return qb.setBuilder();
      },
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      }
    }
  },
  CreateDonationInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      },
      donation(qb, arg) {
        if (arg != null) return qb.setBuilder();
      }
    }
  },
  CreateGoalInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      },
      goal(qb, arg) {
        if (arg != null) return qb.setBuilder();
      }
    }
  },
  CreateGrantApplicationInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      },
      grantApplication(qb, arg) {
        if (arg != null) return qb.setBuilder();
      }
    }
  },
  CreateGrantMilestoneInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      },
      grantMilestone(qb, arg) {
        if (arg != null) return qb.setBuilder();
      }
    }
  },
  CreateGrantProgramInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      },
      grantProgram(qb, arg) {
        if (arg != null) return qb.setBuilder();
      }
    }
  },
  CreateOrganizationInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      },
      organization(qb, arg) {
        if (arg != null) return qb.setBuilder();
      }
    }
  },
  CreatePaymentProcessorConnectionInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      },
      paymentProcessorConnection(qb, arg) {
        if (arg != null) return qb.setBuilder();
      }
    }
  },
  CreatePayoutInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      },
      payout(qb, arg) {
        if (arg != null) return qb.setBuilder();
      }
    }
  },
  CreatePostInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      },
      post(qb, arg) {
        if (arg != null) return qb.setBuilder();
      }
    }
  },
  CreateSponsorshipInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      },
      sponsorship(qb, arg) {
        if (arg != null) return qb.setBuilder();
      }
    }
  },
  CreateSponsorshipTierInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      },
      sponsorshipTier(qb, arg) {
        if (arg != null) return qb.setBuilder();
      }
    }
  },
  CreateTransactionInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      },
      transaction(qb, arg) {
        if (arg != null) return qb.setBuilder();
      }
    }
  },
  CreateUserIdentityInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      },
      userIdentity(qb, arg) {
        if (arg != null) return qb.setBuilder();
      }
    }
  },
  CreateUserInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      },
      user(qb, arg) {
        if (arg != null) return qb.setBuilder();
      }
    }
  },
  CreateUserOrganizationInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      },
      userOrganization(qb, arg) {
        if (arg != null) return qb.setBuilder();
      }
    }
  },
  CreateWebhookDeliveryInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      },
      webhookDelivery(qb, arg) {
        if (arg != null) return qb.setBuilder();
      }
    }
  },
  CreateWebhookEndpointInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      },
      webhookEndpoint(qb, arg) {
        if (arg != null) return qb.setBuilder();
      }
    }
  },
  CreateWorkspaceInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      },
      workspace(qb, arg) {
        if (arg != null) return qb.setBuilder();
      }
    }
  },
  DatetimeFilter: {
    plans: {
      distinctFrom($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier15 ? resolveSqlIdentifier15(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec22 ? resolveInputCodec22(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve53(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "distinctFrom"
          });
        $where.where(fragment);
      },
      equalTo($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier15 ? resolveSqlIdentifier15(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec22 ? resolveInputCodec22(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve51(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "equalTo"
          });
        $where.where(fragment);
      },
      greaterThan($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier15 ? resolveSqlIdentifier15(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec22 ? resolveInputCodec22(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve59(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "greaterThan"
          });
        $where.where(fragment);
      },
      greaterThanOrEqualTo($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier15 ? resolveSqlIdentifier15(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec22 ? resolveInputCodec22(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve60(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "greaterThanOrEqualTo"
          });
        $where.where(fragment);
      },
      in($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier15 ? resolveSqlIdentifier15(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec23 ? resolveInputCodec23(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve55(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "in"
          });
        $where.where(fragment);
      },
      isNull($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec21 ? resolveInputCodec21(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = resolveSqlValue14 ? resolveSqlValue14($where, value, inputCodec) : sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve50(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "isNull"
          });
        $where.where(fragment);
      },
      lessThan($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier15 ? resolveSqlIdentifier15(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec22 ? resolveInputCodec22(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve57(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "lessThan"
          });
        $where.where(fragment);
      },
      lessThanOrEqualTo($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier15 ? resolveSqlIdentifier15(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec22 ? resolveInputCodec22(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve58(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "lessThanOrEqualTo"
          });
        $where.where(fragment);
      },
      notDistinctFrom($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier15 ? resolveSqlIdentifier15(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec22 ? resolveInputCodec22(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve54(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notDistinctFrom"
          });
        $where.where(fragment);
      },
      notEqualTo($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier15 ? resolveSqlIdentifier15(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec22 ? resolveInputCodec22(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve52(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notEqualTo"
          });
        $where.where(fragment);
      },
      notIn($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier15 ? resolveSqlIdentifier15(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec23 ? resolveInputCodec23(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve56(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notIn"
          });
        $where.where(fragment);
      }
    }
  },
  DeleteAuditLogByIdInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      }
    }
  },
  DeleteAuditLogInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      }
    }
  },
  DeleteBountyByIdInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      }
    }
  },
  DeleteBountyFundingByIdInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      }
    }
  },
  DeleteBountyFundingInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      }
    }
  },
  DeleteBountyInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      }
    }
  },
  DeleteDonationByIdInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      }
    }
  },
  DeleteDonationInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      }
    }
  },
  DeleteGoalByIdInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      }
    }
  },
  DeleteGoalInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      }
    }
  },
  DeleteGrantApplicationByIdInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      }
    }
  },
  DeleteGrantApplicationInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      }
    }
  },
  DeleteGrantMilestoneByIdInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      }
    }
  },
  DeleteGrantMilestoneInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      }
    }
  },
  DeleteGrantProgramByIdInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      }
    }
  },
  DeleteGrantProgramInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      }
    }
  },
  DeleteOrganizationByIdInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      }
    }
  },
  DeleteOrganizationBySlugInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      }
    }
  },
  DeleteOrganizationInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      }
    }
  },
  DeletePaymentProcessorConnectionByIdInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      }
    }
  },
  DeletePaymentProcessorConnectionInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      }
    }
  },
  DeletePayoutByIdInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      }
    }
  },
  DeletePayoutInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      }
    }
  },
  DeletePostByIdInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      }
    }
  },
  DeletePostInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      }
    }
  },
  DeleteSponsorshipByIdInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      }
    }
  },
  DeleteSponsorshipInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      }
    }
  },
  DeleteSponsorshipTierByIdInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      }
    }
  },
  DeleteSponsorshipTierInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      }
    }
  },
  DeleteTransactionByIdInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      }
    }
  },
  DeleteTransactionInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      }
    }
  },
  DeleteUserByIdInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      }
    }
  },
  DeleteUserByUsernameInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      }
    }
  },
  DeleteUserIdentityByIdInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      }
    }
  },
  DeleteUserIdentityInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      }
    }
  },
  DeleteUserInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      }
    }
  },
  DeleteUserOrganizationByIdInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      }
    }
  },
  DeleteUserOrganizationInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      }
    }
  },
  DeleteWebhookDeliveryByIdInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      }
    }
  },
  DeleteWebhookDeliveryInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      }
    }
  },
  DeleteWebhookEndpointByIdInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      }
    }
  },
  DeleteWebhookEndpointInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      }
    }
  },
  DeleteWorkspaceByIdInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      }
    }
  },
  DeleteWorkspaceInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      }
    }
  },
  DonationCondition: {
    plans: {
      donorId($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "donor_id",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
          }
        });
      },
      organizationId($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "organization_id",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
          }
        });
      },
      rowId($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "id",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
          }
        });
      },
      transactionId($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "transaction_id",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
          }
        });
      }
    }
  },
  DonationFilter: {
    plans: {
      and($where, value) {
        assertAllowed65(value, "list");
        if (value == null) return;
        return $where.andPlan();
      },
      donor($where, value) {
        assertAllowed64(value, "object");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: userIdentifier,
          alias: resource_userPgResource.name
        });
        registryConfig.pgRelations.donation.userByMyDonorId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.donation.userByMyDonorId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      donorExists($where, value) {
        assertAllowed64(value, "scalar");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: userIdentifier,
          alias: resource_userPgResource.name,
          equals: value
        });
        registryConfig.pgRelations.donation.userByMyDonorId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.donation.userByMyDonorId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      },
      donorId(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec29;
        return condition;
      },
      not($where, value) {
        assertAllowed65(value, "object");
        if (value == null) return;
        return $where.notPlan().andPlan();
      },
      or($where, value) {
        assertAllowed65(value, "list");
        if (value == null) return;
        const $or = $where.orPlan();
        return () => $or.andPlan();
      },
      organization($where, value) {
        assertAllowed64(value, "object");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: organizationIdentifier,
          alias: resource_organizationPgResource.name
        });
        registryConfig.pgRelations.donation.organizationByMyOrganizationId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.donation.organizationByMyOrganizationId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      organizationId(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec30;
        return condition;
      },
      rowId(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec28;
        return condition;
      },
      transaction($where, value) {
        assertAllowed64(value, "object");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: transactionIdentifier,
          alias: resource_transactionPgResource.name
        });
        registryConfig.pgRelations.donation.transactionByMyTransactionId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.donation.transactionByMyTransactionId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      transactionExists($where, value) {
        assertAllowed64(value, "scalar");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: transactionIdentifier,
          alias: resource_transactionPgResource.name,
          equals: value
        });
        registryConfig.pgRelations.donation.transactionByMyTransactionId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.donation.transactionByMyTransactionId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      },
      transactionId(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec31;
        return condition;
      }
    }
  },
  DonationInput: {
    baked: createObjectAndApplyChildren,
    plans: {
      amount(obj, val, {
        field,
        schema
      }) {
        obj.set("amount", bakedInputRuntime(schema, field.type, val));
      },
      createdAt(obj, val, {
        field,
        schema
      }) {
        obj.set("created_at", bakedInputRuntime(schema, field.type, val));
      },
      currency(obj, val, {
        field,
        schema
      }) {
        obj.set("currency", bakedInputRuntime(schema, field.type, val));
      },
      donorId(obj, val, {
        field,
        schema
      }) {
        obj.set("donor_id", bakedInputRuntime(schema, field.type, val));
      },
      isAnonymous(obj, val, {
        field,
        schema
      }) {
        obj.set("is_anonymous", bakedInputRuntime(schema, field.type, val));
      },
      isPublic(obj, val, {
        field,
        schema
      }) {
        obj.set("is_public", bakedInputRuntime(schema, field.type, val));
      },
      organizationId(obj, val, {
        field,
        schema
      }) {
        obj.set("organization_id", bakedInputRuntime(schema, field.type, val));
      },
      publicMessage(obj, val, {
        field,
        schema
      }) {
        obj.set("public_message", bakedInputRuntime(schema, field.type, val));
      },
      rowId(obj, val, {
        field,
        schema
      }) {
        obj.set("id", bakedInputRuntime(schema, field.type, val));
      },
      transactionId(obj, val, {
        field,
        schema
      }) {
        obj.set("transaction_id", bakedInputRuntime(schema, field.type, val));
      }
    }
  },
  DonationPatch: {
    baked: createObjectAndApplyChildren,
    plans: {
      amount(obj, val, {
        field,
        schema
      }) {
        obj.set("amount", bakedInputRuntime(schema, field.type, val));
      },
      createdAt(obj, val, {
        field,
        schema
      }) {
        obj.set("created_at", bakedInputRuntime(schema, field.type, val));
      },
      currency(obj, val, {
        field,
        schema
      }) {
        obj.set("currency", bakedInputRuntime(schema, field.type, val));
      },
      donorId(obj, val, {
        field,
        schema
      }) {
        obj.set("donor_id", bakedInputRuntime(schema, field.type, val));
      },
      isAnonymous(obj, val, {
        field,
        schema
      }) {
        obj.set("is_anonymous", bakedInputRuntime(schema, field.type, val));
      },
      isPublic(obj, val, {
        field,
        schema
      }) {
        obj.set("is_public", bakedInputRuntime(schema, field.type, val));
      },
      organizationId(obj, val, {
        field,
        schema
      }) {
        obj.set("organization_id", bakedInputRuntime(schema, field.type, val));
      },
      publicMessage(obj, val, {
        field,
        schema
      }) {
        obj.set("public_message", bakedInputRuntime(schema, field.type, val));
      },
      rowId(obj, val, {
        field,
        schema
      }) {
        obj.set("id", bakedInputRuntime(schema, field.type, val));
      },
      transactionId(obj, val, {
        field,
        schema
      }) {
        obj.set("transaction_id", bakedInputRuntime(schema, field.type, val));
      }
    }
  },
  GoalCondition: {
    plans: {
      isActive($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "is_active",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.boolean)}`;
          }
        });
      },
      organizationId($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "organization_id",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
          }
        });
      },
      rowId($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "id",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
          }
        });
      }
    }
  },
  GoalFilter: {
    plans: {
      and($where, value) {
        assertAllowed111(value, "list");
        if (value == null) return;
        return $where.andPlan();
      },
      isActive(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec77;
        return condition;
      },
      not($where, value) {
        assertAllowed111(value, "object");
        if (value == null) return;
        return $where.notPlan().andPlan();
      },
      or($where, value) {
        assertAllowed111(value, "list");
        if (value == null) return;
        const $or = $where.orPlan();
        return () => $or.andPlan();
      },
      organization($where, value) {
        assertAllowed110(value, "object");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: organizationIdentifier,
          alias: resource_organizationPgResource.name
        });
        registryConfig.pgRelations.goal.organizationByMyOrganizationId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.goal.organizationByMyOrganizationId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      organizationId(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec76;
        return condition;
      },
      rowId(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec75;
        return condition;
      }
    }
  },
  GoalInput: {
    baked: createObjectAndApplyChildren,
    plans: {
      completedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("completed_at", bakedInputRuntime(schema, field.type, val));
      },
      createdAt(obj, val, {
        field,
        schema
      }) {
        obj.set("created_at", bakedInputRuntime(schema, field.type, val));
      },
      currency(obj, val, {
        field,
        schema
      }) {
        obj.set("currency", bakedInputRuntime(schema, field.type, val));
      },
      currentAmount(obj, val, {
        field,
        schema
      }) {
        obj.set("current_amount", bakedInputRuntime(schema, field.type, val));
      },
      description(obj, val, {
        field,
        schema
      }) {
        obj.set("description", bakedInputRuntime(schema, field.type, val));
      },
      displayOrder(obj, val, {
        field,
        schema
      }) {
        obj.set("display_order", bakedInputRuntime(schema, field.type, val));
      },
      isActive(obj, val, {
        field,
        schema
      }) {
        obj.set("is_active", bakedInputRuntime(schema, field.type, val));
      },
      isCompleted(obj, val, {
        field,
        schema
      }) {
        obj.set("is_completed", bakedInputRuntime(schema, field.type, val));
      },
      organizationId(obj, val, {
        field,
        schema
      }) {
        obj.set("organization_id", bakedInputRuntime(schema, field.type, val));
      },
      rowId(obj, val, {
        field,
        schema
      }) {
        obj.set("id", bakedInputRuntime(schema, field.type, val));
      },
      targetAmount(obj, val, {
        field,
        schema
      }) {
        obj.set("target_amount", bakedInputRuntime(schema, field.type, val));
      },
      title(obj, val, {
        field,
        schema
      }) {
        obj.set("title", bakedInputRuntime(schema, field.type, val));
      },
      updatedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("updated_at", bakedInputRuntime(schema, field.type, val));
      }
    }
  },
  GoalPatch: {
    baked: createObjectAndApplyChildren,
    plans: {
      completedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("completed_at", bakedInputRuntime(schema, field.type, val));
      },
      createdAt(obj, val, {
        field,
        schema
      }) {
        obj.set("created_at", bakedInputRuntime(schema, field.type, val));
      },
      currency(obj, val, {
        field,
        schema
      }) {
        obj.set("currency", bakedInputRuntime(schema, field.type, val));
      },
      currentAmount(obj, val, {
        field,
        schema
      }) {
        obj.set("current_amount", bakedInputRuntime(schema, field.type, val));
      },
      description(obj, val, {
        field,
        schema
      }) {
        obj.set("description", bakedInputRuntime(schema, field.type, val));
      },
      displayOrder(obj, val, {
        field,
        schema
      }) {
        obj.set("display_order", bakedInputRuntime(schema, field.type, val));
      },
      isActive(obj, val, {
        field,
        schema
      }) {
        obj.set("is_active", bakedInputRuntime(schema, field.type, val));
      },
      isCompleted(obj, val, {
        field,
        schema
      }) {
        obj.set("is_completed", bakedInputRuntime(schema, field.type, val));
      },
      organizationId(obj, val, {
        field,
        schema
      }) {
        obj.set("organization_id", bakedInputRuntime(schema, field.type, val));
      },
      rowId(obj, val, {
        field,
        schema
      }) {
        obj.set("id", bakedInputRuntime(schema, field.type, val));
      },
      targetAmount(obj, val, {
        field,
        schema
      }) {
        obj.set("target_amount", bakedInputRuntime(schema, field.type, val));
      },
      title(obj, val, {
        field,
        schema
      }) {
        obj.set("title", bakedInputRuntime(schema, field.type, val));
      },
      updatedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("updated_at", bakedInputRuntime(schema, field.type, val));
      }
    }
  },
  GrantApplicationCondition: {
    plans: {
      applicantId($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "applicant_id",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
          }
        });
      },
      grantProgramId($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "grant_program_id",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
          }
        });
      },
      rowId($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "id",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
          }
        });
      },
      status($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "status",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, grantApplicationStatusCodec)}`;
          }
        });
      }
    }
  },
  GrantApplicationFilter: {
    plans: {
      and($where, value) {
        assertAllowed78(value, "list");
        if (value == null) return;
        return $where.andPlan();
      },
      applicant($where, value) {
        assertAllowed77(value, "object");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: userIdentifier,
          alias: resource_userPgResource.name
        });
        registryConfig.pgRelations.grantApplication.userByMyApplicantId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.grantApplication.userByMyApplicantId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      applicantId(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec40;
        return condition;
      },
      grantMilestones($where, value) {
        assertAllowed76(value, "object");
        const $rel = $where.andPlan();
        $rel.extensions.pgFilterRelation = {
          tableExpression: grantMilestoneIdentifier,
          alias: resource_grant_milestonePgResource.name,
          localAttributes: registryConfig.pgRelations.grantApplication.grantMilestonesByTheirGrantApplicationId.localAttributes,
          remoteAttributes: registryConfig.pgRelations.grantApplication.grantMilestonesByTheirGrantApplicationId.remoteAttributes
        };
        return $rel;
      },
      grantMilestonesExist($where, value) {
        assertAllowed76(value, "scalar");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: grantMilestoneIdentifier,
          alias: resource_grant_milestonePgResource.name,
          equals: value
        });
        registryConfig.pgRelations.grantApplication.grantMilestonesByTheirGrantApplicationId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.grantApplication.grantMilestonesByTheirGrantApplicationId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      },
      grantProgram($where, value) {
        assertAllowed77(value, "object");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: grantProgramIdentifier,
          alias: resource_grant_programPgResource.name
        });
        registryConfig.pgRelations.grantApplication.grantProgramByMyGrantProgramId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.grantApplication.grantProgramByMyGrantProgramId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      grantProgramId(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec39;
        return condition;
      },
      not($where, value) {
        assertAllowed78(value, "object");
        if (value == null) return;
        return $where.notPlan().andPlan();
      },
      or($where, value) {
        assertAllowed78(value, "list");
        if (value == null) return;
        const $or = $where.orPlan();
        return () => $or.andPlan();
      },
      reviewedBy($where, value) {
        assertAllowed77(value, "object");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: userIdentifier,
          alias: resource_userPgResource.name
        });
        registryConfig.pgRelations.grantApplication.userByMyReviewedById.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.grantApplication.userByMyReviewedById.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      reviewedByExists($where, value) {
        assertAllowed77(value, "scalar");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: userIdentifier,
          alias: resource_userPgResource.name,
          equals: value
        });
        registryConfig.pgRelations.grantApplication.userByMyReviewedById.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.grantApplication.userByMyReviewedById.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      },
      rowId(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec38;
        return condition;
      },
      status(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec41;
        return condition;
      }
    }
  },
  GrantApplicationInput: {
    baked: createObjectAndApplyChildren,
    plans: {
      applicantId(obj, val, {
        field,
        schema
      }) {
        obj.set("applicant_id", bakedInputRuntime(schema, field.type, val));
      },
      approvedAmount(obj, val, {
        field,
        schema
      }) {
        obj.set("approved_amount", bakedInputRuntime(schema, field.type, val));
      },
      createdAt(obj, val, {
        field,
        schema
      }) {
        obj.set("created_at", bakedInputRuntime(schema, field.type, val));
      },
      currency(obj, val, {
        field,
        schema
      }) {
        obj.set("currency", bakedInputRuntime(schema, field.type, val));
      },
      description(obj, val, {
        field,
        schema
      }) {
        obj.set("description", bakedInputRuntime(schema, field.type, val));
      },
      grantProgramId(obj, val, {
        field,
        schema
      }) {
        obj.set("grant_program_id", bakedInputRuntime(schema, field.type, val));
      },
      proposedAmount(obj, val, {
        field,
        schema
      }) {
        obj.set("proposed_amount", bakedInputRuntime(schema, field.type, val));
      },
      reviewedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("reviewed_at", bakedInputRuntime(schema, field.type, val));
      },
      reviewedById(obj, val, {
        field,
        schema
      }) {
        obj.set("reviewed_by_id", bakedInputRuntime(schema, field.type, val));
      },
      reviewNotes(obj, val, {
        field,
        schema
      }) {
        obj.set("review_notes", bakedInputRuntime(schema, field.type, val));
      },
      rowId(obj, val, {
        field,
        schema
      }) {
        obj.set("id", bakedInputRuntime(schema, field.type, val));
      },
      status(obj, val, {
        field,
        schema
      }) {
        obj.set("status", bakedInputRuntime(schema, field.type, val));
      },
      submittedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("submitted_at", bakedInputRuntime(schema, field.type, val));
      },
      title(obj, val, {
        field,
        schema
      }) {
        obj.set("title", bakedInputRuntime(schema, field.type, val));
      },
      updatedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("updated_at", bakedInputRuntime(schema, field.type, val));
      }
    }
  },
  GrantApplicationPatch: {
    baked: createObjectAndApplyChildren,
    plans: {
      applicantId(obj, val, {
        field,
        schema
      }) {
        obj.set("applicant_id", bakedInputRuntime(schema, field.type, val));
      },
      approvedAmount(obj, val, {
        field,
        schema
      }) {
        obj.set("approved_amount", bakedInputRuntime(schema, field.type, val));
      },
      createdAt(obj, val, {
        field,
        schema
      }) {
        obj.set("created_at", bakedInputRuntime(schema, field.type, val));
      },
      currency(obj, val, {
        field,
        schema
      }) {
        obj.set("currency", bakedInputRuntime(schema, field.type, val));
      },
      description(obj, val, {
        field,
        schema
      }) {
        obj.set("description", bakedInputRuntime(schema, field.type, val));
      },
      grantProgramId(obj, val, {
        field,
        schema
      }) {
        obj.set("grant_program_id", bakedInputRuntime(schema, field.type, val));
      },
      proposedAmount(obj, val, {
        field,
        schema
      }) {
        obj.set("proposed_amount", bakedInputRuntime(schema, field.type, val));
      },
      reviewedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("reviewed_at", bakedInputRuntime(schema, field.type, val));
      },
      reviewedById(obj, val, {
        field,
        schema
      }) {
        obj.set("reviewed_by_id", bakedInputRuntime(schema, field.type, val));
      },
      reviewNotes(obj, val, {
        field,
        schema
      }) {
        obj.set("review_notes", bakedInputRuntime(schema, field.type, val));
      },
      rowId(obj, val, {
        field,
        schema
      }) {
        obj.set("id", bakedInputRuntime(schema, field.type, val));
      },
      status(obj, val, {
        field,
        schema
      }) {
        obj.set("status", bakedInputRuntime(schema, field.type, val));
      },
      submittedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("submitted_at", bakedInputRuntime(schema, field.type, val));
      },
      title(obj, val, {
        field,
        schema
      }) {
        obj.set("title", bakedInputRuntime(schema, field.type, val));
      },
      updatedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("updated_at", bakedInputRuntime(schema, field.type, val));
      }
    }
  },
  GrantApplicationStatusFilter: {
    plans: {
      distinctFrom($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier20 ? resolveSqlIdentifier20(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec37 ? resolveInputCodec37(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve108(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "distinctFrom"
          });
        $where.where(fragment);
      },
      equalTo($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier20 ? resolveSqlIdentifier20(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec37 ? resolveInputCodec37(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve106(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "equalTo"
          });
        $where.where(fragment);
      },
      greaterThan($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier20 ? resolveSqlIdentifier20(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec37 ? resolveInputCodec37(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve114(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "greaterThan"
          });
        $where.where(fragment);
      },
      greaterThanOrEqualTo($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier20 ? resolveSqlIdentifier20(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec37 ? resolveInputCodec37(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve115(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "greaterThanOrEqualTo"
          });
        $where.where(fragment);
      },
      in($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier20 ? resolveSqlIdentifier20(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec38 ? resolveInputCodec38(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve110(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "in"
          });
        $where.where(fragment);
      },
      isNull($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec36 ? resolveInputCodec36(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = resolveSqlValue19 ? resolveSqlValue19($where, value, inputCodec) : sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve105(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "isNull"
          });
        $where.where(fragment);
      },
      lessThan($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier20 ? resolveSqlIdentifier20(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec37 ? resolveInputCodec37(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve112(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "lessThan"
          });
        $where.where(fragment);
      },
      lessThanOrEqualTo($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier20 ? resolveSqlIdentifier20(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec37 ? resolveInputCodec37(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve113(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "lessThanOrEqualTo"
          });
        $where.where(fragment);
      },
      notDistinctFrom($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier20 ? resolveSqlIdentifier20(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec37 ? resolveInputCodec37(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve109(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notDistinctFrom"
          });
        $where.where(fragment);
      },
      notEqualTo($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier20 ? resolveSqlIdentifier20(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec37 ? resolveInputCodec37(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve107(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notEqualTo"
          });
        $where.where(fragment);
      },
      notIn($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier20 ? resolveSqlIdentifier20(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec38 ? resolveInputCodec38(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve111(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notIn"
          });
        $where.where(fragment);
      }
    }
  },
  GrantApplicationToManyGrantMilestoneFilter: {
    plans: {
      every($where, value) {
        assertAllowed79(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery.notPlan().andPlan();
      },
      none($where, value) {
        assertAllowed79(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      some($where, value) {
        assertAllowed79(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      }
    }
  },
  GrantMilestoneCondition: {
    plans: {
      grantApplicationId($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "grant_application_id",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
          }
        });
      },
      rowId($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "id",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
          }
        });
      },
      status($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "status",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, grantMilestoneStatusCodec)}`;
          }
        });
      }
    }
  },
  GrantMilestoneFilter: {
    plans: {
      and($where, value) {
        assertAllowed81(value, "list");
        if (value == null) return;
        return $where.andPlan();
      },
      grantApplication($where, value) {
        assertAllowed80(value, "object");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: grantApplicationIdentifier,
          alias: resource_grant_applicationPgResource.name
        });
        registryConfig.pgRelations.grantMilestone.grantApplicationByMyGrantApplicationId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.grantMilestone.grantApplicationByMyGrantApplicationId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      grantApplicationId(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec43;
        return condition;
      },
      not($where, value) {
        assertAllowed81(value, "object");
        if (value == null) return;
        return $where.notPlan().andPlan();
      },
      or($where, value) {
        assertAllowed81(value, "list");
        if (value == null) return;
        const $or = $where.orPlan();
        return () => $or.andPlan();
      },
      rowId(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec42;
        return condition;
      },
      status(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec44;
        return condition;
      },
      transaction($where, value) {
        assertAllowed80(value, "object");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: transactionIdentifier,
          alias: resource_transactionPgResource.name
        });
        registryConfig.pgRelations.grantMilestone.transactionByMyTransactionId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.grantMilestone.transactionByMyTransactionId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      transactionExists($where, value) {
        assertAllowed80(value, "scalar");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: transactionIdentifier,
          alias: resource_transactionPgResource.name,
          equals: value
        });
        registryConfig.pgRelations.grantMilestone.transactionByMyTransactionId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.grantMilestone.transactionByMyTransactionId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      }
    }
  },
  GrantMilestoneInput: {
    baked: createObjectAndApplyChildren,
    plans: {
      amount(obj, val, {
        field,
        schema
      }) {
        obj.set("amount", bakedInputRuntime(schema, field.type, val));
      },
      approvedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("approved_at", bakedInputRuntime(schema, field.type, val));
      },
      createdAt(obj, val, {
        field,
        schema
      }) {
        obj.set("created_at", bakedInputRuntime(schema, field.type, val));
      },
      currency(obj, val, {
        field,
        schema
      }) {
        obj.set("currency", bakedInputRuntime(schema, field.type, val));
      },
      description(obj, val, {
        field,
        schema
      }) {
        obj.set("description", bakedInputRuntime(schema, field.type, val));
      },
      dueDate(obj, val, {
        field,
        schema
      }) {
        obj.set("due_date", bakedInputRuntime(schema, field.type, val));
      },
      grantApplicationId(obj, val, {
        field,
        schema
      }) {
        obj.set("grant_application_id", bakedInputRuntime(schema, field.type, val));
      },
      paidAt(obj, val, {
        field,
        schema
      }) {
        obj.set("paid_at", bakedInputRuntime(schema, field.type, val));
      },
      rowId(obj, val, {
        field,
        schema
      }) {
        obj.set("id", bakedInputRuntime(schema, field.type, val));
      },
      sequenceOrder(obj, val, {
        field,
        schema
      }) {
        obj.set("sequence_order", bakedInputRuntime(schema, field.type, val));
      },
      status(obj, val, {
        field,
        schema
      }) {
        obj.set("status", bakedInputRuntime(schema, field.type, val));
      },
      submittedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("submitted_at", bakedInputRuntime(schema, field.type, val));
      },
      title(obj, val, {
        field,
        schema
      }) {
        obj.set("title", bakedInputRuntime(schema, field.type, val));
      },
      transactionId(obj, val, {
        field,
        schema
      }) {
        obj.set("transaction_id", bakedInputRuntime(schema, field.type, val));
      },
      updatedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("updated_at", bakedInputRuntime(schema, field.type, val));
      }
    }
  },
  GrantMilestonePatch: {
    baked: createObjectAndApplyChildren,
    plans: {
      amount(obj, val, {
        field,
        schema
      }) {
        obj.set("amount", bakedInputRuntime(schema, field.type, val));
      },
      approvedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("approved_at", bakedInputRuntime(schema, field.type, val));
      },
      createdAt(obj, val, {
        field,
        schema
      }) {
        obj.set("created_at", bakedInputRuntime(schema, field.type, val));
      },
      currency(obj, val, {
        field,
        schema
      }) {
        obj.set("currency", bakedInputRuntime(schema, field.type, val));
      },
      description(obj, val, {
        field,
        schema
      }) {
        obj.set("description", bakedInputRuntime(schema, field.type, val));
      },
      dueDate(obj, val, {
        field,
        schema
      }) {
        obj.set("due_date", bakedInputRuntime(schema, field.type, val));
      },
      grantApplicationId(obj, val, {
        field,
        schema
      }) {
        obj.set("grant_application_id", bakedInputRuntime(schema, field.type, val));
      },
      paidAt(obj, val, {
        field,
        schema
      }) {
        obj.set("paid_at", bakedInputRuntime(schema, field.type, val));
      },
      rowId(obj, val, {
        field,
        schema
      }) {
        obj.set("id", bakedInputRuntime(schema, field.type, val));
      },
      sequenceOrder(obj, val, {
        field,
        schema
      }) {
        obj.set("sequence_order", bakedInputRuntime(schema, field.type, val));
      },
      status(obj, val, {
        field,
        schema
      }) {
        obj.set("status", bakedInputRuntime(schema, field.type, val));
      },
      submittedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("submitted_at", bakedInputRuntime(schema, field.type, val));
      },
      title(obj, val, {
        field,
        schema
      }) {
        obj.set("title", bakedInputRuntime(schema, field.type, val));
      },
      transactionId(obj, val, {
        field,
        schema
      }) {
        obj.set("transaction_id", bakedInputRuntime(schema, field.type, val));
      },
      updatedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("updated_at", bakedInputRuntime(schema, field.type, val));
      }
    }
  },
  GrantMilestoneStatusFilter: {
    plans: {
      distinctFrom($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier21 ? resolveSqlIdentifier21(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec40 ? resolveInputCodec40(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve119(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "distinctFrom"
          });
        $where.where(fragment);
      },
      equalTo($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier21 ? resolveSqlIdentifier21(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec40 ? resolveInputCodec40(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve117(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "equalTo"
          });
        $where.where(fragment);
      },
      greaterThan($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier21 ? resolveSqlIdentifier21(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec40 ? resolveInputCodec40(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve125(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "greaterThan"
          });
        $where.where(fragment);
      },
      greaterThanOrEqualTo($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier21 ? resolveSqlIdentifier21(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec40 ? resolveInputCodec40(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve126(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "greaterThanOrEqualTo"
          });
        $where.where(fragment);
      },
      in($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier21 ? resolveSqlIdentifier21(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec41 ? resolveInputCodec41(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve121(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "in"
          });
        $where.where(fragment);
      },
      isNull($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec39 ? resolveInputCodec39(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = resolveSqlValue20 ? resolveSqlValue20($where, value, inputCodec) : sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve116(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "isNull"
          });
        $where.where(fragment);
      },
      lessThan($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier21 ? resolveSqlIdentifier21(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec40 ? resolveInputCodec40(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve123(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "lessThan"
          });
        $where.where(fragment);
      },
      lessThanOrEqualTo($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier21 ? resolveSqlIdentifier21(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec40 ? resolveInputCodec40(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve124(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "lessThanOrEqualTo"
          });
        $where.where(fragment);
      },
      notDistinctFrom($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier21 ? resolveSqlIdentifier21(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec40 ? resolveInputCodec40(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve120(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notDistinctFrom"
          });
        $where.where(fragment);
      },
      notEqualTo($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier21 ? resolveSqlIdentifier21(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec40 ? resolveInputCodec40(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve118(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notEqualTo"
          });
        $where.where(fragment);
      },
      notIn($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier21 ? resolveSqlIdentifier21(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec41 ? resolveInputCodec41(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve122(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notIn"
          });
        $where.where(fragment);
      }
    }
  },
  GrantProgramCondition: {
    plans: {
      isActive($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "is_active",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.boolean)}`;
          }
        });
      },
      organizationId($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "organization_id",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
          }
        });
      },
      rowId($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "id",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
          }
        });
      },
      slug($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "slug",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.text)}`;
          }
        });
      }
    }
  },
  GrantProgramFilter: {
    plans: {
      and($where, value) {
        assertAllowed74(value, "list");
        if (value == null) return;
        return $where.andPlan();
      },
      grantApplications($where, value) {
        assertAllowed72(value, "object");
        const $rel = $where.andPlan();
        $rel.extensions.pgFilterRelation = {
          tableExpression: grantApplicationIdentifier,
          alias: resource_grant_applicationPgResource.name,
          localAttributes: registryConfig.pgRelations.grantProgram.grantApplicationsByTheirGrantProgramId.localAttributes,
          remoteAttributes: registryConfig.pgRelations.grantProgram.grantApplicationsByTheirGrantProgramId.remoteAttributes
        };
        return $rel;
      },
      grantApplicationsExist($where, value) {
        assertAllowed72(value, "scalar");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: grantApplicationIdentifier,
          alias: resource_grant_applicationPgResource.name,
          equals: value
        });
        registryConfig.pgRelations.grantProgram.grantApplicationsByTheirGrantProgramId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.grantProgram.grantApplicationsByTheirGrantProgramId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      },
      isActive(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec37;
        return condition;
      },
      not($where, value) {
        assertAllowed74(value, "object");
        if (value == null) return;
        return $where.notPlan().andPlan();
      },
      or($where, value) {
        assertAllowed74(value, "list");
        if (value == null) return;
        const $or = $where.orPlan();
        return () => $or.andPlan();
      },
      organization($where, value) {
        assertAllowed73(value, "object");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: organizationIdentifier,
          alias: resource_organizationPgResource.name
        });
        registryConfig.pgRelations.grantProgram.organizationByMyOrganizationId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.grantProgram.organizationByMyOrganizationId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      organizationId(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec35;
        return condition;
      },
      rowId(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec34;
        return condition;
      },
      slug(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec36;
        return condition;
      }
    }
  },
  GrantProgramInput: {
    baked: createObjectAndApplyChildren,
    plans: {
      applicationsCloseAt(obj, val, {
        field,
        schema
      }) {
        obj.set("applications_close_at", bakedInputRuntime(schema, field.type, val));
      },
      applicationsOpenAt(obj, val, {
        field,
        schema
      }) {
        obj.set("applications_open_at", bakedInputRuntime(schema, field.type, val));
      },
      createdAt(obj, val, {
        field,
        schema
      }) {
        obj.set("created_at", bakedInputRuntime(schema, field.type, val));
      },
      currency(obj, val, {
        field,
        schema
      }) {
        obj.set("currency", bakedInputRuntime(schema, field.type, val));
      },
      deletedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("deleted_at", bakedInputRuntime(schema, field.type, val));
      },
      description(obj, val, {
        field,
        schema
      }) {
        obj.set("description", bakedInputRuntime(schema, field.type, val));
      },
      guidelines(obj, val, {
        field,
        schema
      }) {
        obj.set("guidelines", bakedInputRuntime(schema, field.type, val));
      },
      isActive(obj, val, {
        field,
        schema
      }) {
        obj.set("is_active", bakedInputRuntime(schema, field.type, val));
      },
      maxGrantAmount(obj, val, {
        field,
        schema
      }) {
        obj.set("max_grant_amount", bakedInputRuntime(schema, field.type, val));
      },
      minGrantAmount(obj, val, {
        field,
        schema
      }) {
        obj.set("min_grant_amount", bakedInputRuntime(schema, field.type, val));
      },
      name(obj, val, {
        field,
        schema
      }) {
        obj.set("name", bakedInputRuntime(schema, field.type, val));
      },
      organizationId(obj, val, {
        field,
        schema
      }) {
        obj.set("organization_id", bakedInputRuntime(schema, field.type, val));
      },
      remainingBudget(obj, val, {
        field,
        schema
      }) {
        obj.set("remaining_budget", bakedInputRuntime(schema, field.type, val));
      },
      rowId(obj, val, {
        field,
        schema
      }) {
        obj.set("id", bakedInputRuntime(schema, field.type, val));
      },
      slug(obj, val, {
        field,
        schema
      }) {
        obj.set("slug", bakedInputRuntime(schema, field.type, val));
      },
      totalBudget(obj, val, {
        field,
        schema
      }) {
        obj.set("total_budget", bakedInputRuntime(schema, field.type, val));
      },
      updatedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("updated_at", bakedInputRuntime(schema, field.type, val));
      }
    }
  },
  GrantProgramPatch: {
    baked: createObjectAndApplyChildren,
    plans: {
      applicationsCloseAt(obj, val, {
        field,
        schema
      }) {
        obj.set("applications_close_at", bakedInputRuntime(schema, field.type, val));
      },
      applicationsOpenAt(obj, val, {
        field,
        schema
      }) {
        obj.set("applications_open_at", bakedInputRuntime(schema, field.type, val));
      },
      createdAt(obj, val, {
        field,
        schema
      }) {
        obj.set("created_at", bakedInputRuntime(schema, field.type, val));
      },
      currency(obj, val, {
        field,
        schema
      }) {
        obj.set("currency", bakedInputRuntime(schema, field.type, val));
      },
      deletedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("deleted_at", bakedInputRuntime(schema, field.type, val));
      },
      description(obj, val, {
        field,
        schema
      }) {
        obj.set("description", bakedInputRuntime(schema, field.type, val));
      },
      guidelines(obj, val, {
        field,
        schema
      }) {
        obj.set("guidelines", bakedInputRuntime(schema, field.type, val));
      },
      isActive(obj, val, {
        field,
        schema
      }) {
        obj.set("is_active", bakedInputRuntime(schema, field.type, val));
      },
      maxGrantAmount(obj, val, {
        field,
        schema
      }) {
        obj.set("max_grant_amount", bakedInputRuntime(schema, field.type, val));
      },
      minGrantAmount(obj, val, {
        field,
        schema
      }) {
        obj.set("min_grant_amount", bakedInputRuntime(schema, field.type, val));
      },
      name(obj, val, {
        field,
        schema
      }) {
        obj.set("name", bakedInputRuntime(schema, field.type, val));
      },
      organizationId(obj, val, {
        field,
        schema
      }) {
        obj.set("organization_id", bakedInputRuntime(schema, field.type, val));
      },
      remainingBudget(obj, val, {
        field,
        schema
      }) {
        obj.set("remaining_budget", bakedInputRuntime(schema, field.type, val));
      },
      rowId(obj, val, {
        field,
        schema
      }) {
        obj.set("id", bakedInputRuntime(schema, field.type, val));
      },
      slug(obj, val, {
        field,
        schema
      }) {
        obj.set("slug", bakedInputRuntime(schema, field.type, val));
      },
      totalBudget(obj, val, {
        field,
        schema
      }) {
        obj.set("total_budget", bakedInputRuntime(schema, field.type, val));
      },
      updatedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("updated_at", bakedInputRuntime(schema, field.type, val));
      }
    }
  },
  GrantProgramToManyGrantApplicationFilter: {
    plans: {
      every($where, value) {
        assertAllowed75(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery.notPlan().andPlan();
      },
      none($where, value) {
        assertAllowed75(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      some($where, value) {
        assertAllowed75(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      }
    }
  },
  IdentityProviderFilter: {
    plans: {
      distinctFrom($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier26 ? resolveSqlIdentifier26(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec55 ? resolveInputCodec55(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve174(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "distinctFrom"
          });
        $where.where(fragment);
      },
      equalTo($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier26 ? resolveSqlIdentifier26(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec55 ? resolveInputCodec55(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve172(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "equalTo"
          });
        $where.where(fragment);
      },
      greaterThan($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier26 ? resolveSqlIdentifier26(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec55 ? resolveInputCodec55(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve180(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "greaterThan"
          });
        $where.where(fragment);
      },
      greaterThanOrEqualTo($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier26 ? resolveSqlIdentifier26(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec55 ? resolveInputCodec55(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve181(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "greaterThanOrEqualTo"
          });
        $where.where(fragment);
      },
      in($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier26 ? resolveSqlIdentifier26(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec56 ? resolveInputCodec56(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve176(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "in"
          });
        $where.where(fragment);
      },
      isNull($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec54 ? resolveInputCodec54(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = resolveSqlValue25 ? resolveSqlValue25($where, value, inputCodec) : sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve171(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "isNull"
          });
        $where.where(fragment);
      },
      lessThan($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier26 ? resolveSqlIdentifier26(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec55 ? resolveInputCodec55(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve178(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "lessThan"
          });
        $where.where(fragment);
      },
      lessThanOrEqualTo($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier26 ? resolveSqlIdentifier26(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec55 ? resolveInputCodec55(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve179(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "lessThanOrEqualTo"
          });
        $where.where(fragment);
      },
      notDistinctFrom($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier26 ? resolveSqlIdentifier26(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec55 ? resolveInputCodec55(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve175(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notDistinctFrom"
          });
        $where.where(fragment);
      },
      notEqualTo($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier26 ? resolveSqlIdentifier26(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec55 ? resolveInputCodec55(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve173(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notEqualTo"
          });
        $where.where(fragment);
      },
      notIn($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier26 ? resolveSqlIdentifier26(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec56 ? resolveInputCodec56(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve177(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notIn"
          });
        $where.where(fragment);
      }
    }
  },
  OrganizationCondition: {
    plans: {
      rowId($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "id",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
          }
        });
      },
      slug($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "slug",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.text)}`;
          }
        });
      }
    }
  },
  OrganizationFilter: {
    plans: {
      and($where, value) {
        assertAllowed67(value, "list");
        if (value == null) return;
        return $where.andPlan();
      },
      auditLogs($where, value) {
        assertAllowed66(value, "object");
        const $rel = $where.andPlan();
        $rel.extensions.pgFilterRelation = {
          tableExpression: auditLogIdentifier,
          alias: resource_audit_logPgResource.name,
          localAttributes: registryConfig.pgRelations.organization.auditLogsByTheirOrganizationId.localAttributes,
          remoteAttributes: registryConfig.pgRelations.organization.auditLogsByTheirOrganizationId.remoteAttributes
        };
        return $rel;
      },
      auditLogsExist($where, value) {
        assertAllowed66(value, "scalar");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: auditLogIdentifier,
          alias: resource_audit_logPgResource.name,
          equals: value
        });
        registryConfig.pgRelations.organization.auditLogsByTheirOrganizationId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.organization.auditLogsByTheirOrganizationId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      },
      bounties($where, value) {
        assertAllowed66(value, "object");
        const $rel = $where.andPlan();
        $rel.extensions.pgFilterRelation = {
          tableExpression: bountyIdentifier,
          alias: resource_bountyPgResource.name,
          localAttributes: registryConfig.pgRelations.organization.bountiesByTheirOrganizationId.localAttributes,
          remoteAttributes: registryConfig.pgRelations.organization.bountiesByTheirOrganizationId.remoteAttributes
        };
        return $rel;
      },
      bountiesExist($where, value) {
        assertAllowed66(value, "scalar");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: bountyIdentifier,
          alias: resource_bountyPgResource.name,
          equals: value
        });
        registryConfig.pgRelations.organization.bountiesByTheirOrganizationId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.organization.bountiesByTheirOrganizationId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      },
      donations($where, value) {
        assertAllowed66(value, "object");
        const $rel = $where.andPlan();
        $rel.extensions.pgFilterRelation = {
          tableExpression: donationIdentifier,
          alias: resource_donationPgResource.name,
          localAttributes: registryConfig.pgRelations.organization.donationsByTheirOrganizationId.localAttributes,
          remoteAttributes: registryConfig.pgRelations.organization.donationsByTheirOrganizationId.remoteAttributes
        };
        return $rel;
      },
      donationsExist($where, value) {
        assertAllowed66(value, "scalar");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: donationIdentifier,
          alias: resource_donationPgResource.name,
          equals: value
        });
        registryConfig.pgRelations.organization.donationsByTheirOrganizationId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.organization.donationsByTheirOrganizationId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      },
      goals($where, value) {
        assertAllowed66(value, "object");
        const $rel = $where.andPlan();
        $rel.extensions.pgFilterRelation = {
          tableExpression: goalIdentifier,
          alias: resource_goalPgResource.name,
          localAttributes: registryConfig.pgRelations.organization.goalsByTheirOrganizationId.localAttributes,
          remoteAttributes: registryConfig.pgRelations.organization.goalsByTheirOrganizationId.remoteAttributes
        };
        return $rel;
      },
      goalsExist($where, value) {
        assertAllowed66(value, "scalar");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: goalIdentifier,
          alias: resource_goalPgResource.name,
          equals: value
        });
        registryConfig.pgRelations.organization.goalsByTheirOrganizationId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.organization.goalsByTheirOrganizationId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      },
      grantPrograms($where, value) {
        assertAllowed66(value, "object");
        const $rel = $where.andPlan();
        $rel.extensions.pgFilterRelation = {
          tableExpression: grantProgramIdentifier,
          alias: resource_grant_programPgResource.name,
          localAttributes: registryConfig.pgRelations.organization.grantProgramsByTheirOrganizationId.localAttributes,
          remoteAttributes: registryConfig.pgRelations.organization.grantProgramsByTheirOrganizationId.remoteAttributes
        };
        return $rel;
      },
      grantProgramsExist($where, value) {
        assertAllowed66(value, "scalar");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: grantProgramIdentifier,
          alias: resource_grant_programPgResource.name,
          equals: value
        });
        registryConfig.pgRelations.organization.grantProgramsByTheirOrganizationId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.organization.grantProgramsByTheirOrganizationId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      },
      not($where, value) {
        assertAllowed67(value, "object");
        if (value == null) return;
        return $where.notPlan().andPlan();
      },
      or($where, value) {
        assertAllowed67(value, "list");
        if (value == null) return;
        const $or = $where.orPlan();
        return () => $or.andPlan();
      },
      paymentProcessorConnections($where, value) {
        assertAllowed66(value, "object");
        const $rel = $where.andPlan();
        $rel.extensions.pgFilterRelation = {
          tableExpression: paymentProcessorConnectionIdentifier,
          alias: resource_payment_processor_connectionPgResource.name,
          localAttributes: registryConfig.pgRelations.organization.paymentProcessorConnectionsByTheirOrganizationId.localAttributes,
          remoteAttributes: registryConfig.pgRelations.organization.paymentProcessorConnectionsByTheirOrganizationId.remoteAttributes
        };
        return $rel;
      },
      paymentProcessorConnectionsExist($where, value) {
        assertAllowed66(value, "scalar");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: paymentProcessorConnectionIdentifier,
          alias: resource_payment_processor_connectionPgResource.name,
          equals: value
        });
        registryConfig.pgRelations.organization.paymentProcessorConnectionsByTheirOrganizationId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.organization.paymentProcessorConnectionsByTheirOrganizationId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      },
      payoutsByFromOrganizationId($where, value) {
        assertAllowed66(value, "object");
        const $rel = $where.andPlan();
        $rel.extensions.pgFilterRelation = {
          tableExpression: payoutIdentifier,
          alias: resource_payoutPgResource.name,
          localAttributes: registryConfig.pgRelations.organization.payoutsByTheirFromOrganizationId.localAttributes,
          remoteAttributes: registryConfig.pgRelations.organization.payoutsByTheirFromOrganizationId.remoteAttributes
        };
        return $rel;
      },
      payoutsByFromOrganizationIdExist($where, value) {
        assertAllowed66(value, "scalar");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: payoutIdentifier,
          alias: resource_payoutPgResource.name,
          equals: value
        });
        registryConfig.pgRelations.organization.payoutsByTheirFromOrganizationId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.organization.payoutsByTheirFromOrganizationId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      },
      posts($where, value) {
        assertAllowed66(value, "object");
        const $rel = $where.andPlan();
        $rel.extensions.pgFilterRelation = {
          tableExpression: postIdentifier,
          alias: resource_postPgResource.name,
          localAttributes: registryConfig.pgRelations.organization.postsByTheirOrganizationId.localAttributes,
          remoteAttributes: registryConfig.pgRelations.organization.postsByTheirOrganizationId.remoteAttributes
        };
        return $rel;
      },
      postsExist($where, value) {
        assertAllowed66(value, "scalar");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: postIdentifier,
          alias: resource_postPgResource.name,
          equals: value
        });
        registryConfig.pgRelations.organization.postsByTheirOrganizationId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.organization.postsByTheirOrganizationId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      },
      rowId(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec32;
        return condition;
      },
      slug(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec33;
        return condition;
      },
      sponsorships($where, value) {
        assertAllowed66(value, "object");
        const $rel = $where.andPlan();
        $rel.extensions.pgFilterRelation = {
          tableExpression: sponsorshipIdentifier,
          alias: resource_sponsorshipPgResource.name,
          localAttributes: registryConfig.pgRelations.organization.sponsorshipsByTheirOrganizationId.localAttributes,
          remoteAttributes: registryConfig.pgRelations.organization.sponsorshipsByTheirOrganizationId.remoteAttributes
        };
        return $rel;
      },
      sponsorshipsExist($where, value) {
        assertAllowed66(value, "scalar");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: sponsorshipIdentifier,
          alias: resource_sponsorshipPgResource.name,
          equals: value
        });
        registryConfig.pgRelations.organization.sponsorshipsByTheirOrganizationId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.organization.sponsorshipsByTheirOrganizationId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      },
      sponsorshipTiers($where, value) {
        assertAllowed66(value, "object");
        const $rel = $where.andPlan();
        $rel.extensions.pgFilterRelation = {
          tableExpression: sponsorshipTierIdentifier,
          alias: resource_sponsorship_tierPgResource.name,
          localAttributes: registryConfig.pgRelations.organization.sponsorshipTiersByTheirOrganizationId.localAttributes,
          remoteAttributes: registryConfig.pgRelations.organization.sponsorshipTiersByTheirOrganizationId.remoteAttributes
        };
        return $rel;
      },
      sponsorshipTiersExist($where, value) {
        assertAllowed66(value, "scalar");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: sponsorshipTierIdentifier,
          alias: resource_sponsorship_tierPgResource.name,
          equals: value
        });
        registryConfig.pgRelations.organization.sponsorshipTiersByTheirOrganizationId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.organization.sponsorshipTiersByTheirOrganizationId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      },
      transactionsByToOrganizationId($where, value) {
        assertAllowed66(value, "object");
        const $rel = $where.andPlan();
        $rel.extensions.pgFilterRelation = {
          tableExpression: transactionIdentifier,
          alias: resource_transactionPgResource.name,
          localAttributes: registryConfig.pgRelations.organization.transactionsByTheirToOrganizationId.localAttributes,
          remoteAttributes: registryConfig.pgRelations.organization.transactionsByTheirToOrganizationId.remoteAttributes
        };
        return $rel;
      },
      transactionsByToOrganizationIdExist($where, value) {
        assertAllowed66(value, "scalar");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: transactionIdentifier,
          alias: resource_transactionPgResource.name,
          equals: value
        });
        registryConfig.pgRelations.organization.transactionsByTheirToOrganizationId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.organization.transactionsByTheirToOrganizationId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      },
      userOrganizations($where, value) {
        assertAllowed66(value, "object");
        const $rel = $where.andPlan();
        $rel.extensions.pgFilterRelation = {
          tableExpression: userOrganizationIdentifier,
          alias: resource_user_organizationPgResource.name,
          localAttributes: registryConfig.pgRelations.organization.userOrganizationsByTheirOrganizationId.localAttributes,
          remoteAttributes: registryConfig.pgRelations.organization.userOrganizationsByTheirOrganizationId.remoteAttributes
        };
        return $rel;
      },
      userOrganizationsExist($where, value) {
        assertAllowed66(value, "scalar");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: userOrganizationIdentifier,
          alias: resource_user_organizationPgResource.name,
          equals: value
        });
        registryConfig.pgRelations.organization.userOrganizationsByTheirOrganizationId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.organization.userOrganizationsByTheirOrganizationId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      },
      webhookEndpoints($where, value) {
        assertAllowed66(value, "object");
        const $rel = $where.andPlan();
        $rel.extensions.pgFilterRelation = {
          tableExpression: webhookEndpointIdentifier,
          alias: resource_webhook_endpointPgResource.name,
          localAttributes: registryConfig.pgRelations.organization.webhookEndpointsByTheirOrganizationId.localAttributes,
          remoteAttributes: registryConfig.pgRelations.organization.webhookEndpointsByTheirOrganizationId.remoteAttributes
        };
        return $rel;
      },
      webhookEndpointsExist($where, value) {
        assertAllowed66(value, "scalar");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: webhookEndpointIdentifier,
          alias: resource_webhook_endpointPgResource.name,
          equals: value
        });
        registryConfig.pgRelations.organization.webhookEndpointsByTheirOrganizationId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.organization.webhookEndpointsByTheirOrganizationId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      }
    }
  },
  OrganizationInput: {
    baked: createObjectAndApplyChildren,
    plans: {
      avatarUrl(obj, val, {
        field,
        schema
      }) {
        obj.set("avatar_url", bakedInputRuntime(schema, field.type, val));
      },
      createdAt(obj, val, {
        field,
        schema
      }) {
        obj.set("created_at", bakedInputRuntime(schema, field.type, val));
      },
      deletedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("deleted_at", bakedInputRuntime(schema, field.type, val));
      },
      description(obj, val, {
        field,
        schema
      }) {
        obj.set("description", bakedInputRuntime(schema, field.type, val));
      },
      isVerified(obj, val, {
        field,
        schema
      }) {
        obj.set("is_verified", bakedInputRuntime(schema, field.type, val));
      },
      name(obj, val, {
        field,
        schema
      }) {
        obj.set("name", bakedInputRuntime(schema, field.type, val));
      },
      organizationType(obj, val, {
        field,
        schema
      }) {
        obj.set("organization_type", bakedInputRuntime(schema, field.type, val));
      },
      platformFeePercent(obj, val, {
        field,
        schema
      }) {
        obj.set("platform_fee_percent", bakedInputRuntime(schema, field.type, val));
      },
      rowId(obj, val, {
        field,
        schema
      }) {
        obj.set("id", bakedInputRuntime(schema, field.type, val));
      },
      slug(obj, val, {
        field,
        schema
      }) {
        obj.set("slug", bakedInputRuntime(schema, field.type, val));
      },
      updatedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("updated_at", bakedInputRuntime(schema, field.type, val));
      },
      verifiedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("verified_at", bakedInputRuntime(schema, field.type, val));
      },
      websiteUrl(obj, val, {
        field,
        schema
      }) {
        obj.set("website_url", bakedInputRuntime(schema, field.type, val));
      }
    }
  },
  OrganizationPatch: {
    baked: createObjectAndApplyChildren,
    plans: {
      avatarUrl(obj, val, {
        field,
        schema
      }) {
        obj.set("avatar_url", bakedInputRuntime(schema, field.type, val));
      },
      createdAt(obj, val, {
        field,
        schema
      }) {
        obj.set("created_at", bakedInputRuntime(schema, field.type, val));
      },
      deletedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("deleted_at", bakedInputRuntime(schema, field.type, val));
      },
      description(obj, val, {
        field,
        schema
      }) {
        obj.set("description", bakedInputRuntime(schema, field.type, val));
      },
      isVerified(obj, val, {
        field,
        schema
      }) {
        obj.set("is_verified", bakedInputRuntime(schema, field.type, val));
      },
      name(obj, val, {
        field,
        schema
      }) {
        obj.set("name", bakedInputRuntime(schema, field.type, val));
      },
      organizationType(obj, val, {
        field,
        schema
      }) {
        obj.set("organization_type", bakedInputRuntime(schema, field.type, val));
      },
      platformFeePercent(obj, val, {
        field,
        schema
      }) {
        obj.set("platform_fee_percent", bakedInputRuntime(schema, field.type, val));
      },
      rowId(obj, val, {
        field,
        schema
      }) {
        obj.set("id", bakedInputRuntime(schema, field.type, val));
      },
      slug(obj, val, {
        field,
        schema
      }) {
        obj.set("slug", bakedInputRuntime(schema, field.type, val));
      },
      updatedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("updated_at", bakedInputRuntime(schema, field.type, val));
      },
      verifiedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("verified_at", bakedInputRuntime(schema, field.type, val));
      },
      websiteUrl(obj, val, {
        field,
        schema
      }) {
        obj.set("website_url", bakedInputRuntime(schema, field.type, val));
      }
    }
  },
  OrganizationToManyAuditLogFilter: {
    plans: {
      every($where, value) {
        assertAllowed68(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery.notPlan().andPlan();
      },
      none($where, value) {
        assertAllowed68(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      some($where, value) {
        assertAllowed68(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      }
    }
  },
  OrganizationToManyBountyFilter: {
    plans: {
      every($where, value) {
        assertAllowed69(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery.notPlan().andPlan();
      },
      none($where, value) {
        assertAllowed69(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      some($where, value) {
        assertAllowed69(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      }
    }
  },
  OrganizationToManyDonationFilter: {
    plans: {
      every($where, value) {
        assertAllowed70(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery.notPlan().andPlan();
      },
      none($where, value) {
        assertAllowed70(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      some($where, value) {
        assertAllowed70(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      }
    }
  },
  OrganizationToManyGoalFilter: {
    plans: {
      every($where, value) {
        assertAllowed109(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery.notPlan().andPlan();
      },
      none($where, value) {
        assertAllowed109(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      some($where, value) {
        assertAllowed109(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      }
    }
  },
  OrganizationToManyGrantProgramFilter: {
    plans: {
      every($where, value) {
        assertAllowed71(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery.notPlan().andPlan();
      },
      none($where, value) {
        assertAllowed71(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      some($where, value) {
        assertAllowed71(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      }
    }
  },
  OrganizationToManyPaymentProcessorConnectionFilter: {
    plans: {
      every($where, value) {
        assertAllowed93(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery.notPlan().andPlan();
      },
      none($where, value) {
        assertAllowed93(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      some($where, value) {
        assertAllowed93(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      }
    }
  },
  OrganizationToManyPayoutFilter: {
    plans: {
      every($where, value) {
        assertAllowed99(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery.notPlan().andPlan();
      },
      none($where, value) {
        assertAllowed99(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      some($where, value) {
        assertAllowed99(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      }
    }
  },
  OrganizationToManyPostFilter: {
    plans: {
      every($where, value) {
        assertAllowed112(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery.notPlan().andPlan();
      },
      none($where, value) {
        assertAllowed112(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      some($where, value) {
        assertAllowed112(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      }
    }
  },
  OrganizationToManySponsorshipFilter: {
    plans: {
      every($where, value) {
        assertAllowed92(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery.notPlan().andPlan();
      },
      none($where, value) {
        assertAllowed92(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      some($where, value) {
        assertAllowed92(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      }
    }
  },
  OrganizationToManySponsorshipTierFilter: {
    plans: {
      every($where, value) {
        assertAllowed85(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery.notPlan().andPlan();
      },
      none($where, value) {
        assertAllowed85(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      some($where, value) {
        assertAllowed85(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      }
    }
  },
  OrganizationToManyTransactionFilter: {
    plans: {
      every($where, value) {
        assertAllowed98(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery.notPlan().andPlan();
      },
      none($where, value) {
        assertAllowed98(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      some($where, value) {
        assertAllowed98(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      }
    }
  },
  OrganizationToManyUserOrganizationFilter: {
    plans: {
      every($where, value) {
        assertAllowed82(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery.notPlan().andPlan();
      },
      none($where, value) {
        assertAllowed82(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      some($where, value) {
        assertAllowed82(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      }
    }
  },
  OrganizationToManyWebhookEndpointFilter: {
    plans: {
      every($where, value) {
        assertAllowed102(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery.notPlan().andPlan();
      },
      none($where, value) {
        assertAllowed102(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      some($where, value) {
        assertAllowed102(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      }
    }
  },
  PaymentProcessorConnectionCondition: {
    plans: {
      externalAccountId($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "external_account_id",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.text)}`;
          }
        });
      },
      isActive($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "is_active",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.boolean)}`;
          }
        });
      },
      organizationId($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "organization_id",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
          }
        });
      },
      processor($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "processor",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, paymentProcessorCodec)}`;
          }
        });
      },
      rowId($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "id",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
          }
        });
      }
    }
  },
  PaymentProcessorConnectionFilter: {
    plans: {
      and($where, value) {
        assertAllowed96(value, "list");
        if (value == null) return;
        return $where.andPlan();
      },
      externalAccountId(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec60;
        return condition;
      },
      isActive(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec61;
        return condition;
      },
      not($where, value) {
        assertAllowed96(value, "object");
        if (value == null) return;
        return $where.notPlan().andPlan();
      },
      or($where, value) {
        assertAllowed96(value, "list");
        if (value == null) return;
        const $or = $where.orPlan();
        return () => $or.andPlan();
      },
      organization($where, value) {
        assertAllowed95(value, "object");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: organizationIdentifier,
          alias: resource_organizationPgResource.name
        });
        registryConfig.pgRelations.paymentProcessorConnection.organizationByMyOrganizationId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.paymentProcessorConnection.organizationByMyOrganizationId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      organizationId(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec58;
        return condition;
      },
      processor(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec59;
        return condition;
      },
      rowId(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec57;
        return condition;
      },
      transactionsByProcessorConnectionId($where, value) {
        assertAllowed94(value, "object");
        const $rel = $where.andPlan();
        $rel.extensions.pgFilterRelation = {
          tableExpression: transactionIdentifier,
          alias: resource_transactionPgResource.name,
          localAttributes: registryConfig.pgRelations.paymentProcessorConnection.transactionsByTheirProcessorConnectionId.localAttributes,
          remoteAttributes: registryConfig.pgRelations.paymentProcessorConnection.transactionsByTheirProcessorConnectionId.remoteAttributes
        };
        return $rel;
      },
      transactionsByProcessorConnectionIdExist($where, value) {
        assertAllowed94(value, "scalar");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: transactionIdentifier,
          alias: resource_transactionPgResource.name,
          equals: value
        });
        registryConfig.pgRelations.paymentProcessorConnection.transactionsByTheirProcessorConnectionId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.paymentProcessorConnection.transactionsByTheirProcessorConnectionId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      }
    }
  },
  PaymentProcessorConnectionInput: {
    baked: createObjectAndApplyChildren,
    plans: {
      createdAt(obj, val, {
        field,
        schema
      }) {
        obj.set("created_at", bakedInputRuntime(schema, field.type, val));
      },
      deletedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("deleted_at", bakedInputRuntime(schema, field.type, val));
      },
      displayName(obj, val, {
        field,
        schema
      }) {
        obj.set("display_name", bakedInputRuntime(schema, field.type, val));
      },
      externalAccountId(obj, val, {
        field,
        schema
      }) {
        obj.set("external_account_id", bakedInputRuntime(schema, field.type, val));
      },
      isActive(obj, val, {
        field,
        schema
      }) {
        obj.set("is_active", bakedInputRuntime(schema, field.type, val));
      },
      isPrimary(obj, val, {
        field,
        schema
      }) {
        obj.set("is_primary", bakedInputRuntime(schema, field.type, val));
      },
      isVerified(obj, val, {
        field,
        schema
      }) {
        obj.set("is_verified", bakedInputRuntime(schema, field.type, val));
      },
      metadata(obj, val, {
        field,
        schema
      }) {
        obj.set("metadata", bakedInputRuntime(schema, field.type, val));
      },
      organizationId(obj, val, {
        field,
        schema
      }) {
        obj.set("organization_id", bakedInputRuntime(schema, field.type, val));
      },
      processor(obj, val, {
        field,
        schema
      }) {
        obj.set("processor", bakedInputRuntime(schema, field.type, val));
      },
      rowId(obj, val, {
        field,
        schema
      }) {
        obj.set("id", bakedInputRuntime(schema, field.type, val));
      },
      updatedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("updated_at", bakedInputRuntime(schema, field.type, val));
      },
      verifiedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("verified_at", bakedInputRuntime(schema, field.type, val));
      }
    }
  },
  PaymentProcessorConnectionPatch: {
    baked: createObjectAndApplyChildren,
    plans: {
      createdAt(obj, val, {
        field,
        schema
      }) {
        obj.set("created_at", bakedInputRuntime(schema, field.type, val));
      },
      deletedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("deleted_at", bakedInputRuntime(schema, field.type, val));
      },
      displayName(obj, val, {
        field,
        schema
      }) {
        obj.set("display_name", bakedInputRuntime(schema, field.type, val));
      },
      externalAccountId(obj, val, {
        field,
        schema
      }) {
        obj.set("external_account_id", bakedInputRuntime(schema, field.type, val));
      },
      isActive(obj, val, {
        field,
        schema
      }) {
        obj.set("is_active", bakedInputRuntime(schema, field.type, val));
      },
      isPrimary(obj, val, {
        field,
        schema
      }) {
        obj.set("is_primary", bakedInputRuntime(schema, field.type, val));
      },
      isVerified(obj, val, {
        field,
        schema
      }) {
        obj.set("is_verified", bakedInputRuntime(schema, field.type, val));
      },
      metadata(obj, val, {
        field,
        schema
      }) {
        obj.set("metadata", bakedInputRuntime(schema, field.type, val));
      },
      organizationId(obj, val, {
        field,
        schema
      }) {
        obj.set("organization_id", bakedInputRuntime(schema, field.type, val));
      },
      processor(obj, val, {
        field,
        schema
      }) {
        obj.set("processor", bakedInputRuntime(schema, field.type, val));
      },
      rowId(obj, val, {
        field,
        schema
      }) {
        obj.set("id", bakedInputRuntime(schema, field.type, val));
      },
      updatedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("updated_at", bakedInputRuntime(schema, field.type, val));
      },
      verifiedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("verified_at", bakedInputRuntime(schema, field.type, val));
      }
    }
  },
  PaymentProcessorConnectionToManyTransactionFilter: {
    plans: {
      every($where, value) {
        assertAllowed97(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery.notPlan().andPlan();
      },
      none($where, value) {
        assertAllowed97(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      some($where, value) {
        assertAllowed97(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      }
    }
  },
  PaymentProcessorFilter: {
    plans: {
      distinctFrom($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier24 ? resolveSqlIdentifier24(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec49 ? resolveInputCodec49(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve152(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "distinctFrom"
          });
        $where.where(fragment);
      },
      equalTo($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier24 ? resolveSqlIdentifier24(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec49 ? resolveInputCodec49(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve150(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "equalTo"
          });
        $where.where(fragment);
      },
      greaterThan($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier24 ? resolveSqlIdentifier24(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec49 ? resolveInputCodec49(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve158(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "greaterThan"
          });
        $where.where(fragment);
      },
      greaterThanOrEqualTo($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier24 ? resolveSqlIdentifier24(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec49 ? resolveInputCodec49(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve159(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "greaterThanOrEqualTo"
          });
        $where.where(fragment);
      },
      in($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier24 ? resolveSqlIdentifier24(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec50 ? resolveInputCodec50(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve154(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "in"
          });
        $where.where(fragment);
      },
      isNull($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec48 ? resolveInputCodec48(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = resolveSqlValue23 ? resolveSqlValue23($where, value, inputCodec) : sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve149(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "isNull"
          });
        $where.where(fragment);
      },
      lessThan($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier24 ? resolveSqlIdentifier24(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec49 ? resolveInputCodec49(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve156(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "lessThan"
          });
        $where.where(fragment);
      },
      lessThanOrEqualTo($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier24 ? resolveSqlIdentifier24(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec49 ? resolveInputCodec49(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve157(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "lessThanOrEqualTo"
          });
        $where.where(fragment);
      },
      notDistinctFrom($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier24 ? resolveSqlIdentifier24(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec49 ? resolveInputCodec49(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve153(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notDistinctFrom"
          });
        $where.where(fragment);
      },
      notEqualTo($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier24 ? resolveSqlIdentifier24(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec49 ? resolveInputCodec49(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve151(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notEqualTo"
          });
        $where.where(fragment);
      },
      notIn($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier24 ? resolveSqlIdentifier24(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec50 ? resolveInputCodec50(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve155(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notIn"
          });
        $where.where(fragment);
      }
    }
  },
  PayoutCondition: {
    plans: {
      createdAt($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "created_at",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.timestamptz)}`;
          }
        });
      },
      fromOrganizationId($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "from_organization_id",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
          }
        });
      },
      recipientUserId($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "recipient_user_id",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
          }
        });
      },
      rowId($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "id",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
          }
        });
      },
      status($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "status",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, transactionStatusCodec)}`;
          }
        });
      }
    }
  },
  PayoutFilter: {
    plans: {
      and($where, value) {
        assertAllowed101(value, "list");
        if (value == null) return;
        return $where.andPlan();
      },
      createdAt(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec66;
        return condition;
      },
      fromOrganization($where, value) {
        assertAllowed100(value, "object");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: organizationIdentifier,
          alias: resource_organizationPgResource.name
        });
        registryConfig.pgRelations.payout.organizationByMyFromOrganizationId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.payout.organizationByMyFromOrganizationId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      fromOrganizationId(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec64;
        return condition;
      },
      not($where, value) {
        assertAllowed101(value, "object");
        if (value == null) return;
        return $where.notPlan().andPlan();
      },
      or($where, value) {
        assertAllowed101(value, "list");
        if (value == null) return;
        const $or = $where.orPlan();
        return () => $or.andPlan();
      },
      processorConnection($where, value) {
        assertAllowed100(value, "object");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: paymentProcessorConnectionIdentifier,
          alias: resource_payment_processor_connectionPgResource.name
        });
        registryConfig.pgRelations.payout.paymentProcessorConnectionByMyProcessorConnectionId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.payout.paymentProcessorConnectionByMyProcessorConnectionId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      processorConnectionExists($where, value) {
        assertAllowed100(value, "scalar");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: paymentProcessorConnectionIdentifier,
          alias: resource_payment_processor_connectionPgResource.name,
          equals: value
        });
        registryConfig.pgRelations.payout.paymentProcessorConnectionByMyProcessorConnectionId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.payout.paymentProcessorConnectionByMyProcessorConnectionId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      },
      recipientUser($where, value) {
        assertAllowed100(value, "object");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: userIdentifier,
          alias: resource_userPgResource.name
        });
        registryConfig.pgRelations.payout.userByMyRecipientUserId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.payout.userByMyRecipientUserId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      recipientUserExists($where, value) {
        assertAllowed100(value, "scalar");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: userIdentifier,
          alias: resource_userPgResource.name,
          equals: value
        });
        registryConfig.pgRelations.payout.userByMyRecipientUserId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.payout.userByMyRecipientUserId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      },
      recipientUserId(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec63;
        return condition;
      },
      rowId(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec62;
        return condition;
      },
      status(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec65;
        return condition;
      }
    }
  },
  PayoutInput: {
    baked: createObjectAndApplyChildren,
    plans: {
      amount(obj, val, {
        field,
        schema
      }) {
        obj.set("amount", bakedInputRuntime(schema, field.type, val));
      },
      completedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("completed_at", bakedInputRuntime(schema, field.type, val));
      },
      createdAt(obj, val, {
        field,
        schema
      }) {
        obj.set("created_at", bakedInputRuntime(schema, field.type, val));
      },
      currency(obj, val, {
        field,
        schema
      }) {
        obj.set("currency", bakedInputRuntime(schema, field.type, val));
      },
      description(obj, val, {
        field,
        schema
      }) {
        obj.set("description", bakedInputRuntime(schema, field.type, val));
      },
      externalPayoutId(obj, val, {
        field,
        schema
      }) {
        obj.set("external_payout_id", bakedInputRuntime(schema, field.type, val));
      },
      failureReason(obj, val, {
        field,
        schema
      }) {
        obj.set("failure_reason", bakedInputRuntime(schema, field.type, val));
      },
      feeAmount(obj, val, {
        field,
        schema
      }) {
        obj.set("fee_amount", bakedInputRuntime(schema, field.type, val));
      },
      fromOrganizationId(obj, val, {
        field,
        schema
      }) {
        obj.set("from_organization_id", bakedInputRuntime(schema, field.type, val));
      },
      initiatedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("initiated_at", bakedInputRuntime(schema, field.type, val));
      },
      processor(obj, val, {
        field,
        schema
      }) {
        obj.set("processor", bakedInputRuntime(schema, field.type, val));
      },
      processorConnectionId(obj, val, {
        field,
        schema
      }) {
        obj.set("processor_connection_id", bakedInputRuntime(schema, field.type, val));
      },
      recipientUserId(obj, val, {
        field,
        schema
      }) {
        obj.set("recipient_user_id", bakedInputRuntime(schema, field.type, val));
      },
      rowId(obj, val, {
        field,
        schema
      }) {
        obj.set("id", bakedInputRuntime(schema, field.type, val));
      },
      status(obj, val, {
        field,
        schema
      }) {
        obj.set("status", bakedInputRuntime(schema, field.type, val));
      },
      updatedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("updated_at", bakedInputRuntime(schema, field.type, val));
      }
    }
  },
  PayoutPatch: {
    baked: createObjectAndApplyChildren,
    plans: {
      amount(obj, val, {
        field,
        schema
      }) {
        obj.set("amount", bakedInputRuntime(schema, field.type, val));
      },
      completedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("completed_at", bakedInputRuntime(schema, field.type, val));
      },
      createdAt(obj, val, {
        field,
        schema
      }) {
        obj.set("created_at", bakedInputRuntime(schema, field.type, val));
      },
      currency(obj, val, {
        field,
        schema
      }) {
        obj.set("currency", bakedInputRuntime(schema, field.type, val));
      },
      description(obj, val, {
        field,
        schema
      }) {
        obj.set("description", bakedInputRuntime(schema, field.type, val));
      },
      externalPayoutId(obj, val, {
        field,
        schema
      }) {
        obj.set("external_payout_id", bakedInputRuntime(schema, field.type, val));
      },
      failureReason(obj, val, {
        field,
        schema
      }) {
        obj.set("failure_reason", bakedInputRuntime(schema, field.type, val));
      },
      feeAmount(obj, val, {
        field,
        schema
      }) {
        obj.set("fee_amount", bakedInputRuntime(schema, field.type, val));
      },
      fromOrganizationId(obj, val, {
        field,
        schema
      }) {
        obj.set("from_organization_id", bakedInputRuntime(schema, field.type, val));
      },
      initiatedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("initiated_at", bakedInputRuntime(schema, field.type, val));
      },
      processor(obj, val, {
        field,
        schema
      }) {
        obj.set("processor", bakedInputRuntime(schema, field.type, val));
      },
      processorConnectionId(obj, val, {
        field,
        schema
      }) {
        obj.set("processor_connection_id", bakedInputRuntime(schema, field.type, val));
      },
      recipientUserId(obj, val, {
        field,
        schema
      }) {
        obj.set("recipient_user_id", bakedInputRuntime(schema, field.type, val));
      },
      rowId(obj, val, {
        field,
        schema
      }) {
        obj.set("id", bakedInputRuntime(schema, field.type, val));
      },
      status(obj, val, {
        field,
        schema
      }) {
        obj.set("status", bakedInputRuntime(schema, field.type, val));
      },
      updatedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("updated_at", bakedInputRuntime(schema, field.type, val));
      }
    }
  },
  PostCondition: {
    plans: {
      authorId($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "author_id",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
          }
        });
      },
      isPublished($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "is_published",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.boolean)}`;
          }
        });
      },
      organizationId($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "organization_id",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
          }
        });
      },
      publishedAt($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "published_at",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.timestamptz)}`;
          }
        });
      },
      rowId($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "id",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
          }
        });
      },
      visibility($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "visibility",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, postVisibilityCodec)}`;
          }
        });
      }
    }
  },
  PostFilter: {
    plans: {
      and($where, value) {
        assertAllowed114(value, "list");
        if (value == null) return;
        return $where.andPlan();
      },
      author($where, value) {
        assertAllowed113(value, "object");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: userIdentifier,
          alias: resource_userPgResource.name
        });
        registryConfig.pgRelations.post.userByMyAuthorId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.post.userByMyAuthorId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      authorId(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec80;
        return condition;
      },
      isPublished(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec82;
        return condition;
      },
      minimumTier($where, value) {
        assertAllowed113(value, "object");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: sponsorshipTierIdentifier,
          alias: resource_sponsorship_tierPgResource.name
        });
        registryConfig.pgRelations.post.sponsorshipTierByMyMinimumTierId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.post.sponsorshipTierByMyMinimumTierId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      minimumTierExists($where, value) {
        assertAllowed113(value, "scalar");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: sponsorshipTierIdentifier,
          alias: resource_sponsorship_tierPgResource.name,
          equals: value
        });
        registryConfig.pgRelations.post.sponsorshipTierByMyMinimumTierId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.post.sponsorshipTierByMyMinimumTierId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      },
      not($where, value) {
        assertAllowed114(value, "object");
        if (value == null) return;
        return $where.notPlan().andPlan();
      },
      or($where, value) {
        assertAllowed114(value, "list");
        if (value == null) return;
        const $or = $where.orPlan();
        return () => $or.andPlan();
      },
      organization($where, value) {
        assertAllowed113(value, "object");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: organizationIdentifier,
          alias: resource_organizationPgResource.name
        });
        registryConfig.pgRelations.post.organizationByMyOrganizationId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.post.organizationByMyOrganizationId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      organizationId(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec79;
        return condition;
      },
      publishedAt(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec83;
        return condition;
      },
      rowId(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec78;
        return condition;
      },
      visibility(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec81;
        return condition;
      }
    }
  },
  PostInput: {
    baked: createObjectAndApplyChildren,
    plans: {
      authorId(obj, val, {
        field,
        schema
      }) {
        obj.set("author_id", bakedInputRuntime(schema, field.type, val));
      },
      content(obj, val, {
        field,
        schema
      }) {
        obj.set("content", bakedInputRuntime(schema, field.type, val));
      },
      createdAt(obj, val, {
        field,
        schema
      }) {
        obj.set("created_at", bakedInputRuntime(schema, field.type, val));
      },
      deletedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("deleted_at", bakedInputRuntime(schema, field.type, val));
      },
      excerpt(obj, val, {
        field,
        schema
      }) {
        obj.set("excerpt", bakedInputRuntime(schema, field.type, val));
      },
      isPublished(obj, val, {
        field,
        schema
      }) {
        obj.set("is_published", bakedInputRuntime(schema, field.type, val));
      },
      minimumTierId(obj, val, {
        field,
        schema
      }) {
        obj.set("minimum_tier_id", bakedInputRuntime(schema, field.type, val));
      },
      organizationId(obj, val, {
        field,
        schema
      }) {
        obj.set("organization_id", bakedInputRuntime(schema, field.type, val));
      },
      publishedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("published_at", bakedInputRuntime(schema, field.type, val));
      },
      rowId(obj, val, {
        field,
        schema
      }) {
        obj.set("id", bakedInputRuntime(schema, field.type, val));
      },
      title(obj, val, {
        field,
        schema
      }) {
        obj.set("title", bakedInputRuntime(schema, field.type, val));
      },
      updatedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("updated_at", bakedInputRuntime(schema, field.type, val));
      },
      visibility(obj, val, {
        field,
        schema
      }) {
        obj.set("visibility", bakedInputRuntime(schema, field.type, val));
      }
    }
  },
  PostPatch: {
    baked: createObjectAndApplyChildren,
    plans: {
      authorId(obj, val, {
        field,
        schema
      }) {
        obj.set("author_id", bakedInputRuntime(schema, field.type, val));
      },
      content(obj, val, {
        field,
        schema
      }) {
        obj.set("content", bakedInputRuntime(schema, field.type, val));
      },
      createdAt(obj, val, {
        field,
        schema
      }) {
        obj.set("created_at", bakedInputRuntime(schema, field.type, val));
      },
      deletedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("deleted_at", bakedInputRuntime(schema, field.type, val));
      },
      excerpt(obj, val, {
        field,
        schema
      }) {
        obj.set("excerpt", bakedInputRuntime(schema, field.type, val));
      },
      isPublished(obj, val, {
        field,
        schema
      }) {
        obj.set("is_published", bakedInputRuntime(schema, field.type, val));
      },
      minimumTierId(obj, val, {
        field,
        schema
      }) {
        obj.set("minimum_tier_id", bakedInputRuntime(schema, field.type, val));
      },
      organizationId(obj, val, {
        field,
        schema
      }) {
        obj.set("organization_id", bakedInputRuntime(schema, field.type, val));
      },
      publishedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("published_at", bakedInputRuntime(schema, field.type, val));
      },
      rowId(obj, val, {
        field,
        schema
      }) {
        obj.set("id", bakedInputRuntime(schema, field.type, val));
      },
      title(obj, val, {
        field,
        schema
      }) {
        obj.set("title", bakedInputRuntime(schema, field.type, val));
      },
      updatedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("updated_at", bakedInputRuntime(schema, field.type, val));
      },
      visibility(obj, val, {
        field,
        schema
      }) {
        obj.set("visibility", bakedInputRuntime(schema, field.type, val));
      }
    }
  },
  PostVisibilityFilter: {
    plans: {
      distinctFrom($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier25 ? resolveSqlIdentifier25(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec52 ? resolveInputCodec52(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve163(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "distinctFrom"
          });
        $where.where(fragment);
      },
      equalTo($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier25 ? resolveSqlIdentifier25(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec52 ? resolveInputCodec52(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve161(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "equalTo"
          });
        $where.where(fragment);
      },
      greaterThan($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier25 ? resolveSqlIdentifier25(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec52 ? resolveInputCodec52(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve169(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "greaterThan"
          });
        $where.where(fragment);
      },
      greaterThanOrEqualTo($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier25 ? resolveSqlIdentifier25(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec52 ? resolveInputCodec52(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve170(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "greaterThanOrEqualTo"
          });
        $where.where(fragment);
      },
      in($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier25 ? resolveSqlIdentifier25(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec53 ? resolveInputCodec53(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve165(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "in"
          });
        $where.where(fragment);
      },
      isNull($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec51 ? resolveInputCodec51(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = resolveSqlValue24 ? resolveSqlValue24($where, value, inputCodec) : sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve160(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "isNull"
          });
        $where.where(fragment);
      },
      lessThan($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier25 ? resolveSqlIdentifier25(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec52 ? resolveInputCodec52(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve167(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "lessThan"
          });
        $where.where(fragment);
      },
      lessThanOrEqualTo($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier25 ? resolveSqlIdentifier25(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec52 ? resolveInputCodec52(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve168(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "lessThanOrEqualTo"
          });
        $where.where(fragment);
      },
      notDistinctFrom($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier25 ? resolveSqlIdentifier25(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec52 ? resolveInputCodec52(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve164(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notDistinctFrom"
          });
        $where.where(fragment);
      },
      notEqualTo($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier25 ? resolveSqlIdentifier25(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec52 ? resolveInputCodec52(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve162(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notEqualTo"
          });
        $where.where(fragment);
      },
      notIn($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier25 ? resolveSqlIdentifier25(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec53 ? resolveInputCodec53(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve166(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notIn"
          });
        $where.where(fragment);
      }
    }
  },
  SponsorshipCondition: {
    plans: {
      frequency($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "frequency",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, sponsorshipFrequencyCodec)}`;
          }
        });
      },
      organizationId($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "organization_id",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
          }
        });
      },
      rowId($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "id",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
          }
        });
      },
      sponsorId($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "sponsor_id",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
          }
        });
      },
      status($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "status",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, sponsorshipStatusCodec)}`;
          }
        });
      },
      tierId($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "tier_id",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
          }
        });
      }
    }
  },
  SponsorshipFilter: {
    plans: {
      and($where, value) {
        assertAllowed91(value, "list");
        if (value == null) return;
        return $where.andPlan();
      },
      frequency(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec55;
        return condition;
      },
      not($where, value) {
        assertAllowed91(value, "object");
        if (value == null) return;
        return $where.notPlan().andPlan();
      },
      or($where, value) {
        assertAllowed91(value, "list");
        if (value == null) return;
        const $or = $where.orPlan();
        return () => $or.andPlan();
      },
      organization($where, value) {
        assertAllowed90(value, "object");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: organizationIdentifier,
          alias: resource_organizationPgResource.name
        });
        registryConfig.pgRelations.sponsorship.organizationByMyOrganizationId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.sponsorship.organizationByMyOrganizationId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      organizationId(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec53;
        return condition;
      },
      rowId(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec51;
        return condition;
      },
      sponsor($where, value) {
        assertAllowed90(value, "object");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: userIdentifier,
          alias: resource_userPgResource.name
        });
        registryConfig.pgRelations.sponsorship.userByMySponsorId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.sponsorship.userByMySponsorId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      sponsorId(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec52;
        return condition;
      },
      status(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec56;
        return condition;
      },
      tier($where, value) {
        assertAllowed90(value, "object");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: sponsorshipTierIdentifier,
          alias: resource_sponsorship_tierPgResource.name
        });
        registryConfig.pgRelations.sponsorship.sponsorshipTierByMyTierId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.sponsorship.sponsorshipTierByMyTierId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      tierExists($where, value) {
        assertAllowed90(value, "scalar");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: sponsorshipTierIdentifier,
          alias: resource_sponsorship_tierPgResource.name,
          equals: value
        });
        registryConfig.pgRelations.sponsorship.sponsorshipTierByMyTierId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.sponsorship.sponsorshipTierByMyTierId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      },
      tierId(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec54;
        return condition;
      }
    }
  },
  SponsorshipFrequencyFilter: {
    plans: {
      distinctFrom($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier22 ? resolveSqlIdentifier22(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec43 ? resolveInputCodec43(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve130(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "distinctFrom"
          });
        $where.where(fragment);
      },
      equalTo($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier22 ? resolveSqlIdentifier22(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec43 ? resolveInputCodec43(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve128(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "equalTo"
          });
        $where.where(fragment);
      },
      greaterThan($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier22 ? resolveSqlIdentifier22(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec43 ? resolveInputCodec43(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve136(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "greaterThan"
          });
        $where.where(fragment);
      },
      greaterThanOrEqualTo($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier22 ? resolveSqlIdentifier22(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec43 ? resolveInputCodec43(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve137(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "greaterThanOrEqualTo"
          });
        $where.where(fragment);
      },
      in($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier22 ? resolveSqlIdentifier22(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec44 ? resolveInputCodec44(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve132(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "in"
          });
        $where.where(fragment);
      },
      isNull($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec42 ? resolveInputCodec42(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = resolveSqlValue21 ? resolveSqlValue21($where, value, inputCodec) : sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve127(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "isNull"
          });
        $where.where(fragment);
      },
      lessThan($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier22 ? resolveSqlIdentifier22(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec43 ? resolveInputCodec43(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve134(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "lessThan"
          });
        $where.where(fragment);
      },
      lessThanOrEqualTo($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier22 ? resolveSqlIdentifier22(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec43 ? resolveInputCodec43(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve135(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "lessThanOrEqualTo"
          });
        $where.where(fragment);
      },
      notDistinctFrom($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier22 ? resolveSqlIdentifier22(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec43 ? resolveInputCodec43(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve131(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notDistinctFrom"
          });
        $where.where(fragment);
      },
      notEqualTo($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier22 ? resolveSqlIdentifier22(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec43 ? resolveInputCodec43(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve129(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notEqualTo"
          });
        $where.where(fragment);
      },
      notIn($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier22 ? resolveSqlIdentifier22(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec44 ? resolveInputCodec44(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve133(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notIn"
          });
        $where.where(fragment);
      }
    }
  },
  SponsorshipInput: {
    baked: createObjectAndApplyChildren,
    plans: {
      amount(obj, val, {
        field,
        schema
      }) {
        obj.set("amount", bakedInputRuntime(schema, field.type, val));
      },
      cancelledAt(obj, val, {
        field,
        schema
      }) {
        obj.set("cancelled_at", bakedInputRuntime(schema, field.type, val));
      },
      createdAt(obj, val, {
        field,
        schema
      }) {
        obj.set("created_at", bakedInputRuntime(schema, field.type, val));
      },
      currency(obj, val, {
        field,
        schema
      }) {
        obj.set("currency", bakedInputRuntime(schema, field.type, val));
      },
      currentPeriodEnd(obj, val, {
        field,
        schema
      }) {
        obj.set("current_period_end", bakedInputRuntime(schema, field.type, val));
      },
      currentPeriodStart(obj, val, {
        field,
        schema
      }) {
        obj.set("current_period_start", bakedInputRuntime(schema, field.type, val));
      },
      externalSubscriptionId(obj, val, {
        field,
        schema
      }) {
        obj.set("external_subscription_id", bakedInputRuntime(schema, field.type, val));
      },
      frequency(obj, val, {
        field,
        schema
      }) {
        obj.set("frequency", bakedInputRuntime(schema, field.type, val));
      },
      isPublic(obj, val, {
        field,
        schema
      }) {
        obj.set("is_public", bakedInputRuntime(schema, field.type, val));
      },
      nextBillingDate(obj, val, {
        field,
        schema
      }) {
        obj.set("next_billing_date", bakedInputRuntime(schema, field.type, val));
      },
      organizationId(obj, val, {
        field,
        schema
      }) {
        obj.set("organization_id", bakedInputRuntime(schema, field.type, val));
      },
      publicMessage(obj, val, {
        field,
        schema
      }) {
        obj.set("public_message", bakedInputRuntime(schema, field.type, val));
      },
      rowId(obj, val, {
        field,
        schema
      }) {
        obj.set("id", bakedInputRuntime(schema, field.type, val));
      },
      sponsorId(obj, val, {
        field,
        schema
      }) {
        obj.set("sponsor_id", bakedInputRuntime(schema, field.type, val));
      },
      startedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("started_at", bakedInputRuntime(schema, field.type, val));
      },
      status(obj, val, {
        field,
        schema
      }) {
        obj.set("status", bakedInputRuntime(schema, field.type, val));
      },
      tierId(obj, val, {
        field,
        schema
      }) {
        obj.set("tier_id", bakedInputRuntime(schema, field.type, val));
      },
      updatedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("updated_at", bakedInputRuntime(schema, field.type, val));
      }
    }
  },
  SponsorshipPatch: {
    baked: createObjectAndApplyChildren,
    plans: {
      amount(obj, val, {
        field,
        schema
      }) {
        obj.set("amount", bakedInputRuntime(schema, field.type, val));
      },
      cancelledAt(obj, val, {
        field,
        schema
      }) {
        obj.set("cancelled_at", bakedInputRuntime(schema, field.type, val));
      },
      createdAt(obj, val, {
        field,
        schema
      }) {
        obj.set("created_at", bakedInputRuntime(schema, field.type, val));
      },
      currency(obj, val, {
        field,
        schema
      }) {
        obj.set("currency", bakedInputRuntime(schema, field.type, val));
      },
      currentPeriodEnd(obj, val, {
        field,
        schema
      }) {
        obj.set("current_period_end", bakedInputRuntime(schema, field.type, val));
      },
      currentPeriodStart(obj, val, {
        field,
        schema
      }) {
        obj.set("current_period_start", bakedInputRuntime(schema, field.type, val));
      },
      externalSubscriptionId(obj, val, {
        field,
        schema
      }) {
        obj.set("external_subscription_id", bakedInputRuntime(schema, field.type, val));
      },
      frequency(obj, val, {
        field,
        schema
      }) {
        obj.set("frequency", bakedInputRuntime(schema, field.type, val));
      },
      isPublic(obj, val, {
        field,
        schema
      }) {
        obj.set("is_public", bakedInputRuntime(schema, field.type, val));
      },
      nextBillingDate(obj, val, {
        field,
        schema
      }) {
        obj.set("next_billing_date", bakedInputRuntime(schema, field.type, val));
      },
      organizationId(obj, val, {
        field,
        schema
      }) {
        obj.set("organization_id", bakedInputRuntime(schema, field.type, val));
      },
      publicMessage(obj, val, {
        field,
        schema
      }) {
        obj.set("public_message", bakedInputRuntime(schema, field.type, val));
      },
      rowId(obj, val, {
        field,
        schema
      }) {
        obj.set("id", bakedInputRuntime(schema, field.type, val));
      },
      sponsorId(obj, val, {
        field,
        schema
      }) {
        obj.set("sponsor_id", bakedInputRuntime(schema, field.type, val));
      },
      startedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("started_at", bakedInputRuntime(schema, field.type, val));
      },
      status(obj, val, {
        field,
        schema
      }) {
        obj.set("status", bakedInputRuntime(schema, field.type, val));
      },
      tierId(obj, val, {
        field,
        schema
      }) {
        obj.set("tier_id", bakedInputRuntime(schema, field.type, val));
      },
      updatedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("updated_at", bakedInputRuntime(schema, field.type, val));
      }
    }
  },
  SponsorshipStatusFilter: {
    plans: {
      distinctFrom($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier23 ? resolveSqlIdentifier23(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec46 ? resolveInputCodec46(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve141(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "distinctFrom"
          });
        $where.where(fragment);
      },
      equalTo($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier23 ? resolveSqlIdentifier23(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec46 ? resolveInputCodec46(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve139(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "equalTo"
          });
        $where.where(fragment);
      },
      greaterThan($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier23 ? resolveSqlIdentifier23(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec46 ? resolveInputCodec46(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve147(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "greaterThan"
          });
        $where.where(fragment);
      },
      greaterThanOrEqualTo($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier23 ? resolveSqlIdentifier23(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec46 ? resolveInputCodec46(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve148(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "greaterThanOrEqualTo"
          });
        $where.where(fragment);
      },
      in($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier23 ? resolveSqlIdentifier23(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec47 ? resolveInputCodec47(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve143(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "in"
          });
        $where.where(fragment);
      },
      isNull($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec45 ? resolveInputCodec45(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = resolveSqlValue22 ? resolveSqlValue22($where, value, inputCodec) : sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve138(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "isNull"
          });
        $where.where(fragment);
      },
      lessThan($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier23 ? resolveSqlIdentifier23(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec46 ? resolveInputCodec46(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve145(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "lessThan"
          });
        $where.where(fragment);
      },
      lessThanOrEqualTo($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier23 ? resolveSqlIdentifier23(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec46 ? resolveInputCodec46(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve146(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "lessThanOrEqualTo"
          });
        $where.where(fragment);
      },
      notDistinctFrom($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier23 ? resolveSqlIdentifier23(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec46 ? resolveInputCodec46(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve142(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notDistinctFrom"
          });
        $where.where(fragment);
      },
      notEqualTo($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier23 ? resolveSqlIdentifier23(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec46 ? resolveInputCodec46(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve140(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notEqualTo"
          });
        $where.where(fragment);
      },
      notIn($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier23 ? resolveSqlIdentifier23(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec47 ? resolveInputCodec47(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve144(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notIn"
          });
        $where.where(fragment);
      }
    }
  },
  SponsorshipTierCondition: {
    plans: {
      isActive($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "is_active",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.boolean)}`;
          }
        });
      },
      organizationId($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "organization_id",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
          }
        });
      },
      rowId($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "id",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
          }
        });
      }
    }
  },
  SponsorshipTierFilter: {
    plans: {
      and($where, value) {
        assertAllowed88(value, "list");
        if (value == null) return;
        return $where.andPlan();
      },
      isActive(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec50;
        return condition;
      },
      not($where, value) {
        assertAllowed88(value, "object");
        if (value == null) return;
        return $where.notPlan().andPlan();
      },
      or($where, value) {
        assertAllowed88(value, "list");
        if (value == null) return;
        const $or = $where.orPlan();
        return () => $or.andPlan();
      },
      organization($where, value) {
        assertAllowed87(value, "object");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: organizationIdentifier,
          alias: resource_organizationPgResource.name
        });
        registryConfig.pgRelations.sponsorshipTier.organizationByMyOrganizationId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.sponsorshipTier.organizationByMyOrganizationId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      organizationId(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec49;
        return condition;
      },
      rowId(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec48;
        return condition;
      },
      sponsorshipsByTierId($where, value) {
        assertAllowed86(value, "object");
        const $rel = $where.andPlan();
        $rel.extensions.pgFilterRelation = {
          tableExpression: sponsorshipIdentifier,
          alias: resource_sponsorshipPgResource.name,
          localAttributes: registryConfig.pgRelations.sponsorshipTier.sponsorshipsByTheirTierId.localAttributes,
          remoteAttributes: registryConfig.pgRelations.sponsorshipTier.sponsorshipsByTheirTierId.remoteAttributes
        };
        return $rel;
      },
      sponsorshipsByTierIdExist($where, value) {
        assertAllowed86(value, "scalar");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: sponsorshipIdentifier,
          alias: resource_sponsorshipPgResource.name,
          equals: value
        });
        registryConfig.pgRelations.sponsorshipTier.sponsorshipsByTheirTierId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.sponsorshipTier.sponsorshipsByTheirTierId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      }
    }
  },
  SponsorshipTierInput: {
    baked: createObjectAndApplyChildren,
    plans: {
      benefits(obj, val, {
        field,
        schema
      }) {
        obj.set("benefits", bakedInputRuntime(schema, field.type, val));
      },
      createdAt(obj, val, {
        field,
        schema
      }) {
        obj.set("created_at", bakedInputRuntime(schema, field.type, val));
      },
      currency(obj, val, {
        field,
        schema
      }) {
        obj.set("currency", bakedInputRuntime(schema, field.type, val));
      },
      deletedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("deleted_at", bakedInputRuntime(schema, field.type, val));
      },
      description(obj, val, {
        field,
        schema
      }) {
        obj.set("description", bakedInputRuntime(schema, field.type, val));
      },
      displayOrder(obj, val, {
        field,
        schema
      }) {
        obj.set("display_order", bakedInputRuntime(schema, field.type, val));
      },
      isActive(obj, val, {
        field,
        schema
      }) {
        obj.set("is_active", bakedInputRuntime(schema, field.type, val));
      },
      isHighlighted(obj, val, {
        field,
        schema
      }) {
        obj.set("is_highlighted", bakedInputRuntime(schema, field.type, val));
      },
      maxSponsors(obj, val, {
        field,
        schema
      }) {
        obj.set("max_sponsors", bakedInputRuntime(schema, field.type, val));
      },
      monthlyAmount(obj, val, {
        field,
        schema
      }) {
        obj.set("monthly_amount", bakedInputRuntime(schema, field.type, val));
      },
      name(obj, val, {
        field,
        schema
      }) {
        obj.set("name", bakedInputRuntime(schema, field.type, val));
      },
      organizationId(obj, val, {
        field,
        schema
      }) {
        obj.set("organization_id", bakedInputRuntime(schema, field.type, val));
      },
      rowId(obj, val, {
        field,
        schema
      }) {
        obj.set("id", bakedInputRuntime(schema, field.type, val));
      },
      updatedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("updated_at", bakedInputRuntime(schema, field.type, val));
      },
      yearlyAmount(obj, val, {
        field,
        schema
      }) {
        obj.set("yearly_amount", bakedInputRuntime(schema, field.type, val));
      }
    }
  },
  SponsorshipTierPatch: {
    baked: createObjectAndApplyChildren,
    plans: {
      benefits(obj, val, {
        field,
        schema
      }) {
        obj.set("benefits", bakedInputRuntime(schema, field.type, val));
      },
      createdAt(obj, val, {
        field,
        schema
      }) {
        obj.set("created_at", bakedInputRuntime(schema, field.type, val));
      },
      currency(obj, val, {
        field,
        schema
      }) {
        obj.set("currency", bakedInputRuntime(schema, field.type, val));
      },
      deletedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("deleted_at", bakedInputRuntime(schema, field.type, val));
      },
      description(obj, val, {
        field,
        schema
      }) {
        obj.set("description", bakedInputRuntime(schema, field.type, val));
      },
      displayOrder(obj, val, {
        field,
        schema
      }) {
        obj.set("display_order", bakedInputRuntime(schema, field.type, val));
      },
      isActive(obj, val, {
        field,
        schema
      }) {
        obj.set("is_active", bakedInputRuntime(schema, field.type, val));
      },
      isHighlighted(obj, val, {
        field,
        schema
      }) {
        obj.set("is_highlighted", bakedInputRuntime(schema, field.type, val));
      },
      maxSponsors(obj, val, {
        field,
        schema
      }) {
        obj.set("max_sponsors", bakedInputRuntime(schema, field.type, val));
      },
      monthlyAmount(obj, val, {
        field,
        schema
      }) {
        obj.set("monthly_amount", bakedInputRuntime(schema, field.type, val));
      },
      name(obj, val, {
        field,
        schema
      }) {
        obj.set("name", bakedInputRuntime(schema, field.type, val));
      },
      organizationId(obj, val, {
        field,
        schema
      }) {
        obj.set("organization_id", bakedInputRuntime(schema, field.type, val));
      },
      rowId(obj, val, {
        field,
        schema
      }) {
        obj.set("id", bakedInputRuntime(schema, field.type, val));
      },
      updatedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("updated_at", bakedInputRuntime(schema, field.type, val));
      },
      yearlyAmount(obj, val, {
        field,
        schema
      }) {
        obj.set("yearly_amount", bakedInputRuntime(schema, field.type, val));
      }
    }
  },
  SponsorshipTierToManySponsorshipFilter: {
    plans: {
      every($where, value) {
        assertAllowed89(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery.notPlan().andPlan();
      },
      none($where, value) {
        assertAllowed89(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      some($where, value) {
        assertAllowed89(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      }
    }
  },
  StringFilter: {
    plans: {
      distinctFrom($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier2 ? resolveSqlIdentifier2(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec5 ? resolveInputCodec5(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve15(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "distinctFrom"
          });
        $where.where(fragment);
      },
      distinctFromInsensitive($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier6 ? resolveSqlIdentifier6(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec10 ? resolveInputCodec10(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = resolveSqlValue5 ? resolveSqlValue5($where, value, inputCodec) : sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve15(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "distinctFromInsensitive"
          });
        $where.where(fragment);
      },
      endsWith($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier2 ? resolveSqlIdentifier2(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = resolveInput9 ? resolveInput9(value) : value,
          inputCodec = resolveInputCodec5 ? resolveInputCodec5(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve31(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "endsWith"
          });
        $where.where(fragment);
      },
      endsWithInsensitive($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier3 ? resolveSqlIdentifier3(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = resolveInput11 ? resolveInput11(value) : value,
          inputCodec = resolveInputCodec7 ? resolveInputCodec7(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve33(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "endsWithInsensitive"
          });
        $where.where(fragment);
      },
      equalTo($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier2 ? resolveSqlIdentifier2(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec5 ? resolveInputCodec5(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve13(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "equalTo"
          });
        $where.where(fragment);
      },
      equalToInsensitive($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier4 ? resolveSqlIdentifier4(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec8 ? resolveInputCodec8(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = resolveSqlValue3 ? resolveSqlValue3($where, value, inputCodec) : sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve13(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "equalToInsensitive"
          });
        $where.where(fragment);
      },
      greaterThan($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier2 ? resolveSqlIdentifier2(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec5 ? resolveInputCodec5(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve21(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "greaterThan"
          });
        $where.where(fragment);
      },
      greaterThanInsensitive($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier12 ? resolveSqlIdentifier12(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec16 ? resolveInputCodec16(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = resolveSqlValue11 ? resolveSqlValue11($where, value, inputCodec) : sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve21(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "greaterThanInsensitive"
          });
        $where.where(fragment);
      },
      greaterThanOrEqualTo($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier2 ? resolveSqlIdentifier2(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec5 ? resolveInputCodec5(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve22(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "greaterThanOrEqualTo"
          });
        $where.where(fragment);
      },
      greaterThanOrEqualToInsensitive($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier13 ? resolveSqlIdentifier13(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec17 ? resolveInputCodec17(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = resolveSqlValue12 ? resolveSqlValue12($where, value, inputCodec) : sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve22(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "greaterThanOrEqualToInsensitive"
          });
        $where.where(fragment);
      },
      in($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier2 ? resolveSqlIdentifier2(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec6 ? resolveInputCodec6(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve17(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "in"
          });
        $where.where(fragment);
      },
      includes($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier2 ? resolveSqlIdentifier2(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = resolveInput ? resolveInput(value) : value,
          inputCodec = resolveInputCodec5 ? resolveInputCodec5(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve23(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "includes"
          });
        $where.where(fragment);
      },
      includesInsensitive($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier3 ? resolveSqlIdentifier3(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = resolveInput3 ? resolveInput3(value) : value,
          inputCodec = resolveInputCodec7 ? resolveInputCodec7(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve25(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "includesInsensitive"
          });
        $where.where(fragment);
      },
      inInsensitive($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier8 ? resolveSqlIdentifier8(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec12 ? resolveInputCodec12(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = resolveSqlValue7 ? resolveSqlValue7($where, value, inputCodec) : sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve17(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "inInsensitive"
          });
        $where.where(fragment);
      },
      isNull($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec4 ? resolveInputCodec4(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = resolveSqlValue2 ? resolveSqlValue2($where, value, inputCodec) : sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve12(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "isNull"
          });
        $where.where(fragment);
      },
      lessThan($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier2 ? resolveSqlIdentifier2(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec5 ? resolveInputCodec5(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve19(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "lessThan"
          });
        $where.where(fragment);
      },
      lessThanInsensitive($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier10 ? resolveSqlIdentifier10(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec14 ? resolveInputCodec14(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = resolveSqlValue9 ? resolveSqlValue9($where, value, inputCodec) : sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve19(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "lessThanInsensitive"
          });
        $where.where(fragment);
      },
      lessThanOrEqualTo($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier2 ? resolveSqlIdentifier2(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec5 ? resolveInputCodec5(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve20(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "lessThanOrEqualTo"
          });
        $where.where(fragment);
      },
      lessThanOrEqualToInsensitive($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier11 ? resolveSqlIdentifier11(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec15 ? resolveInputCodec15(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = resolveSqlValue10 ? resolveSqlValue10($where, value, inputCodec) : sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve20(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "lessThanOrEqualToInsensitive"
          });
        $where.where(fragment);
      },
      like($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier2 ? resolveSqlIdentifier2(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec5 ? resolveInputCodec5(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve35(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "like"
          });
        $where.where(fragment);
      },
      likeInsensitive($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier3 ? resolveSqlIdentifier3(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec7 ? resolveInputCodec7(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve37(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "likeInsensitive"
          });
        $where.where(fragment);
      },
      notDistinctFrom($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier2 ? resolveSqlIdentifier2(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec5 ? resolveInputCodec5(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve16(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notDistinctFrom"
          });
        $where.where(fragment);
      },
      notDistinctFromInsensitive($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier7 ? resolveSqlIdentifier7(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec11 ? resolveInputCodec11(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = resolveSqlValue6 ? resolveSqlValue6($where, value, inputCodec) : sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve16(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notDistinctFromInsensitive"
          });
        $where.where(fragment);
      },
      notEndsWith($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier2 ? resolveSqlIdentifier2(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = resolveInput10 ? resolveInput10(value) : value,
          inputCodec = resolveInputCodec5 ? resolveInputCodec5(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve32(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notEndsWith"
          });
        $where.where(fragment);
      },
      notEndsWithInsensitive($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier3 ? resolveSqlIdentifier3(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = resolveInput12 ? resolveInput12(value) : value,
          inputCodec = resolveInputCodec7 ? resolveInputCodec7(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve34(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notEndsWithInsensitive"
          });
        $where.where(fragment);
      },
      notEqualTo($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier2 ? resolveSqlIdentifier2(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec5 ? resolveInputCodec5(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve14(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notEqualTo"
          });
        $where.where(fragment);
      },
      notEqualToInsensitive($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier5 ? resolveSqlIdentifier5(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec9 ? resolveInputCodec9(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = resolveSqlValue4 ? resolveSqlValue4($where, value, inputCodec) : sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve14(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notEqualToInsensitive"
          });
        $where.where(fragment);
      },
      notIn($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier2 ? resolveSqlIdentifier2(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec6 ? resolveInputCodec6(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve18(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notIn"
          });
        $where.where(fragment);
      },
      notIncludes($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier2 ? resolveSqlIdentifier2(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = resolveInput2 ? resolveInput2(value) : value,
          inputCodec = resolveInputCodec5 ? resolveInputCodec5(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve24(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notIncludes"
          });
        $where.where(fragment);
      },
      notIncludesInsensitive($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier3 ? resolveSqlIdentifier3(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = resolveInput4 ? resolveInput4(value) : value,
          inputCodec = resolveInputCodec7 ? resolveInputCodec7(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve26(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notIncludesInsensitive"
          });
        $where.where(fragment);
      },
      notInInsensitive($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier9 ? resolveSqlIdentifier9(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec13 ? resolveInputCodec13(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = resolveSqlValue8 ? resolveSqlValue8($where, value, inputCodec) : sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve18(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notInInsensitive"
          });
        $where.where(fragment);
      },
      notLike($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier2 ? resolveSqlIdentifier2(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec5 ? resolveInputCodec5(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve36(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notLike"
          });
        $where.where(fragment);
      },
      notLikeInsensitive($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier3 ? resolveSqlIdentifier3(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec7 ? resolveInputCodec7(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve38(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notLikeInsensitive"
          });
        $where.where(fragment);
      },
      notStartsWith($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier2 ? resolveSqlIdentifier2(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = resolveInput6 ? resolveInput6(value) : value,
          inputCodec = resolveInputCodec5 ? resolveInputCodec5(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve28(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notStartsWith"
          });
        $where.where(fragment);
      },
      notStartsWithInsensitive($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier3 ? resolveSqlIdentifier3(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = resolveInput8 ? resolveInput8(value) : value,
          inputCodec = resolveInputCodec7 ? resolveInputCodec7(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve30(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notStartsWithInsensitive"
          });
        $where.where(fragment);
      },
      startsWith($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier2 ? resolveSqlIdentifier2(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = resolveInput5 ? resolveInput5(value) : value,
          inputCodec = resolveInputCodec5 ? resolveInputCodec5(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve27(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "startsWith"
          });
        $where.where(fragment);
      },
      startsWithInsensitive($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier3 ? resolveSqlIdentifier3(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = resolveInput7 ? resolveInput7(value) : value,
          inputCodec = resolveInputCodec7 ? resolveInputCodec7(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve29(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "startsWithInsensitive"
          });
        $where.where(fragment);
      }
    }
  },
  TransactionCondition: {
    plans: {
      createdAt($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "created_at",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.timestamptz)}`;
          }
        });
      },
      externalTransactionId($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "external_transaction_id",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.text)}`;
          }
        });
      },
      fromUserId($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "from_user_id",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
          }
        });
      },
      processorConnectionId($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "processor_connection_id",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
          }
        });
      },
      rowId($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "id",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
          }
        });
      },
      status($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "status",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, transactionStatusCodec)}`;
          }
        });
      },
      toOrganizationId($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "to_organization_id",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
          }
        });
      },
      toUserId($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "to_user_id",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
          }
        });
      },
      transactionType($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "transaction_type",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, transactionTypeCodec)}`;
          }
        });
      }
    }
  },
  TransactionFilter: {
    plans: {
      and($where, value) {
        assertAllowed61(value, "list");
        if (value == null) return;
        return $where.andPlan();
      },
      bountyFundings($where, value) {
        assertAllowed59(value, "object");
        const $rel = $where.andPlan();
        $rel.extensions.pgFilterRelation = {
          tableExpression: bountyFundingIdentifier,
          alias: resource_bounty_fundingPgResource.name,
          localAttributes: registryConfig.pgRelations.transaction.bountyFundingsByTheirTransactionId.localAttributes,
          remoteAttributes: registryConfig.pgRelations.transaction.bountyFundingsByTheirTransactionId.remoteAttributes
        };
        return $rel;
      },
      bountyFundingsExist($where, value) {
        assertAllowed59(value, "scalar");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: bountyFundingIdentifier,
          alias: resource_bounty_fundingPgResource.name,
          equals: value
        });
        registryConfig.pgRelations.transaction.bountyFundingsByTheirTransactionId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.transaction.bountyFundingsByTheirTransactionId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      },
      createdAt(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec27;
        return condition;
      },
      donations($where, value) {
        assertAllowed59(value, "object");
        const $rel = $where.andPlan();
        $rel.extensions.pgFilterRelation = {
          tableExpression: donationIdentifier,
          alias: resource_donationPgResource.name,
          localAttributes: registryConfig.pgRelations.transaction.donationsByTheirTransactionId.localAttributes,
          remoteAttributes: registryConfig.pgRelations.transaction.donationsByTheirTransactionId.remoteAttributes
        };
        return $rel;
      },
      donationsExist($where, value) {
        assertAllowed59(value, "scalar");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: donationIdentifier,
          alias: resource_donationPgResource.name,
          equals: value
        });
        registryConfig.pgRelations.transaction.donationsByTheirTransactionId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.transaction.donationsByTheirTransactionId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      },
      externalTransactionId(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec24;
        return condition;
      },
      fromUser($where, value) {
        assertAllowed60(value, "object");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: userIdentifier,
          alias: resource_userPgResource.name
        });
        registryConfig.pgRelations.transaction.userByMyFromUserId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.transaction.userByMyFromUserId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      fromUserExists($where, value) {
        assertAllowed60(value, "scalar");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: userIdentifier,
          alias: resource_userPgResource.name,
          equals: value
        });
        registryConfig.pgRelations.transaction.userByMyFromUserId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.transaction.userByMyFromUserId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      },
      fromUserId(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec20;
        return condition;
      },
      not($where, value) {
        assertAllowed61(value, "object");
        if (value == null) return;
        return $where.notPlan().andPlan();
      },
      or($where, value) {
        assertAllowed61(value, "list");
        if (value == null) return;
        const $or = $where.orPlan();
        return () => $or.andPlan();
      },
      processorConnection($where, value) {
        assertAllowed60(value, "object");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: paymentProcessorConnectionIdentifier,
          alias: resource_payment_processor_connectionPgResource.name
        });
        registryConfig.pgRelations.transaction.paymentProcessorConnectionByMyProcessorConnectionId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.transaction.paymentProcessorConnectionByMyProcessorConnectionId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      processorConnectionExists($where, value) {
        assertAllowed60(value, "scalar");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: paymentProcessorConnectionIdentifier,
          alias: resource_payment_processor_connectionPgResource.name,
          equals: value
        });
        registryConfig.pgRelations.transaction.paymentProcessorConnectionByMyProcessorConnectionId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.transaction.paymentProcessorConnectionByMyProcessorConnectionId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      },
      processorConnectionId(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec23;
        return condition;
      },
      rowId(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec19;
        return condition;
      },
      status(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec26;
        return condition;
      },
      toOrganization($where, value) {
        assertAllowed60(value, "object");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: organizationIdentifier,
          alias: resource_organizationPgResource.name
        });
        registryConfig.pgRelations.transaction.organizationByMyToOrganizationId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.transaction.organizationByMyToOrganizationId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      toOrganizationExists($where, value) {
        assertAllowed60(value, "scalar");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: organizationIdentifier,
          alias: resource_organizationPgResource.name,
          equals: value
        });
        registryConfig.pgRelations.transaction.organizationByMyToOrganizationId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.transaction.organizationByMyToOrganizationId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      },
      toOrganizationId(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec21;
        return condition;
      },
      toUser($where, value) {
        assertAllowed60(value, "object");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: userIdentifier,
          alias: resource_userPgResource.name
        });
        registryConfig.pgRelations.transaction.userByMyToUserId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.transaction.userByMyToUserId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      toUserExists($where, value) {
        assertAllowed60(value, "scalar");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: userIdentifier,
          alias: resource_userPgResource.name,
          equals: value
        });
        registryConfig.pgRelations.transaction.userByMyToUserId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.transaction.userByMyToUserId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      },
      toUserId(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec22;
        return condition;
      },
      transactionType(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec25;
        return condition;
      }
    }
  },
  TransactionInput: {
    baked: createObjectAndApplyChildren,
    plans: {
      createdAt(obj, val, {
        field,
        schema
      }) {
        obj.set("created_at", bakedInputRuntime(schema, field.type, val));
      },
      currency(obj, val, {
        field,
        schema
      }) {
        obj.set("currency", bakedInputRuntime(schema, field.type, val));
      },
      description(obj, val, {
        field,
        schema
      }) {
        obj.set("description", bakedInputRuntime(schema, field.type, val));
      },
      externalTransactionId(obj, val, {
        field,
        schema
      }) {
        obj.set("external_transaction_id", bakedInputRuntime(schema, field.type, val));
      },
      failureReason(obj, val, {
        field,
        schema
      }) {
        obj.set("failure_reason", bakedInputRuntime(schema, field.type, val));
      },
      fromUserId(obj, val, {
        field,
        schema
      }) {
        obj.set("from_user_id", bakedInputRuntime(schema, field.type, val));
      },
      grossAmount(obj, val, {
        field,
        schema
      }) {
        obj.set("gross_amount", bakedInputRuntime(schema, field.type, val));
      },
      metadata(obj, val, {
        field,
        schema
      }) {
        obj.set("metadata", bakedInputRuntime(schema, field.type, val));
      },
      netAmount(obj, val, {
        field,
        schema
      }) {
        obj.set("net_amount", bakedInputRuntime(schema, field.type, val));
      },
      originalTransactionId(obj, val, {
        field,
        schema
      }) {
        obj.set("original_transaction_id", bakedInputRuntime(schema, field.type, val));
      },
      platformFeeAmount(obj, val, {
        field,
        schema
      }) {
        obj.set("platform_fee_amount", bakedInputRuntime(schema, field.type, val));
      },
      processedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("processed_at", bakedInputRuntime(schema, field.type, val));
      },
      processor(obj, val, {
        field,
        schema
      }) {
        obj.set("processor", bakedInputRuntime(schema, field.type, val));
      },
      processorConnectionId(obj, val, {
        field,
        schema
      }) {
        obj.set("processor_connection_id", bakedInputRuntime(schema, field.type, val));
      },
      processorFeeAmount(obj, val, {
        field,
        schema
      }) {
        obj.set("processor_fee_amount", bakedInputRuntime(schema, field.type, val));
      },
      refundedAmount(obj, val, {
        field,
        schema
      }) {
        obj.set("refunded_amount", bakedInputRuntime(schema, field.type, val));
      },
      rowId(obj, val, {
        field,
        schema
      }) {
        obj.set("id", bakedInputRuntime(schema, field.type, val));
      },
      status(obj, val, {
        field,
        schema
      }) {
        obj.set("status", bakedInputRuntime(schema, field.type, val));
      },
      toOrganizationId(obj, val, {
        field,
        schema
      }) {
        obj.set("to_organization_id", bakedInputRuntime(schema, field.type, val));
      },
      toUserId(obj, val, {
        field,
        schema
      }) {
        obj.set("to_user_id", bakedInputRuntime(schema, field.type, val));
      },
      transactionType(obj, val, {
        field,
        schema
      }) {
        obj.set("transaction_type", bakedInputRuntime(schema, field.type, val));
      },
      updatedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("updated_at", bakedInputRuntime(schema, field.type, val));
      }
    }
  },
  TransactionPatch: {
    baked: createObjectAndApplyChildren,
    plans: {
      createdAt(obj, val, {
        field,
        schema
      }) {
        obj.set("created_at", bakedInputRuntime(schema, field.type, val));
      },
      currency(obj, val, {
        field,
        schema
      }) {
        obj.set("currency", bakedInputRuntime(schema, field.type, val));
      },
      description(obj, val, {
        field,
        schema
      }) {
        obj.set("description", bakedInputRuntime(schema, field.type, val));
      },
      externalTransactionId(obj, val, {
        field,
        schema
      }) {
        obj.set("external_transaction_id", bakedInputRuntime(schema, field.type, val));
      },
      failureReason(obj, val, {
        field,
        schema
      }) {
        obj.set("failure_reason", bakedInputRuntime(schema, field.type, val));
      },
      fromUserId(obj, val, {
        field,
        schema
      }) {
        obj.set("from_user_id", bakedInputRuntime(schema, field.type, val));
      },
      grossAmount(obj, val, {
        field,
        schema
      }) {
        obj.set("gross_amount", bakedInputRuntime(schema, field.type, val));
      },
      metadata(obj, val, {
        field,
        schema
      }) {
        obj.set("metadata", bakedInputRuntime(schema, field.type, val));
      },
      netAmount(obj, val, {
        field,
        schema
      }) {
        obj.set("net_amount", bakedInputRuntime(schema, field.type, val));
      },
      originalTransactionId(obj, val, {
        field,
        schema
      }) {
        obj.set("original_transaction_id", bakedInputRuntime(schema, field.type, val));
      },
      platformFeeAmount(obj, val, {
        field,
        schema
      }) {
        obj.set("platform_fee_amount", bakedInputRuntime(schema, field.type, val));
      },
      processedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("processed_at", bakedInputRuntime(schema, field.type, val));
      },
      processor(obj, val, {
        field,
        schema
      }) {
        obj.set("processor", bakedInputRuntime(schema, field.type, val));
      },
      processorConnectionId(obj, val, {
        field,
        schema
      }) {
        obj.set("processor_connection_id", bakedInputRuntime(schema, field.type, val));
      },
      processorFeeAmount(obj, val, {
        field,
        schema
      }) {
        obj.set("processor_fee_amount", bakedInputRuntime(schema, field.type, val));
      },
      refundedAmount(obj, val, {
        field,
        schema
      }) {
        obj.set("refunded_amount", bakedInputRuntime(schema, field.type, val));
      },
      rowId(obj, val, {
        field,
        schema
      }) {
        obj.set("id", bakedInputRuntime(schema, field.type, val));
      },
      status(obj, val, {
        field,
        schema
      }) {
        obj.set("status", bakedInputRuntime(schema, field.type, val));
      },
      toOrganizationId(obj, val, {
        field,
        schema
      }) {
        obj.set("to_organization_id", bakedInputRuntime(schema, field.type, val));
      },
      toUserId(obj, val, {
        field,
        schema
      }) {
        obj.set("to_user_id", bakedInputRuntime(schema, field.type, val));
      },
      transactionType(obj, val, {
        field,
        schema
      }) {
        obj.set("transaction_type", bakedInputRuntime(schema, field.type, val));
      },
      updatedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("updated_at", bakedInputRuntime(schema, field.type, val));
      }
    }
  },
  TransactionStatusFilter: {
    plans: {
      distinctFrom($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier18 ? resolveSqlIdentifier18(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec31 ? resolveInputCodec31(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve86(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "distinctFrom"
          });
        $where.where(fragment);
      },
      equalTo($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier18 ? resolveSqlIdentifier18(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec31 ? resolveInputCodec31(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve84(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "equalTo"
          });
        $where.where(fragment);
      },
      greaterThan($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier18 ? resolveSqlIdentifier18(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec31 ? resolveInputCodec31(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve92(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "greaterThan"
          });
        $where.where(fragment);
      },
      greaterThanOrEqualTo($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier18 ? resolveSqlIdentifier18(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec31 ? resolveInputCodec31(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve93(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "greaterThanOrEqualTo"
          });
        $where.where(fragment);
      },
      in($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier18 ? resolveSqlIdentifier18(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec32 ? resolveInputCodec32(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve88(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "in"
          });
        $where.where(fragment);
      },
      isNull($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec30 ? resolveInputCodec30(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = resolveSqlValue17 ? resolveSqlValue17($where, value, inputCodec) : sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve83(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "isNull"
          });
        $where.where(fragment);
      },
      lessThan($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier18 ? resolveSqlIdentifier18(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec31 ? resolveInputCodec31(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve90(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "lessThan"
          });
        $where.where(fragment);
      },
      lessThanOrEqualTo($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier18 ? resolveSqlIdentifier18(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec31 ? resolveInputCodec31(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve91(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "lessThanOrEqualTo"
          });
        $where.where(fragment);
      },
      notDistinctFrom($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier18 ? resolveSqlIdentifier18(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec31 ? resolveInputCodec31(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve87(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notDistinctFrom"
          });
        $where.where(fragment);
      },
      notEqualTo($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier18 ? resolveSqlIdentifier18(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec31 ? resolveInputCodec31(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve85(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notEqualTo"
          });
        $where.where(fragment);
      },
      notIn($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier18 ? resolveSqlIdentifier18(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec32 ? resolveInputCodec32(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve89(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notIn"
          });
        $where.where(fragment);
      }
    }
  },
  TransactionToManyBountyFundingFilter: {
    plans: {
      every($where, value) {
        assertAllowed62(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery.notPlan().andPlan();
      },
      none($where, value) {
        assertAllowed62(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      some($where, value) {
        assertAllowed62(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      }
    }
  },
  TransactionToManyDonationFilter: {
    plans: {
      every($where, value) {
        assertAllowed63(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery.notPlan().andPlan();
      },
      none($where, value) {
        assertAllowed63(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      some($where, value) {
        assertAllowed63(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      }
    }
  },
  TransactionTypeFilter: {
    plans: {
      distinctFrom($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier17 ? resolveSqlIdentifier17(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec28 ? resolveInputCodec28(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve75(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "distinctFrom"
          });
        $where.where(fragment);
      },
      equalTo($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier17 ? resolveSqlIdentifier17(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec28 ? resolveInputCodec28(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve73(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "equalTo"
          });
        $where.where(fragment);
      },
      greaterThan($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier17 ? resolveSqlIdentifier17(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec28 ? resolveInputCodec28(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve81(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "greaterThan"
          });
        $where.where(fragment);
      },
      greaterThanOrEqualTo($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier17 ? resolveSqlIdentifier17(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec28 ? resolveInputCodec28(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve82(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "greaterThanOrEqualTo"
          });
        $where.where(fragment);
      },
      in($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier17 ? resolveSqlIdentifier17(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec29 ? resolveInputCodec29(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve77(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "in"
          });
        $where.where(fragment);
      },
      isNull($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec27 ? resolveInputCodec27(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = resolveSqlValue16 ? resolveSqlValue16($where, value, inputCodec) : sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve72(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "isNull"
          });
        $where.where(fragment);
      },
      lessThan($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier17 ? resolveSqlIdentifier17(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec28 ? resolveInputCodec28(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve79(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "lessThan"
          });
        $where.where(fragment);
      },
      lessThanOrEqualTo($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier17 ? resolveSqlIdentifier17(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec28 ? resolveInputCodec28(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve80(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "lessThanOrEqualTo"
          });
        $where.where(fragment);
      },
      notDistinctFrom($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier17 ? resolveSqlIdentifier17(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec28 ? resolveInputCodec28(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve76(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notDistinctFrom"
          });
        $where.where(fragment);
      },
      notEqualTo($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier17 ? resolveSqlIdentifier17(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec28 ? resolveInputCodec28(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve74(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notEqualTo"
          });
        $where.where(fragment);
      },
      notIn($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier17 ? resolveSqlIdentifier17(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec29 ? resolveInputCodec29(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve78(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notIn"
          });
        $where.where(fragment);
      }
    }
  },
  UpdateAuditLogByIdInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      },
      patch(qb, arg) {
        if (arg != null) return qb.setBuilder();
      }
    }
  },
  UpdateAuditLogInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      },
      patch(qb, arg) {
        if (arg != null) return qb.setBuilder();
      }
    }
  },
  UpdateBountyByIdInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      },
      patch(qb, arg) {
        if (arg != null) return qb.setBuilder();
      }
    }
  },
  UpdateBountyFundingByIdInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      },
      patch(qb, arg) {
        if (arg != null) return qb.setBuilder();
      }
    }
  },
  UpdateBountyFundingInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      },
      patch(qb, arg) {
        if (arg != null) return qb.setBuilder();
      }
    }
  },
  UpdateBountyInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      },
      patch(qb, arg) {
        if (arg != null) return qb.setBuilder();
      }
    }
  },
  UpdateDonationByIdInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      },
      patch(qb, arg) {
        if (arg != null) return qb.setBuilder();
      }
    }
  },
  UpdateDonationInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      },
      patch(qb, arg) {
        if (arg != null) return qb.setBuilder();
      }
    }
  },
  UpdateGoalByIdInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      },
      patch(qb, arg) {
        if (arg != null) return qb.setBuilder();
      }
    }
  },
  UpdateGoalInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      },
      patch(qb, arg) {
        if (arg != null) return qb.setBuilder();
      }
    }
  },
  UpdateGrantApplicationByIdInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      },
      patch(qb, arg) {
        if (arg != null) return qb.setBuilder();
      }
    }
  },
  UpdateGrantApplicationInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      },
      patch(qb, arg) {
        if (arg != null) return qb.setBuilder();
      }
    }
  },
  UpdateGrantMilestoneByIdInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      },
      patch(qb, arg) {
        if (arg != null) return qb.setBuilder();
      }
    }
  },
  UpdateGrantMilestoneInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      },
      patch(qb, arg) {
        if (arg != null) return qb.setBuilder();
      }
    }
  },
  UpdateGrantProgramByIdInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      },
      patch(qb, arg) {
        if (arg != null) return qb.setBuilder();
      }
    }
  },
  UpdateGrantProgramInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      },
      patch(qb, arg) {
        if (arg != null) return qb.setBuilder();
      }
    }
  },
  UpdateOrganizationByIdInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      },
      patch(qb, arg) {
        if (arg != null) return qb.setBuilder();
      }
    }
  },
  UpdateOrganizationBySlugInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      },
      patch(qb, arg) {
        if (arg != null) return qb.setBuilder();
      }
    }
  },
  UpdateOrganizationInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      },
      patch(qb, arg) {
        if (arg != null) return qb.setBuilder();
      }
    }
  },
  UpdatePaymentProcessorConnectionByIdInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      },
      patch(qb, arg) {
        if (arg != null) return qb.setBuilder();
      }
    }
  },
  UpdatePaymentProcessorConnectionInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      },
      patch(qb, arg) {
        if (arg != null) return qb.setBuilder();
      }
    }
  },
  UpdatePayoutByIdInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      },
      patch(qb, arg) {
        if (arg != null) return qb.setBuilder();
      }
    }
  },
  UpdatePayoutInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      },
      patch(qb, arg) {
        if (arg != null) return qb.setBuilder();
      }
    }
  },
  UpdatePostByIdInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      },
      patch(qb, arg) {
        if (arg != null) return qb.setBuilder();
      }
    }
  },
  UpdatePostInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      },
      patch(qb, arg) {
        if (arg != null) return qb.setBuilder();
      }
    }
  },
  UpdateSponsorshipByIdInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      },
      patch(qb, arg) {
        if (arg != null) return qb.setBuilder();
      }
    }
  },
  UpdateSponsorshipInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      },
      patch(qb, arg) {
        if (arg != null) return qb.setBuilder();
      }
    }
  },
  UpdateSponsorshipTierByIdInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      },
      patch(qb, arg) {
        if (arg != null) return qb.setBuilder();
      }
    }
  },
  UpdateSponsorshipTierInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      },
      patch(qb, arg) {
        if (arg != null) return qb.setBuilder();
      }
    }
  },
  UpdateTransactionByIdInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      },
      patch(qb, arg) {
        if (arg != null) return qb.setBuilder();
      }
    }
  },
  UpdateTransactionInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      },
      patch(qb, arg) {
        if (arg != null) return qb.setBuilder();
      }
    }
  },
  UpdateUserByIdInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      },
      patch(qb, arg) {
        if (arg != null) return qb.setBuilder();
      }
    }
  },
  UpdateUserByUsernameInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      },
      patch(qb, arg) {
        if (arg != null) return qb.setBuilder();
      }
    }
  },
  UpdateUserIdentityByIdInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      },
      patch(qb, arg) {
        if (arg != null) return qb.setBuilder();
      }
    }
  },
  UpdateUserIdentityInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      },
      patch(qb, arg) {
        if (arg != null) return qb.setBuilder();
      }
    }
  },
  UpdateUserInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      },
      patch(qb, arg) {
        if (arg != null) return qb.setBuilder();
      }
    }
  },
  UpdateUserOrganizationByIdInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      },
      patch(qb, arg) {
        if (arg != null) return qb.setBuilder();
      }
    }
  },
  UpdateUserOrganizationInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      },
      patch(qb, arg) {
        if (arg != null) return qb.setBuilder();
      }
    }
  },
  UpdateWebhookDeliveryByIdInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      },
      patch(qb, arg) {
        if (arg != null) return qb.setBuilder();
      }
    }
  },
  UpdateWebhookDeliveryInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      },
      patch(qb, arg) {
        if (arg != null) return qb.setBuilder();
      }
    }
  },
  UpdateWebhookEndpointByIdInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      },
      patch(qb, arg) {
        if (arg != null) return qb.setBuilder();
      }
    }
  },
  UpdateWebhookEndpointInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      },
      patch(qb, arg) {
        if (arg != null) return qb.setBuilder();
      }
    }
  },
  UpdateWorkspaceByIdInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      },
      patch(qb, arg) {
        if (arg != null) return qb.setBuilder();
      }
    }
  },
  UpdateWorkspaceInput: {
    plans: {
      clientMutationId(qb, val) {
        qb.setMeta("clientMutationId", val);
      },
      patch(qb, arg) {
        if (arg != null) return qb.setBuilder();
      }
    }
  },
  UserCondition: {
    plans: {
      rowId($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "id",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
          }
        });
      },
      username($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "username",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.text)}`;
          }
        });
      }
    }
  },
  UserFilter: {
    plans: {
      and($where, value) {
        assertAllowed50(value, "list");
        if (value == null) return;
        return $where.andPlan();
      },
      auditLogsByActorUserId($where, value) {
        assertAllowed49(value, "object");
        const $rel = $where.andPlan();
        $rel.extensions.pgFilterRelation = {
          tableExpression: auditLogIdentifier,
          alias: resource_audit_logPgResource.name,
          localAttributes: registryConfig.pgRelations.user.auditLogsByTheirActorUserId.localAttributes,
          remoteAttributes: registryConfig.pgRelations.user.auditLogsByTheirActorUserId.remoteAttributes
        };
        return $rel;
      },
      auditLogsByActorUserIdExist($where, value) {
        assertAllowed49(value, "scalar");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: auditLogIdentifier,
          alias: resource_audit_logPgResource.name,
          equals: value
        });
        registryConfig.pgRelations.user.auditLogsByTheirActorUserId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.user.auditLogsByTheirActorUserId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      },
      authoredPosts($where, value) {
        assertAllowed49(value, "object");
        const $rel = $where.andPlan();
        $rel.extensions.pgFilterRelation = {
          tableExpression: postIdentifier,
          alias: resource_postPgResource.name,
          localAttributes: registryConfig.pgRelations.user.postsByTheirAuthorId.localAttributes,
          remoteAttributes: registryConfig.pgRelations.user.postsByTheirAuthorId.remoteAttributes
        };
        return $rel;
      },
      authoredPostsExist($where, value) {
        assertAllowed49(value, "scalar");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: postIdentifier,
          alias: resource_postPgResource.name,
          equals: value
        });
        registryConfig.pgRelations.user.postsByTheirAuthorId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.user.postsByTheirAuthorId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      },
      bountiesByClaimantId($where, value) {
        assertAllowed49(value, "object");
        const $rel = $where.andPlan();
        $rel.extensions.pgFilterRelation = {
          tableExpression: bountyIdentifier,
          alias: resource_bountyPgResource.name,
          localAttributes: registryConfig.pgRelations.user.bountiesByTheirClaimantId.localAttributes,
          remoteAttributes: registryConfig.pgRelations.user.bountiesByTheirClaimantId.remoteAttributes
        };
        return $rel;
      },
      bountiesByClaimantIdExist($where, value) {
        assertAllowed49(value, "scalar");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: bountyIdentifier,
          alias: resource_bountyPgResource.name,
          equals: value
        });
        registryConfig.pgRelations.user.bountiesByTheirClaimantId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.user.bountiesByTheirClaimantId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      },
      bountyFundingsByFunderId($where, value) {
        assertAllowed49(value, "object");
        const $rel = $where.andPlan();
        $rel.extensions.pgFilterRelation = {
          tableExpression: bountyFundingIdentifier,
          alias: resource_bounty_fundingPgResource.name,
          localAttributes: registryConfig.pgRelations.user.bountyFundingsByTheirFunderId.localAttributes,
          remoteAttributes: registryConfig.pgRelations.user.bountyFundingsByTheirFunderId.remoteAttributes
        };
        return $rel;
      },
      bountyFundingsByFunderIdExist($where, value) {
        assertAllowed49(value, "scalar");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: bountyFundingIdentifier,
          alias: resource_bounty_fundingPgResource.name,
          equals: value
        });
        registryConfig.pgRelations.user.bountyFundingsByTheirFunderId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.user.bountyFundingsByTheirFunderId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      },
      donationsByDonorId($where, value) {
        assertAllowed49(value, "object");
        const $rel = $where.andPlan();
        $rel.extensions.pgFilterRelation = {
          tableExpression: donationIdentifier,
          alias: resource_donationPgResource.name,
          localAttributes: registryConfig.pgRelations.user.donationsByTheirDonorId.localAttributes,
          remoteAttributes: registryConfig.pgRelations.user.donationsByTheirDonorId.remoteAttributes
        };
        return $rel;
      },
      donationsByDonorIdExist($where, value) {
        assertAllowed49(value, "scalar");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: donationIdentifier,
          alias: resource_donationPgResource.name,
          equals: value
        });
        registryConfig.pgRelations.user.donationsByTheirDonorId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.user.donationsByTheirDonorId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      },
      grantApplicationsByApplicantId($where, value) {
        assertAllowed49(value, "object");
        const $rel = $where.andPlan();
        $rel.extensions.pgFilterRelation = {
          tableExpression: grantApplicationIdentifier,
          alias: resource_grant_applicationPgResource.name,
          localAttributes: registryConfig.pgRelations.user.grantApplicationsByTheirApplicantId.localAttributes,
          remoteAttributes: registryConfig.pgRelations.user.grantApplicationsByTheirApplicantId.remoteAttributes
        };
        return $rel;
      },
      grantApplicationsByApplicantIdExist($where, value) {
        assertAllowed49(value, "scalar");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: grantApplicationIdentifier,
          alias: resource_grant_applicationPgResource.name,
          equals: value
        });
        registryConfig.pgRelations.user.grantApplicationsByTheirApplicantId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.user.grantApplicationsByTheirApplicantId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      },
      not($where, value) {
        assertAllowed50(value, "object");
        if (value == null) return;
        return $where.notPlan().andPlan();
      },
      or($where, value) {
        assertAllowed50(value, "list");
        if (value == null) return;
        const $or = $where.orPlan();
        return () => $or.andPlan();
      },
      payoutsByRecipientUserId($where, value) {
        assertAllowed49(value, "object");
        const $rel = $where.andPlan();
        $rel.extensions.pgFilterRelation = {
          tableExpression: payoutIdentifier,
          alias: resource_payoutPgResource.name,
          localAttributes: registryConfig.pgRelations.user.payoutsByTheirRecipientUserId.localAttributes,
          remoteAttributes: registryConfig.pgRelations.user.payoutsByTheirRecipientUserId.remoteAttributes
        };
        return $rel;
      },
      payoutsByRecipientUserIdExist($where, value) {
        assertAllowed49(value, "scalar");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: payoutIdentifier,
          alias: resource_payoutPgResource.name,
          equals: value
        });
        registryConfig.pgRelations.user.payoutsByTheirRecipientUserId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.user.payoutsByTheirRecipientUserId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      },
      rowId(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec8;
        return condition;
      },
      sponsorshipsBySponsorId($where, value) {
        assertAllowed49(value, "object");
        const $rel = $where.andPlan();
        $rel.extensions.pgFilterRelation = {
          tableExpression: sponsorshipIdentifier,
          alias: resource_sponsorshipPgResource.name,
          localAttributes: registryConfig.pgRelations.user.sponsorshipsByTheirSponsorId.localAttributes,
          remoteAttributes: registryConfig.pgRelations.user.sponsorshipsByTheirSponsorId.remoteAttributes
        };
        return $rel;
      },
      sponsorshipsBySponsorIdExist($where, value) {
        assertAllowed49(value, "scalar");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: sponsorshipIdentifier,
          alias: resource_sponsorshipPgResource.name,
          equals: value
        });
        registryConfig.pgRelations.user.sponsorshipsByTheirSponsorId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.user.sponsorshipsByTheirSponsorId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      },
      transactionsByFromUserId($where, value) {
        assertAllowed49(value, "object");
        const $rel = $where.andPlan();
        $rel.extensions.pgFilterRelation = {
          tableExpression: transactionIdentifier,
          alias: resource_transactionPgResource.name,
          localAttributes: registryConfig.pgRelations.user.transactionsByTheirFromUserId.localAttributes,
          remoteAttributes: registryConfig.pgRelations.user.transactionsByTheirFromUserId.remoteAttributes
        };
        return $rel;
      },
      transactionsByFromUserIdExist($where, value) {
        assertAllowed49(value, "scalar");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: transactionIdentifier,
          alias: resource_transactionPgResource.name,
          equals: value
        });
        registryConfig.pgRelations.user.transactionsByTheirFromUserId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.user.transactionsByTheirFromUserId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      },
      transactionsByToUserId($where, value) {
        assertAllowed49(value, "object");
        const $rel = $where.andPlan();
        $rel.extensions.pgFilterRelation = {
          tableExpression: transactionIdentifier,
          alias: resource_transactionPgResource.name,
          localAttributes: registryConfig.pgRelations.user.transactionsByTheirToUserId.localAttributes,
          remoteAttributes: registryConfig.pgRelations.user.transactionsByTheirToUserId.remoteAttributes
        };
        return $rel;
      },
      transactionsByToUserIdExist($where, value) {
        assertAllowed49(value, "scalar");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: transactionIdentifier,
          alias: resource_transactionPgResource.name,
          equals: value
        });
        registryConfig.pgRelations.user.transactionsByTheirToUserId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.user.transactionsByTheirToUserId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      },
      userIdentities($where, value) {
        assertAllowed49(value, "object");
        const $rel = $where.andPlan();
        $rel.extensions.pgFilterRelation = {
          tableExpression: userIdentityIdentifier,
          alias: resource_user_identityPgResource.name,
          localAttributes: registryConfig.pgRelations.user.userIdentitiesByTheirUserId.localAttributes,
          remoteAttributes: registryConfig.pgRelations.user.userIdentitiesByTheirUserId.remoteAttributes
        };
        return $rel;
      },
      userIdentitiesExist($where, value) {
        assertAllowed49(value, "scalar");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: userIdentityIdentifier,
          alias: resource_user_identityPgResource.name,
          equals: value
        });
        registryConfig.pgRelations.user.userIdentitiesByTheirUserId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.user.userIdentitiesByTheirUserId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      },
      username(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec9;
        return condition;
      },
      userOrganizations($where, value) {
        assertAllowed49(value, "object");
        const $rel = $where.andPlan();
        $rel.extensions.pgFilterRelation = {
          tableExpression: userOrganizationIdentifier,
          alias: resource_user_organizationPgResource.name,
          localAttributes: registryConfig.pgRelations.user.userOrganizationsByTheirUserId.localAttributes,
          remoteAttributes: registryConfig.pgRelations.user.userOrganizationsByTheirUserId.remoteAttributes
        };
        return $rel;
      },
      userOrganizationsExist($where, value) {
        assertAllowed49(value, "scalar");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: userOrganizationIdentifier,
          alias: resource_user_organizationPgResource.name,
          equals: value
        });
        registryConfig.pgRelations.user.userOrganizationsByTheirUserId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.user.userOrganizationsByTheirUserId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      }
    }
  },
  UserIdentityCondition: {
    plans: {
      provider($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "provider",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, identityProviderCodec)}`;
          }
        });
      },
      providerUserId($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "provider_user_id",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.text)}`;
          }
        });
      },
      rowId($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "id",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
          }
        });
      },
      userId($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "user_id",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
          }
        });
      }
    }
  },
  UserIdentityFilter: {
    plans: {
      and($where, value) {
        assertAllowed120(value, "list");
        if (value == null) return;
        return $where.andPlan();
      },
      not($where, value) {
        assertAllowed120(value, "object");
        if (value == null) return;
        return $where.notPlan().andPlan();
      },
      or($where, value) {
        assertAllowed120(value, "list");
        if (value == null) return;
        const $or = $where.orPlan();
        return () => $or.andPlan();
      },
      provider(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec86;
        return condition;
      },
      providerUserId(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec87;
        return condition;
      },
      rowId(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec84;
        return condition;
      },
      user($where, value) {
        assertAllowed119(value, "object");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: userIdentifier,
          alias: resource_userPgResource.name
        });
        registryConfig.pgRelations.userIdentity.userByMyUserId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.userIdentity.userByMyUserId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      userId(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec85;
        return condition;
      }
    }
  },
  UserIdentityInput: {
    baked: createObjectAndApplyChildren,
    plans: {
      accessToken(obj, val, {
        field,
        schema
      }) {
        obj.set("access_token", bakedInputRuntime(schema, field.type, val));
      },
      createdAt(obj, val, {
        field,
        schema
      }) {
        obj.set("created_at", bakedInputRuntime(schema, field.type, val));
      },
      provider(obj, val, {
        field,
        schema
      }) {
        obj.set("provider", bakedInputRuntime(schema, field.type, val));
      },
      providerEmail(obj, val, {
        field,
        schema
      }) {
        obj.set("provider_email", bakedInputRuntime(schema, field.type, val));
      },
      providerUserId(obj, val, {
        field,
        schema
      }) {
        obj.set("provider_user_id", bakedInputRuntime(schema, field.type, val));
      },
      providerUsername(obj, val, {
        field,
        schema
      }) {
        obj.set("provider_username", bakedInputRuntime(schema, field.type, val));
      },
      refreshToken(obj, val, {
        field,
        schema
      }) {
        obj.set("refresh_token", bakedInputRuntime(schema, field.type, val));
      },
      rowId(obj, val, {
        field,
        schema
      }) {
        obj.set("id", bakedInputRuntime(schema, field.type, val));
      },
      tokenExpiresAt(obj, val, {
        field,
        schema
      }) {
        obj.set("token_expires_at", bakedInputRuntime(schema, field.type, val));
      },
      updatedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("updated_at", bakedInputRuntime(schema, field.type, val));
      },
      userId(obj, val, {
        field,
        schema
      }) {
        obj.set("user_id", bakedInputRuntime(schema, field.type, val));
      }
    }
  },
  UserIdentityPatch: {
    baked: createObjectAndApplyChildren,
    plans: {
      accessToken(obj, val, {
        field,
        schema
      }) {
        obj.set("access_token", bakedInputRuntime(schema, field.type, val));
      },
      createdAt(obj, val, {
        field,
        schema
      }) {
        obj.set("created_at", bakedInputRuntime(schema, field.type, val));
      },
      provider(obj, val, {
        field,
        schema
      }) {
        obj.set("provider", bakedInputRuntime(schema, field.type, val));
      },
      providerEmail(obj, val, {
        field,
        schema
      }) {
        obj.set("provider_email", bakedInputRuntime(schema, field.type, val));
      },
      providerUserId(obj, val, {
        field,
        schema
      }) {
        obj.set("provider_user_id", bakedInputRuntime(schema, field.type, val));
      },
      providerUsername(obj, val, {
        field,
        schema
      }) {
        obj.set("provider_username", bakedInputRuntime(schema, field.type, val));
      },
      refreshToken(obj, val, {
        field,
        schema
      }) {
        obj.set("refresh_token", bakedInputRuntime(schema, field.type, val));
      },
      rowId(obj, val, {
        field,
        schema
      }) {
        obj.set("id", bakedInputRuntime(schema, field.type, val));
      },
      tokenExpiresAt(obj, val, {
        field,
        schema
      }) {
        obj.set("token_expires_at", bakedInputRuntime(schema, field.type, val));
      },
      updatedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("updated_at", bakedInputRuntime(schema, field.type, val));
      },
      userId(obj, val, {
        field,
        schema
      }) {
        obj.set("user_id", bakedInputRuntime(schema, field.type, val));
      }
    }
  },
  UserInput: {
    baked: createObjectAndApplyChildren,
    plans: {
      avatarUrl(obj, val, {
        field,
        schema
      }) {
        obj.set("avatar_url", bakedInputRuntime(schema, field.type, val));
      },
      bio(obj, val, {
        field,
        schema
      }) {
        obj.set("bio", bakedInputRuntime(schema, field.type, val));
      },
      createdAt(obj, val, {
        field,
        schema
      }) {
        obj.set("created_at", bakedInputRuntime(schema, field.type, val));
      },
      deletedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("deleted_at", bakedInputRuntime(schema, field.type, val));
      },
      displayName(obj, val, {
        field,
        schema
      }) {
        obj.set("display_name", bakedInputRuntime(schema, field.type, val));
      },
      rowId(obj, val, {
        field,
        schema
      }) {
        obj.set("id", bakedInputRuntime(schema, field.type, val));
      },
      updatedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("updated_at", bakedInputRuntime(schema, field.type, val));
      },
      username(obj, val, {
        field,
        schema
      }) {
        obj.set("username", bakedInputRuntime(schema, field.type, val));
      },
      websiteUrl(obj, val, {
        field,
        schema
      }) {
        obj.set("website_url", bakedInputRuntime(schema, field.type, val));
      }
    }
  },
  UserOrganizationCondition: {
    plans: {
      organizationId($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "organization_id",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
          }
        });
      },
      rowId($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "id",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
          }
        });
      },
      userId($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "user_id",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
          }
        });
      }
    }
  },
  UserOrganizationFilter: {
    plans: {
      and($where, value) {
        assertAllowed84(value, "list");
        if (value == null) return;
        return $where.andPlan();
      },
      not($where, value) {
        assertAllowed84(value, "object");
        if (value == null) return;
        return $where.notPlan().andPlan();
      },
      or($where, value) {
        assertAllowed84(value, "list");
        if (value == null) return;
        const $or = $where.orPlan();
        return () => $or.andPlan();
      },
      organization($where, value) {
        assertAllowed83(value, "object");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: organizationIdentifier,
          alias: resource_organizationPgResource.name
        });
        registryConfig.pgRelations.userOrganization.organizationByMyOrganizationId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.userOrganization.organizationByMyOrganizationId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      organizationId(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec47;
        return condition;
      },
      rowId(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec45;
        return condition;
      },
      user($where, value) {
        assertAllowed83(value, "object");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: userIdentifier,
          alias: resource_userPgResource.name
        });
        registryConfig.pgRelations.userOrganization.userByMyUserId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.userOrganization.userByMyUserId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      userId(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec46;
        return condition;
      }
    }
  },
  UserOrganizationInput: {
    baked: createObjectAndApplyChildren,
    plans: {
      createdAt(obj, val, {
        field,
        schema
      }) {
        obj.set("created_at", bakedInputRuntime(schema, field.type, val));
      },
      organizationId(obj, val, {
        field,
        schema
      }) {
        obj.set("organization_id", bakedInputRuntime(schema, field.type, val));
      },
      role(obj, val, {
        field,
        schema
      }) {
        obj.set("role", bakedInputRuntime(schema, field.type, val));
      },
      rowId(obj, val, {
        field,
        schema
      }) {
        obj.set("id", bakedInputRuntime(schema, field.type, val));
      },
      updatedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("updated_at", bakedInputRuntime(schema, field.type, val));
      },
      userId(obj, val, {
        field,
        schema
      }) {
        obj.set("user_id", bakedInputRuntime(schema, field.type, val));
      }
    }
  },
  UserOrganizationPatch: {
    baked: createObjectAndApplyChildren,
    plans: {
      createdAt(obj, val, {
        field,
        schema
      }) {
        obj.set("created_at", bakedInputRuntime(schema, field.type, val));
      },
      organizationId(obj, val, {
        field,
        schema
      }) {
        obj.set("organization_id", bakedInputRuntime(schema, field.type, val));
      },
      role(obj, val, {
        field,
        schema
      }) {
        obj.set("role", bakedInputRuntime(schema, field.type, val));
      },
      rowId(obj, val, {
        field,
        schema
      }) {
        obj.set("id", bakedInputRuntime(schema, field.type, val));
      },
      updatedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("updated_at", bakedInputRuntime(schema, field.type, val));
      },
      userId(obj, val, {
        field,
        schema
      }) {
        obj.set("user_id", bakedInputRuntime(schema, field.type, val));
      }
    }
  },
  UserPatch: {
    baked: createObjectAndApplyChildren,
    plans: {
      avatarUrl(obj, val, {
        field,
        schema
      }) {
        obj.set("avatar_url", bakedInputRuntime(schema, field.type, val));
      },
      bio(obj, val, {
        field,
        schema
      }) {
        obj.set("bio", bakedInputRuntime(schema, field.type, val));
      },
      createdAt(obj, val, {
        field,
        schema
      }) {
        obj.set("created_at", bakedInputRuntime(schema, field.type, val));
      },
      deletedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("deleted_at", bakedInputRuntime(schema, field.type, val));
      },
      displayName(obj, val, {
        field,
        schema
      }) {
        obj.set("display_name", bakedInputRuntime(schema, field.type, val));
      },
      rowId(obj, val, {
        field,
        schema
      }) {
        obj.set("id", bakedInputRuntime(schema, field.type, val));
      },
      updatedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("updated_at", bakedInputRuntime(schema, field.type, val));
      },
      username(obj, val, {
        field,
        schema
      }) {
        obj.set("username", bakedInputRuntime(schema, field.type, val));
      },
      websiteUrl(obj, val, {
        field,
        schema
      }) {
        obj.set("website_url", bakedInputRuntime(schema, field.type, val));
      }
    }
  },
  UserToManyAuditLogFilter: {
    plans: {
      every($where, value) {
        assertAllowed51(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery.notPlan().andPlan();
      },
      none($where, value) {
        assertAllowed51(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      some($where, value) {
        assertAllowed51(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      }
    }
  },
  UserToManyBountyFilter: {
    plans: {
      every($where, value) {
        assertAllowed52(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery.notPlan().andPlan();
      },
      none($where, value) {
        assertAllowed52(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      some($where, value) {
        assertAllowed52(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      }
    }
  },
  UserToManyBountyFundingFilter: {
    plans: {
      every($where, value) {
        assertAllowed115(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery.notPlan().andPlan();
      },
      none($where, value) {
        assertAllowed115(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      some($where, value) {
        assertAllowed115(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      }
    }
  },
  UserToManyDonationFilter: {
    plans: {
      every($where, value) {
        assertAllowed116(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery.notPlan().andPlan();
      },
      none($where, value) {
        assertAllowed116(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      some($where, value) {
        assertAllowed116(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      }
    }
  },
  UserToManyGrantApplicationFilter: {
    plans: {
      every($where, value) {
        assertAllowed117(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery.notPlan().andPlan();
      },
      none($where, value) {
        assertAllowed117(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      some($where, value) {
        assertAllowed117(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      }
    }
  },
  UserToManyPayoutFilter: {
    plans: {
      every($where, value) {
        assertAllowed124(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery.notPlan().andPlan();
      },
      none($where, value) {
        assertAllowed124(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      some($where, value) {
        assertAllowed124(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      }
    }
  },
  UserToManyPostFilter: {
    plans: {
      every($where, value) {
        assertAllowed125(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery.notPlan().andPlan();
      },
      none($where, value) {
        assertAllowed125(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      some($where, value) {
        assertAllowed125(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      }
    }
  },
  UserToManySponsorshipFilter: {
    plans: {
      every($where, value) {
        assertAllowed122(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery.notPlan().andPlan();
      },
      none($where, value) {
        assertAllowed122(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      some($where, value) {
        assertAllowed122(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      }
    }
  },
  UserToManyTransactionFilter: {
    plans: {
      every($where, value) {
        assertAllowed123(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery.notPlan().andPlan();
      },
      none($where, value) {
        assertAllowed123(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      some($where, value) {
        assertAllowed123(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      }
    }
  },
  UserToManyUserIdentityFilter: {
    plans: {
      every($where, value) {
        assertAllowed118(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery.notPlan().andPlan();
      },
      none($where, value) {
        assertAllowed118(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      some($where, value) {
        assertAllowed118(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      }
    }
  },
  UserToManyUserOrganizationFilter: {
    plans: {
      every($where, value) {
        assertAllowed121(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery.notPlan().andPlan();
      },
      none($where, value) {
        assertAllowed121(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      some($where, value) {
        assertAllowed121(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      }
    }
  },
  UUIDFilter: {
    plans: {
      distinctFrom($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier ? resolveSqlIdentifier(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec2 ? resolveInputCodec2(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve4(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "distinctFrom"
          });
        $where.where(fragment);
      },
      equalTo($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier ? resolveSqlIdentifier(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec2 ? resolveInputCodec2(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve2(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "equalTo"
          });
        $where.where(fragment);
      },
      greaterThan($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier ? resolveSqlIdentifier(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec2 ? resolveInputCodec2(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve10(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "greaterThan"
          });
        $where.where(fragment);
      },
      greaterThanOrEqualTo($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier ? resolveSqlIdentifier(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec2 ? resolveInputCodec2(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve11(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "greaterThanOrEqualTo"
          });
        $where.where(fragment);
      },
      in($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier ? resolveSqlIdentifier(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec3 ? resolveInputCodec3(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve6(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "in"
          });
        $where.where(fragment);
      },
      isNull($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec ? resolveInputCodec(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = resolveSqlValue ? resolveSqlValue($where, value, inputCodec) : sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "isNull"
          });
        $where.where(fragment);
      },
      lessThan($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier ? resolveSqlIdentifier(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec2 ? resolveInputCodec2(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve8(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "lessThan"
          });
        $where.where(fragment);
      },
      lessThanOrEqualTo($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier ? resolveSqlIdentifier(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec2 ? resolveInputCodec2(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve9(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "lessThanOrEqualTo"
          });
        $where.where(fragment);
      },
      notDistinctFrom($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier ? resolveSqlIdentifier(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec2 ? resolveInputCodec2(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve5(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notDistinctFrom"
          });
        $where.where(fragment);
      },
      notEqualTo($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier ? resolveSqlIdentifier(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec2 ? resolveInputCodec2(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve3(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notEqualTo"
          });
        $where.where(fragment);
      },
      notIn($where, value) {
        if (!$where.extensions?.pgFilterAttribute) throw Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        if (value === void 0) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier ? resolveSqlIdentifier(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && value === null) return;
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const resolvedInput = value,
          inputCodec = resolveInputCodec3 ? resolveInputCodec3(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
          fragment = resolve7(sqlIdentifier, sqlValue, value, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notIn"
          });
        $where.where(fragment);
      }
    }
  },
  WebhookDeliveryCondition: {
    plans: {
      createdAt($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "created_at",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.timestamptz)}`;
          }
        });
      },
      isSuccessful($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "is_successful",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.boolean)}`;
          }
        });
      },
      nextRetryAt($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "next_retry_at",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.timestamptz)}`;
          }
        });
      },
      rowId($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "id",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
          }
        });
      },
      webhookEndpointId($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "webhook_endpoint_id",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
          }
        });
      }
    }
  },
  WebhookDeliveryFilter: {
    plans: {
      and($where, value) {
        assertAllowed108(value, "list");
        if (value == null) return;
        return $where.andPlan();
      },
      createdAt(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec74;
        return condition;
      },
      isSuccessful(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec72;
        return condition;
      },
      nextRetryAt(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec73;
        return condition;
      },
      not($where, value) {
        assertAllowed108(value, "object");
        if (value == null) return;
        return $where.notPlan().andPlan();
      },
      or($where, value) {
        assertAllowed108(value, "list");
        if (value == null) return;
        const $or = $where.orPlan();
        return () => $or.andPlan();
      },
      rowId(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec70;
        return condition;
      },
      webhookEndpoint($where, value) {
        assertAllowed107(value, "object");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: webhookEndpointIdentifier,
          alias: resource_webhook_endpointPgResource.name
        });
        registryConfig.pgRelations.webhookDelivery.webhookEndpointByMyWebhookEndpointId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.webhookDelivery.webhookEndpointByMyWebhookEndpointId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      webhookEndpointId(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec71;
        return condition;
      }
    }
  },
  WebhookDeliveryInput: {
    baked: createObjectAndApplyChildren,
    plans: {
      attemptCount(obj, val, {
        field,
        schema
      }) {
        obj.set("attempt_count", bakedInputRuntime(schema, field.type, val));
      },
      createdAt(obj, val, {
        field,
        schema
      }) {
        obj.set("created_at", bakedInputRuntime(schema, field.type, val));
      },
      deliveredAt(obj, val, {
        field,
        schema
      }) {
        obj.set("delivered_at", bakedInputRuntime(schema, field.type, val));
      },
      errorMessage(obj, val, {
        field,
        schema
      }) {
        obj.set("error_message", bakedInputRuntime(schema, field.type, val));
      },
      eventType(obj, val, {
        field,
        schema
      }) {
        obj.set("event_type", bakedInputRuntime(schema, field.type, val));
      },
      httpStatusCode(obj, val, {
        field,
        schema
      }) {
        obj.set("http_status_code", bakedInputRuntime(schema, field.type, val));
      },
      isSuccessful(obj, val, {
        field,
        schema
      }) {
        obj.set("is_successful", bakedInputRuntime(schema, field.type, val));
      },
      nextRetryAt(obj, val, {
        field,
        schema
      }) {
        obj.set("next_retry_at", bakedInputRuntime(schema, field.type, val));
      },
      payload(obj, val, {
        field,
        schema
      }) {
        obj.set("payload", bakedInputRuntime(schema, field.type, val));
      },
      responseBody(obj, val, {
        field,
        schema
      }) {
        obj.set("response_body", bakedInputRuntime(schema, field.type, val));
      },
      rowId(obj, val, {
        field,
        schema
      }) {
        obj.set("id", bakedInputRuntime(schema, field.type, val));
      },
      webhookEndpointId(obj, val, {
        field,
        schema
      }) {
        obj.set("webhook_endpoint_id", bakedInputRuntime(schema, field.type, val));
      }
    }
  },
  WebhookDeliveryPatch: {
    baked: createObjectAndApplyChildren,
    plans: {
      attemptCount(obj, val, {
        field,
        schema
      }) {
        obj.set("attempt_count", bakedInputRuntime(schema, field.type, val));
      },
      createdAt(obj, val, {
        field,
        schema
      }) {
        obj.set("created_at", bakedInputRuntime(schema, field.type, val));
      },
      deliveredAt(obj, val, {
        field,
        schema
      }) {
        obj.set("delivered_at", bakedInputRuntime(schema, field.type, val));
      },
      errorMessage(obj, val, {
        field,
        schema
      }) {
        obj.set("error_message", bakedInputRuntime(schema, field.type, val));
      },
      eventType(obj, val, {
        field,
        schema
      }) {
        obj.set("event_type", bakedInputRuntime(schema, field.type, val));
      },
      httpStatusCode(obj, val, {
        field,
        schema
      }) {
        obj.set("http_status_code", bakedInputRuntime(schema, field.type, val));
      },
      isSuccessful(obj, val, {
        field,
        schema
      }) {
        obj.set("is_successful", bakedInputRuntime(schema, field.type, val));
      },
      nextRetryAt(obj, val, {
        field,
        schema
      }) {
        obj.set("next_retry_at", bakedInputRuntime(schema, field.type, val));
      },
      payload(obj, val, {
        field,
        schema
      }) {
        obj.set("payload", bakedInputRuntime(schema, field.type, val));
      },
      responseBody(obj, val, {
        field,
        schema
      }) {
        obj.set("response_body", bakedInputRuntime(schema, field.type, val));
      },
      rowId(obj, val, {
        field,
        schema
      }) {
        obj.set("id", bakedInputRuntime(schema, field.type, val));
      },
      webhookEndpointId(obj, val, {
        field,
        schema
      }) {
        obj.set("webhook_endpoint_id", bakedInputRuntime(schema, field.type, val));
      }
    }
  },
  WebhookEndpointCondition: {
    plans: {
      isActive($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "is_active",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.boolean)}`;
          }
        });
      },
      organizationId($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "organization_id",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
          }
        });
      },
      rowId($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "id",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
          }
        });
      }
    }
  },
  WebhookEndpointFilter: {
    plans: {
      and($where, value) {
        assertAllowed105(value, "list");
        if (value == null) return;
        return $where.andPlan();
      },
      isActive(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec69;
        return condition;
      },
      not($where, value) {
        assertAllowed105(value, "object");
        if (value == null) return;
        return $where.notPlan().andPlan();
      },
      or($where, value) {
        assertAllowed105(value, "list");
        if (value == null) return;
        const $or = $where.orPlan();
        return () => $or.andPlan();
      },
      organization($where, value) {
        assertAllowed104(value, "object");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: organizationIdentifier,
          alias: resource_organizationPgResource.name
        });
        registryConfig.pgRelations.webhookEndpoint.organizationByMyOrganizationId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.webhookEndpoint.organizationByMyOrganizationId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      organizationId(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec68;
        return condition;
      },
      rowId(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec67;
        return condition;
      },
      webhookDeliveries($where, value) {
        assertAllowed103(value, "object");
        const $rel = $where.andPlan();
        $rel.extensions.pgFilterRelation = {
          tableExpression: webhookDeliveryIdentifier,
          alias: resource_webhook_deliveryPgResource.name,
          localAttributes: registryConfig.pgRelations.webhookEndpoint.webhookDeliveriesByTheirWebhookEndpointId.localAttributes,
          remoteAttributes: registryConfig.pgRelations.webhookEndpoint.webhookDeliveriesByTheirWebhookEndpointId.remoteAttributes
        };
        return $rel;
      },
      webhookDeliveriesExist($where, value) {
        assertAllowed103(value, "scalar");
        if (value == null) return;
        const $subQuery = $where.existsPlan({
          tableExpression: webhookDeliveryIdentifier,
          alias: resource_webhook_deliveryPgResource.name,
          equals: value
        });
        registryConfig.pgRelations.webhookEndpoint.webhookDeliveriesByTheirWebhookEndpointId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.webhookEndpoint.webhookDeliveriesByTheirWebhookEndpointId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      }
    }
  },
  WebhookEndpointInput: {
    baked: createObjectAndApplyChildren,
    plans: {
      createdAt(obj, val, {
        field,
        schema
      }) {
        obj.set("created_at", bakedInputRuntime(schema, field.type, val));
      },
      deletedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("deleted_at", bakedInputRuntime(schema, field.type, val));
      },
      description(obj, val, {
        field,
        schema
      }) {
        obj.set("description", bakedInputRuntime(schema, field.type, val));
      },
      events(obj, val, {
        field,
        schema
      }) {
        obj.set("events", bakedInputRuntime(schema, field.type, val));
      },
      isActive(obj, val, {
        field,
        schema
      }) {
        obj.set("is_active", bakedInputRuntime(schema, field.type, val));
      },
      organizationId(obj, val, {
        field,
        schema
      }) {
        obj.set("organization_id", bakedInputRuntime(schema, field.type, val));
      },
      rowId(obj, val, {
        field,
        schema
      }) {
        obj.set("id", bakedInputRuntime(schema, field.type, val));
      },
      secret(obj, val, {
        field,
        schema
      }) {
        obj.set("secret", bakedInputRuntime(schema, field.type, val));
      },
      updatedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("updated_at", bakedInputRuntime(schema, field.type, val));
      },
      url(obj, val, {
        field,
        schema
      }) {
        obj.set("url", bakedInputRuntime(schema, field.type, val));
      }
    }
  },
  WebhookEndpointPatch: {
    baked: createObjectAndApplyChildren,
    plans: {
      createdAt(obj, val, {
        field,
        schema
      }) {
        obj.set("created_at", bakedInputRuntime(schema, field.type, val));
      },
      deletedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("deleted_at", bakedInputRuntime(schema, field.type, val));
      },
      description(obj, val, {
        field,
        schema
      }) {
        obj.set("description", bakedInputRuntime(schema, field.type, val));
      },
      events(obj, val, {
        field,
        schema
      }) {
        obj.set("events", bakedInputRuntime(schema, field.type, val));
      },
      isActive(obj, val, {
        field,
        schema
      }) {
        obj.set("is_active", bakedInputRuntime(schema, field.type, val));
      },
      organizationId(obj, val, {
        field,
        schema
      }) {
        obj.set("organization_id", bakedInputRuntime(schema, field.type, val));
      },
      rowId(obj, val, {
        field,
        schema
      }) {
        obj.set("id", bakedInputRuntime(schema, field.type, val));
      },
      secret(obj, val, {
        field,
        schema
      }) {
        obj.set("secret", bakedInputRuntime(schema, field.type, val));
      },
      updatedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("updated_at", bakedInputRuntime(schema, field.type, val));
      },
      url(obj, val, {
        field,
        schema
      }) {
        obj.set("url", bakedInputRuntime(schema, field.type, val));
      }
    }
  },
  WebhookEndpointToManyWebhookDeliveryFilter: {
    plans: {
      every($where, value) {
        assertAllowed106(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery.notPlan().andPlan();
      },
      none($where, value) {
        assertAllowed106(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      },
      some($where, value) {
        assertAllowed106(value, "object");
        if (value == null) return;
        if (!$where.extensions.pgFilterRelation) throw Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        return $subQuery;
      }
    }
  },
  WorkspaceCondition: {
    plans: {
      organizationId($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "organization_id",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.text)}`;
          }
        });
      },
      rowId($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "id",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
          }
        });
      },
      slug($condition, val) {
        $condition.where({
          type: "attribute",
          attribute: "slug",
          callback(expression) {
            return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.text)}`;
          }
        });
      }
    }
  },
  WorkspaceFilter: {
    plans: {
      and($where, value) {
        assertAllowed134(value, "list");
        if (value == null) return;
        return $where.andPlan();
      },
      not($where, value) {
        assertAllowed134(value, "object");
        if (value == null) return;
        return $where.notPlan().andPlan();
      },
      or($where, value) {
        assertAllowed134(value, "list");
        if (value == null) return;
        const $or = $where.orPlan();
        return () => $or.andPlan();
      },
      organizationId(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec89;
        return condition;
      },
      rowId(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec88;
        return condition;
      },
      slug(queryBuilder, value) {
        if (value === void 0) return;
        if (!false && isEmpty(value)) throw Object.assign(Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && value === null) throw Object.assign(Error("Null literals are forbidden in filter argument input."), {});
        const condition = new PgCondition(queryBuilder);
        condition.extensions.pgFilterAttribute = colSpec90;
        return condition;
      }
    }
  },
  WorkspaceInput: {
    baked: createObjectAndApplyChildren,
    plans: {
      createdAt(obj, val, {
        field,
        schema
      }) {
        obj.set("created_at", bakedInputRuntime(schema, field.type, val));
      },
      deletedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("deleted_at", bakedInputRuntime(schema, field.type, val));
      },
      deletionReason(obj, val, {
        field,
        schema
      }) {
        obj.set("deletion_reason", bakedInputRuntime(schema, field.type, val));
      },
      name(obj, val, {
        field,
        schema
      }) {
        obj.set("name", bakedInputRuntime(schema, field.type, val));
      },
      organizationId(obj, val, {
        field,
        schema
      }) {
        obj.set("organization_id", bakedInputRuntime(schema, field.type, val));
      },
      rowId(obj, val, {
        field,
        schema
      }) {
        obj.set("id", bakedInputRuntime(schema, field.type, val));
      },
      slug(obj, val, {
        field,
        schema
      }) {
        obj.set("slug", bakedInputRuntime(schema, field.type, val));
      },
      updatedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("updated_at", bakedInputRuntime(schema, field.type, val));
      }
    }
  },
  WorkspacePatch: {
    baked: createObjectAndApplyChildren,
    plans: {
      createdAt(obj, val, {
        field,
        schema
      }) {
        obj.set("created_at", bakedInputRuntime(schema, field.type, val));
      },
      deletedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("deleted_at", bakedInputRuntime(schema, field.type, val));
      },
      deletionReason(obj, val, {
        field,
        schema
      }) {
        obj.set("deletion_reason", bakedInputRuntime(schema, field.type, val));
      },
      name(obj, val, {
        field,
        schema
      }) {
        obj.set("name", bakedInputRuntime(schema, field.type, val));
      },
      organizationId(obj, val, {
        field,
        schema
      }) {
        obj.set("organization_id", bakedInputRuntime(schema, field.type, val));
      },
      rowId(obj, val, {
        field,
        schema
      }) {
        obj.set("id", bakedInputRuntime(schema, field.type, val));
      },
      slug(obj, val, {
        field,
        schema
      }) {
        obj.set("slug", bakedInputRuntime(schema, field.type, val));
      },
      updatedAt(obj, val, {
        field,
        schema
      }) {
        obj.set("updated_at", bakedInputRuntime(schema, field.type, val));
      }
    }
  }
};
export const scalars = {
  BigFloat: {
    serialize: UUIDSerialize,
    parseValue: UUIDSerialize,
    parseLiteral(ast) {
      if (ast.kind !== Kind.STRING) throw new GraphQLError(`${"BigFloat" ?? "This scalar"} can only parse string values (kind='${ast.kind}')`);
      return ast.value;
    }
  },
  Cursor: {
    serialize: UUIDSerialize,
    parseValue: UUIDSerialize,
    parseLiteral(ast) {
      if (ast.kind !== Kind.STRING) throw new GraphQLError(`${"Cursor" ?? "This scalar"} can only parse string values (kind='${ast.kind}')`);
      return ast.value;
    }
  },
  Datetime: {
    serialize: UUIDSerialize,
    parseValue: UUIDSerialize,
    parseLiteral(ast) {
      if (ast.kind !== Kind.STRING) throw new GraphQLError(`${"Datetime" ?? "This scalar"} can only parse string values (kind='${ast.kind}')`);
      return ast.value;
    }
  },
  UUID: {
    serialize: UUIDSerialize,
    parseValue(value) {
      return coerce("" + value);
    },
    parseLiteral(ast) {
      if (ast.kind !== Kind.STRING) throw new GraphQLError(`${"UUID" ?? "This scalar"} can only parse string values (kind = '${ast.kind}')`);
      return coerce(ast.value);
    }
  }
};
export const enums = {
  AuditLogOrderBy: {
    values: {
      ACTOR_USER_ID_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "actor_user_id",
          direction: "ASC"
        });
      },
      ACTOR_USER_ID_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "actor_user_id",
          direction: "DESC"
        });
      },
      CREATED_AT_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "created_at",
          direction: "ASC"
        });
      },
      CREATED_AT_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "created_at",
          direction: "DESC"
        });
      },
      ORGANIZATION_ID_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "organization_id",
          direction: "ASC"
        });
      },
      ORGANIZATION_ID_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "organization_id",
          direction: "DESC"
        });
      },
      PRIMARY_KEY_ASC(queryBuilder) {
        audit_logUniques[0].attributes.forEach(attributeName => {
          queryBuilder.orderBy({
            attribute: attributeName,
            direction: "ASC"
          });
        });
        queryBuilder.setOrderIsUnique();
      },
      PRIMARY_KEY_DESC(queryBuilder) {
        audit_logUniques[0].attributes.forEach(attributeName => {
          queryBuilder.orderBy({
            attribute: attributeName,
            direction: "DESC"
          });
        });
        queryBuilder.setOrderIsUnique();
      },
      ROW_ID_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "id",
          direction: "ASC"
        });
        queryBuilder.setOrderIsUnique();
      },
      ROW_ID_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "id",
          direction: "DESC"
        });
        queryBuilder.setOrderIsUnique();
      },
      TARGET_ENTITY_ID_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "target_entity_id",
          direction: "ASC"
        });
      },
      TARGET_ENTITY_ID_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "target_entity_id",
          direction: "DESC"
        });
      },
      TARGET_ENTITY_TYPE_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "target_entity_type",
          direction: "ASC"
        });
      },
      TARGET_ENTITY_TYPE_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "target_entity_type",
          direction: "DESC"
        });
      }
    }
  },
  BountyFundingOrderBy: {
    values: {
      BOUNTY_ID_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "bounty_id",
          direction: "ASC"
        });
      },
      BOUNTY_ID_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "bounty_id",
          direction: "DESC"
        });
      },
      FUNDER_ID_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "funder_id",
          direction: "ASC"
        });
      },
      FUNDER_ID_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "funder_id",
          direction: "DESC"
        });
      },
      PRIMARY_KEY_ASC(queryBuilder) {
        bounty_fundingUniques[0].attributes.forEach(attributeName => {
          queryBuilder.orderBy({
            attribute: attributeName,
            direction: "ASC"
          });
        });
        queryBuilder.setOrderIsUnique();
      },
      PRIMARY_KEY_DESC(queryBuilder) {
        bounty_fundingUniques[0].attributes.forEach(attributeName => {
          queryBuilder.orderBy({
            attribute: attributeName,
            direction: "DESC"
          });
        });
        queryBuilder.setOrderIsUnique();
      },
      ROW_ID_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "id",
          direction: "ASC"
        });
        queryBuilder.setOrderIsUnique();
      },
      ROW_ID_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "id",
          direction: "DESC"
        });
        queryBuilder.setOrderIsUnique();
      },
      TRANSACTION_ID_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "transaction_id",
          direction: "ASC"
        });
      },
      TRANSACTION_ID_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "transaction_id",
          direction: "DESC"
        });
      }
    }
  },
  BountyOrderBy: {
    values: {
      CLAIMANT_ID_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "claimant_id",
          direction: "ASC"
        });
      },
      CLAIMANT_ID_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "claimant_id",
          direction: "DESC"
        });
      },
      EXTERNAL_URL_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "external_url",
          direction: "ASC"
        });
      },
      EXTERNAL_URL_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "external_url",
          direction: "DESC"
        });
      },
      ORGANIZATION_ID_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "organization_id",
          direction: "ASC"
        });
      },
      ORGANIZATION_ID_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "organization_id",
          direction: "DESC"
        });
      },
      PRIMARY_KEY_ASC(queryBuilder) {
        bountyUniques[0].attributes.forEach(attributeName => {
          queryBuilder.orderBy({
            attribute: attributeName,
            direction: "ASC"
          });
        });
        queryBuilder.setOrderIsUnique();
      },
      PRIMARY_KEY_DESC(queryBuilder) {
        bountyUniques[0].attributes.forEach(attributeName => {
          queryBuilder.orderBy({
            attribute: attributeName,
            direction: "DESC"
          });
        });
        queryBuilder.setOrderIsUnique();
      },
      ROW_ID_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "id",
          direction: "ASC"
        });
        queryBuilder.setOrderIsUnique();
      },
      ROW_ID_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "id",
          direction: "DESC"
        });
        queryBuilder.setOrderIsUnique();
      }
    }
  },
  DonationOrderBy: {
    values: {
      DONOR_ID_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "donor_id",
          direction: "ASC"
        });
      },
      DONOR_ID_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "donor_id",
          direction: "DESC"
        });
      },
      ORGANIZATION_ID_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "organization_id",
          direction: "ASC"
        });
      },
      ORGANIZATION_ID_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "organization_id",
          direction: "DESC"
        });
      },
      PRIMARY_KEY_ASC(queryBuilder) {
        donationUniques[0].attributes.forEach(attributeName => {
          queryBuilder.orderBy({
            attribute: attributeName,
            direction: "ASC"
          });
        });
        queryBuilder.setOrderIsUnique();
      },
      PRIMARY_KEY_DESC(queryBuilder) {
        donationUniques[0].attributes.forEach(attributeName => {
          queryBuilder.orderBy({
            attribute: attributeName,
            direction: "DESC"
          });
        });
        queryBuilder.setOrderIsUnique();
      },
      ROW_ID_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "id",
          direction: "ASC"
        });
        queryBuilder.setOrderIsUnique();
      },
      ROW_ID_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "id",
          direction: "DESC"
        });
        queryBuilder.setOrderIsUnique();
      },
      TRANSACTION_ID_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "transaction_id",
          direction: "ASC"
        });
      },
      TRANSACTION_ID_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "transaction_id",
          direction: "DESC"
        });
      }
    }
  },
  GoalOrderBy: {
    values: {
      IS_ACTIVE_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "is_active",
          direction: "ASC"
        });
      },
      IS_ACTIVE_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "is_active",
          direction: "DESC"
        });
      },
      ORGANIZATION_ID_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "organization_id",
          direction: "ASC"
        });
      },
      ORGANIZATION_ID_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "organization_id",
          direction: "DESC"
        });
      },
      PRIMARY_KEY_ASC(queryBuilder) {
        goalUniques[0].attributes.forEach(attributeName => {
          queryBuilder.orderBy({
            attribute: attributeName,
            direction: "ASC"
          });
        });
        queryBuilder.setOrderIsUnique();
      },
      PRIMARY_KEY_DESC(queryBuilder) {
        goalUniques[0].attributes.forEach(attributeName => {
          queryBuilder.orderBy({
            attribute: attributeName,
            direction: "DESC"
          });
        });
        queryBuilder.setOrderIsUnique();
      },
      ROW_ID_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "id",
          direction: "ASC"
        });
        queryBuilder.setOrderIsUnique();
      },
      ROW_ID_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "id",
          direction: "DESC"
        });
        queryBuilder.setOrderIsUnique();
      }
    }
  },
  GrantApplicationOrderBy: {
    values: {
      APPLICANT_ID_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "applicant_id",
          direction: "ASC"
        });
      },
      APPLICANT_ID_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "applicant_id",
          direction: "DESC"
        });
      },
      GRANT_PROGRAM_ID_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "grant_program_id",
          direction: "ASC"
        });
      },
      GRANT_PROGRAM_ID_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "grant_program_id",
          direction: "DESC"
        });
      },
      PRIMARY_KEY_ASC(queryBuilder) {
        grant_applicationUniques[0].attributes.forEach(attributeName => {
          queryBuilder.orderBy({
            attribute: attributeName,
            direction: "ASC"
          });
        });
        queryBuilder.setOrderIsUnique();
      },
      PRIMARY_KEY_DESC(queryBuilder) {
        grant_applicationUniques[0].attributes.forEach(attributeName => {
          queryBuilder.orderBy({
            attribute: attributeName,
            direction: "DESC"
          });
        });
        queryBuilder.setOrderIsUnique();
      },
      ROW_ID_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "id",
          direction: "ASC"
        });
        queryBuilder.setOrderIsUnique();
      },
      ROW_ID_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "id",
          direction: "DESC"
        });
        queryBuilder.setOrderIsUnique();
      }
    }
  },
  GrantMilestoneOrderBy: {
    values: {
      GRANT_APPLICATION_ID_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "grant_application_id",
          direction: "ASC"
        });
      },
      GRANT_APPLICATION_ID_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "grant_application_id",
          direction: "DESC"
        });
      },
      PRIMARY_KEY_ASC(queryBuilder) {
        grant_milestoneUniques[0].attributes.forEach(attributeName => {
          queryBuilder.orderBy({
            attribute: attributeName,
            direction: "ASC"
          });
        });
        queryBuilder.setOrderIsUnique();
      },
      PRIMARY_KEY_DESC(queryBuilder) {
        grant_milestoneUniques[0].attributes.forEach(attributeName => {
          queryBuilder.orderBy({
            attribute: attributeName,
            direction: "DESC"
          });
        });
        queryBuilder.setOrderIsUnique();
      },
      ROW_ID_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "id",
          direction: "ASC"
        });
        queryBuilder.setOrderIsUnique();
      },
      ROW_ID_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "id",
          direction: "DESC"
        });
        queryBuilder.setOrderIsUnique();
      }
    }
  },
  GrantProgramOrderBy: {
    values: {
      IS_ACTIVE_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "is_active",
          direction: "ASC"
        });
      },
      IS_ACTIVE_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "is_active",
          direction: "DESC"
        });
      },
      ORGANIZATION_ID_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "organization_id",
          direction: "ASC"
        });
      },
      ORGANIZATION_ID_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "organization_id",
          direction: "DESC"
        });
      },
      PRIMARY_KEY_ASC(queryBuilder) {
        grant_programUniques[0].attributes.forEach(attributeName => {
          queryBuilder.orderBy({
            attribute: attributeName,
            direction: "ASC"
          });
        });
        queryBuilder.setOrderIsUnique();
      },
      PRIMARY_KEY_DESC(queryBuilder) {
        grant_programUniques[0].attributes.forEach(attributeName => {
          queryBuilder.orderBy({
            attribute: attributeName,
            direction: "DESC"
          });
        });
        queryBuilder.setOrderIsUnique();
      },
      ROW_ID_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "id",
          direction: "ASC"
        });
        queryBuilder.setOrderIsUnique();
      },
      ROW_ID_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "id",
          direction: "DESC"
        });
        queryBuilder.setOrderIsUnique();
      },
      SLUG_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "slug",
          direction: "ASC"
        });
      },
      SLUG_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "slug",
          direction: "DESC"
        });
      }
    }
  },
  OrganizationOrderBy: {
    values: {
      PRIMARY_KEY_ASC(queryBuilder) {
        organizationUniques[0].attributes.forEach(attributeName => {
          queryBuilder.orderBy({
            attribute: attributeName,
            direction: "ASC"
          });
        });
        queryBuilder.setOrderIsUnique();
      },
      PRIMARY_KEY_DESC(queryBuilder) {
        organizationUniques[0].attributes.forEach(attributeName => {
          queryBuilder.orderBy({
            attribute: attributeName,
            direction: "DESC"
          });
        });
        queryBuilder.setOrderIsUnique();
      },
      ROW_ID_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "id",
          direction: "ASC"
        });
        queryBuilder.setOrderIsUnique();
      },
      ROW_ID_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "id",
          direction: "DESC"
        });
        queryBuilder.setOrderIsUnique();
      },
      SLUG_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "slug",
          direction: "ASC"
        });
        queryBuilder.setOrderIsUnique();
      },
      SLUG_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "slug",
          direction: "DESC"
        });
        queryBuilder.setOrderIsUnique();
      }
    }
  },
  PaymentProcessorConnectionOrderBy: {
    values: {
      EXTERNAL_ACCOUNT_ID_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "external_account_id",
          direction: "ASC"
        });
      },
      EXTERNAL_ACCOUNT_ID_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "external_account_id",
          direction: "DESC"
        });
      },
      IS_ACTIVE_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "is_active",
          direction: "ASC"
        });
      },
      IS_ACTIVE_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "is_active",
          direction: "DESC"
        });
      },
      ORGANIZATION_ID_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "organization_id",
          direction: "ASC"
        });
      },
      ORGANIZATION_ID_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "organization_id",
          direction: "DESC"
        });
      },
      PRIMARY_KEY_ASC(queryBuilder) {
        payment_processor_connectionUniques[0].attributes.forEach(attributeName => {
          queryBuilder.orderBy({
            attribute: attributeName,
            direction: "ASC"
          });
        });
        queryBuilder.setOrderIsUnique();
      },
      PRIMARY_KEY_DESC(queryBuilder) {
        payment_processor_connectionUniques[0].attributes.forEach(attributeName => {
          queryBuilder.orderBy({
            attribute: attributeName,
            direction: "DESC"
          });
        });
        queryBuilder.setOrderIsUnique();
      },
      ROW_ID_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "id",
          direction: "ASC"
        });
        queryBuilder.setOrderIsUnique();
      },
      ROW_ID_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "id",
          direction: "DESC"
        });
        queryBuilder.setOrderIsUnique();
      }
    }
  },
  PayoutOrderBy: {
    values: {
      CREATED_AT_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "created_at",
          direction: "ASC"
        });
      },
      CREATED_AT_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "created_at",
          direction: "DESC"
        });
      },
      FROM_ORGANIZATION_ID_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "from_organization_id",
          direction: "ASC"
        });
      },
      FROM_ORGANIZATION_ID_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "from_organization_id",
          direction: "DESC"
        });
      },
      PRIMARY_KEY_ASC(queryBuilder) {
        payoutUniques[0].attributes.forEach(attributeName => {
          queryBuilder.orderBy({
            attribute: attributeName,
            direction: "ASC"
          });
        });
        queryBuilder.setOrderIsUnique();
      },
      PRIMARY_KEY_DESC(queryBuilder) {
        payoutUniques[0].attributes.forEach(attributeName => {
          queryBuilder.orderBy({
            attribute: attributeName,
            direction: "DESC"
          });
        });
        queryBuilder.setOrderIsUnique();
      },
      RECIPIENT_USER_ID_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "recipient_user_id",
          direction: "ASC"
        });
      },
      RECIPIENT_USER_ID_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "recipient_user_id",
          direction: "DESC"
        });
      },
      ROW_ID_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "id",
          direction: "ASC"
        });
        queryBuilder.setOrderIsUnique();
      },
      ROW_ID_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "id",
          direction: "DESC"
        });
        queryBuilder.setOrderIsUnique();
      }
    }
  },
  PostOrderBy: {
    values: {
      AUTHOR_ID_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "author_id",
          direction: "ASC"
        });
      },
      AUTHOR_ID_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "author_id",
          direction: "DESC"
        });
      },
      IS_PUBLISHED_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "is_published",
          direction: "ASC"
        });
      },
      IS_PUBLISHED_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "is_published",
          direction: "DESC"
        });
      },
      ORGANIZATION_ID_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "organization_id",
          direction: "ASC"
        });
      },
      ORGANIZATION_ID_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "organization_id",
          direction: "DESC"
        });
      },
      PRIMARY_KEY_ASC(queryBuilder) {
        postUniques[0].attributes.forEach(attributeName => {
          queryBuilder.orderBy({
            attribute: attributeName,
            direction: "ASC"
          });
        });
        queryBuilder.setOrderIsUnique();
      },
      PRIMARY_KEY_DESC(queryBuilder) {
        postUniques[0].attributes.forEach(attributeName => {
          queryBuilder.orderBy({
            attribute: attributeName,
            direction: "DESC"
          });
        });
        queryBuilder.setOrderIsUnique();
      },
      PUBLISHED_AT_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "published_at",
          direction: "ASC"
        });
      },
      PUBLISHED_AT_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "published_at",
          direction: "DESC"
        });
      },
      ROW_ID_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "id",
          direction: "ASC"
        });
        queryBuilder.setOrderIsUnique();
      },
      ROW_ID_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "id",
          direction: "DESC"
        });
        queryBuilder.setOrderIsUnique();
      }
    }
  },
  SponsorshipOrderBy: {
    values: {
      ORGANIZATION_ID_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "organization_id",
          direction: "ASC"
        });
      },
      ORGANIZATION_ID_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "organization_id",
          direction: "DESC"
        });
      },
      PRIMARY_KEY_ASC(queryBuilder) {
        sponsorshipUniques[0].attributes.forEach(attributeName => {
          queryBuilder.orderBy({
            attribute: attributeName,
            direction: "ASC"
          });
        });
        queryBuilder.setOrderIsUnique();
      },
      PRIMARY_KEY_DESC(queryBuilder) {
        sponsorshipUniques[0].attributes.forEach(attributeName => {
          queryBuilder.orderBy({
            attribute: attributeName,
            direction: "DESC"
          });
        });
        queryBuilder.setOrderIsUnique();
      },
      ROW_ID_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "id",
          direction: "ASC"
        });
        queryBuilder.setOrderIsUnique();
      },
      ROW_ID_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "id",
          direction: "DESC"
        });
        queryBuilder.setOrderIsUnique();
      },
      SPONSOR_ID_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "sponsor_id",
          direction: "ASC"
        });
      },
      SPONSOR_ID_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "sponsor_id",
          direction: "DESC"
        });
      },
      TIER_ID_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "tier_id",
          direction: "ASC"
        });
      },
      TIER_ID_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "tier_id",
          direction: "DESC"
        });
      }
    }
  },
  SponsorshipTierOrderBy: {
    values: {
      IS_ACTIVE_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "is_active",
          direction: "ASC"
        });
      },
      IS_ACTIVE_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "is_active",
          direction: "DESC"
        });
      },
      ORGANIZATION_ID_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "organization_id",
          direction: "ASC"
        });
      },
      ORGANIZATION_ID_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "organization_id",
          direction: "DESC"
        });
      },
      PRIMARY_KEY_ASC(queryBuilder) {
        sponsorship_tierUniques[0].attributes.forEach(attributeName => {
          queryBuilder.orderBy({
            attribute: attributeName,
            direction: "ASC"
          });
        });
        queryBuilder.setOrderIsUnique();
      },
      PRIMARY_KEY_DESC(queryBuilder) {
        sponsorship_tierUniques[0].attributes.forEach(attributeName => {
          queryBuilder.orderBy({
            attribute: attributeName,
            direction: "DESC"
          });
        });
        queryBuilder.setOrderIsUnique();
      },
      ROW_ID_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "id",
          direction: "ASC"
        });
        queryBuilder.setOrderIsUnique();
      },
      ROW_ID_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "id",
          direction: "DESC"
        });
        queryBuilder.setOrderIsUnique();
      }
    }
  },
  TransactionOrderBy: {
    values: {
      CREATED_AT_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "created_at",
          direction: "ASC"
        });
      },
      CREATED_AT_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "created_at",
          direction: "DESC"
        });
      },
      EXTERNAL_TRANSACTION_ID_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "external_transaction_id",
          direction: "ASC"
        });
      },
      EXTERNAL_TRANSACTION_ID_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "external_transaction_id",
          direction: "DESC"
        });
      },
      FROM_USER_ID_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "from_user_id",
          direction: "ASC"
        });
      },
      FROM_USER_ID_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "from_user_id",
          direction: "DESC"
        });
      },
      PRIMARY_KEY_ASC(queryBuilder) {
        transactionUniques[0].attributes.forEach(attributeName => {
          queryBuilder.orderBy({
            attribute: attributeName,
            direction: "ASC"
          });
        });
        queryBuilder.setOrderIsUnique();
      },
      PRIMARY_KEY_DESC(queryBuilder) {
        transactionUniques[0].attributes.forEach(attributeName => {
          queryBuilder.orderBy({
            attribute: attributeName,
            direction: "DESC"
          });
        });
        queryBuilder.setOrderIsUnique();
      },
      PROCESSOR_CONNECTION_ID_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "processor_connection_id",
          direction: "ASC"
        });
      },
      PROCESSOR_CONNECTION_ID_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "processor_connection_id",
          direction: "DESC"
        });
      },
      ROW_ID_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "id",
          direction: "ASC"
        });
        queryBuilder.setOrderIsUnique();
      },
      ROW_ID_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "id",
          direction: "DESC"
        });
        queryBuilder.setOrderIsUnique();
      },
      TO_ORGANIZATION_ID_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "to_organization_id",
          direction: "ASC"
        });
      },
      TO_ORGANIZATION_ID_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "to_organization_id",
          direction: "DESC"
        });
      },
      TO_USER_ID_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "to_user_id",
          direction: "ASC"
        });
      },
      TO_USER_ID_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "to_user_id",
          direction: "DESC"
        });
      }
    }
  },
  UserIdentityOrderBy: {
    values: {
      PRIMARY_KEY_ASC(queryBuilder) {
        user_identityUniques[0].attributes.forEach(attributeName => {
          queryBuilder.orderBy({
            attribute: attributeName,
            direction: "ASC"
          });
        });
        queryBuilder.setOrderIsUnique();
      },
      PRIMARY_KEY_DESC(queryBuilder) {
        user_identityUniques[0].attributes.forEach(attributeName => {
          queryBuilder.orderBy({
            attribute: attributeName,
            direction: "DESC"
          });
        });
        queryBuilder.setOrderIsUnique();
      },
      PROVIDER_USER_ID_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "provider_user_id",
          direction: "ASC"
        });
      },
      PROVIDER_USER_ID_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "provider_user_id",
          direction: "DESC"
        });
      },
      ROW_ID_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "id",
          direction: "ASC"
        });
        queryBuilder.setOrderIsUnique();
      },
      ROW_ID_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "id",
          direction: "DESC"
        });
        queryBuilder.setOrderIsUnique();
      },
      USER_ID_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "user_id",
          direction: "ASC"
        });
      },
      USER_ID_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "user_id",
          direction: "DESC"
        });
      }
    }
  },
  UserOrderBy: {
    values: {
      PRIMARY_KEY_ASC(queryBuilder) {
        userUniques[0].attributes.forEach(attributeName => {
          queryBuilder.orderBy({
            attribute: attributeName,
            direction: "ASC"
          });
        });
        queryBuilder.setOrderIsUnique();
      },
      PRIMARY_KEY_DESC(queryBuilder) {
        userUniques[0].attributes.forEach(attributeName => {
          queryBuilder.orderBy({
            attribute: attributeName,
            direction: "DESC"
          });
        });
        queryBuilder.setOrderIsUnique();
      },
      ROW_ID_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "id",
          direction: "ASC"
        });
        queryBuilder.setOrderIsUnique();
      },
      ROW_ID_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "id",
          direction: "DESC"
        });
        queryBuilder.setOrderIsUnique();
      },
      USERNAME_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "username",
          direction: "ASC"
        });
        queryBuilder.setOrderIsUnique();
      },
      USERNAME_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "username",
          direction: "DESC"
        });
        queryBuilder.setOrderIsUnique();
      }
    }
  },
  UserOrganizationOrderBy: {
    values: {
      ORGANIZATION_ID_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "organization_id",
          direction: "ASC"
        });
      },
      ORGANIZATION_ID_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "organization_id",
          direction: "DESC"
        });
      },
      PRIMARY_KEY_ASC(queryBuilder) {
        user_organizationUniques[0].attributes.forEach(attributeName => {
          queryBuilder.orderBy({
            attribute: attributeName,
            direction: "ASC"
          });
        });
        queryBuilder.setOrderIsUnique();
      },
      PRIMARY_KEY_DESC(queryBuilder) {
        user_organizationUniques[0].attributes.forEach(attributeName => {
          queryBuilder.orderBy({
            attribute: attributeName,
            direction: "DESC"
          });
        });
        queryBuilder.setOrderIsUnique();
      },
      ROW_ID_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "id",
          direction: "ASC"
        });
        queryBuilder.setOrderIsUnique();
      },
      ROW_ID_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "id",
          direction: "DESC"
        });
        queryBuilder.setOrderIsUnique();
      },
      USER_ID_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "user_id",
          direction: "ASC"
        });
      },
      USER_ID_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "user_id",
          direction: "DESC"
        });
      }
    }
  },
  WebhookDeliveryOrderBy: {
    values: {
      CREATED_AT_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "created_at",
          direction: "ASC"
        });
      },
      CREATED_AT_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "created_at",
          direction: "DESC"
        });
      },
      IS_SUCCESSFUL_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "is_successful",
          direction: "ASC"
        });
      },
      IS_SUCCESSFUL_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "is_successful",
          direction: "DESC"
        });
      },
      NEXT_RETRY_AT_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "next_retry_at",
          direction: "ASC"
        });
      },
      NEXT_RETRY_AT_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "next_retry_at",
          direction: "DESC"
        });
      },
      PRIMARY_KEY_ASC(queryBuilder) {
        webhook_deliveryUniques[0].attributes.forEach(attributeName => {
          queryBuilder.orderBy({
            attribute: attributeName,
            direction: "ASC"
          });
        });
        queryBuilder.setOrderIsUnique();
      },
      PRIMARY_KEY_DESC(queryBuilder) {
        webhook_deliveryUniques[0].attributes.forEach(attributeName => {
          queryBuilder.orderBy({
            attribute: attributeName,
            direction: "DESC"
          });
        });
        queryBuilder.setOrderIsUnique();
      },
      ROW_ID_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "id",
          direction: "ASC"
        });
        queryBuilder.setOrderIsUnique();
      },
      ROW_ID_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "id",
          direction: "DESC"
        });
        queryBuilder.setOrderIsUnique();
      },
      WEBHOOK_ENDPOINT_ID_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "webhook_endpoint_id",
          direction: "ASC"
        });
      },
      WEBHOOK_ENDPOINT_ID_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "webhook_endpoint_id",
          direction: "DESC"
        });
      }
    }
  },
  WebhookEndpointOrderBy: {
    values: {
      IS_ACTIVE_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "is_active",
          direction: "ASC"
        });
      },
      IS_ACTIVE_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "is_active",
          direction: "DESC"
        });
      },
      ORGANIZATION_ID_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "organization_id",
          direction: "ASC"
        });
      },
      ORGANIZATION_ID_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "organization_id",
          direction: "DESC"
        });
      },
      PRIMARY_KEY_ASC(queryBuilder) {
        webhook_endpointUniques[0].attributes.forEach(attributeName => {
          queryBuilder.orderBy({
            attribute: attributeName,
            direction: "ASC"
          });
        });
        queryBuilder.setOrderIsUnique();
      },
      PRIMARY_KEY_DESC(queryBuilder) {
        webhook_endpointUniques[0].attributes.forEach(attributeName => {
          queryBuilder.orderBy({
            attribute: attributeName,
            direction: "DESC"
          });
        });
        queryBuilder.setOrderIsUnique();
      },
      ROW_ID_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "id",
          direction: "ASC"
        });
        queryBuilder.setOrderIsUnique();
      },
      ROW_ID_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "id",
          direction: "DESC"
        });
        queryBuilder.setOrderIsUnique();
      }
    }
  },
  WorkspaceOrderBy: {
    values: {
      ORGANIZATION_ID_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "organization_id",
          direction: "ASC"
        });
      },
      ORGANIZATION_ID_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "organization_id",
          direction: "DESC"
        });
      },
      PRIMARY_KEY_ASC(queryBuilder) {
        workspaceUniques[0].attributes.forEach(attributeName => {
          queryBuilder.orderBy({
            attribute: attributeName,
            direction: "ASC"
          });
        });
        queryBuilder.setOrderIsUnique();
      },
      PRIMARY_KEY_DESC(queryBuilder) {
        workspaceUniques[0].attributes.forEach(attributeName => {
          queryBuilder.orderBy({
            attribute: attributeName,
            direction: "DESC"
          });
        });
        queryBuilder.setOrderIsUnique();
      },
      ROW_ID_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "id",
          direction: "ASC"
        });
        queryBuilder.setOrderIsUnique();
      },
      ROW_ID_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "id",
          direction: "DESC"
        });
        queryBuilder.setOrderIsUnique();
      },
      SLUG_ASC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "slug",
          direction: "ASC"
        });
      },
      SLUG_DESC(queryBuilder) {
        queryBuilder.orderBy({
          attribute: "slug",
          direction: "DESC"
        });
      }
    }
  }
};
export const schema = makeGrafastSchema({
  typeDefs: typeDefs,
  objects: objects,
  interfaces: interfaces,
  inputObjects: inputObjects,
  scalars: scalars,
  enums: enums
});